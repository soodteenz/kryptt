This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document. The content has been processed where security check has been disabled.
Generated by Repomix on: 2025-02-09T22:57:10.879Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: tests/, examples/, docs/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information

## Additional Info

# Directory Structure
```
.github/
  ISSUE_TEMPLATE/
    bug_report.yaml
    feature-request.yml
    question.yaml
  workflows/
    ci.yaml
    publish-pypi.yaml
alpaca/
  broker/
    models/
      __init__.py
      accounts.py
      cip.py
      documents.py
      funding.py
      journals.py
      rebalancing.py
      trading.py
    __init__.py
    client.py
    enums.py
    requests.py
  common/
    __init__.py
    constants.py
    enums.py
    exceptions.py
    models.py
    requests.py
    rest.py
    types.py
    utils.py
  data/
    historical/
      __init__.py
      corporate_actions.py
      crypto.py
      news.py
      option.py
      screener.py
      stock.py
      utils.py
    live/
      __init__.py
      crypto.py
      news.py
      option.py
      stock.py
      websocket.py
    models/
      __init__.py
      bars.py
      base.py
      corporate_actions.py
      news.py
      orderbooks.py
      quotes.py
      screener.py
      snapshots.py
      trades.py
    __init__.py
    enums.py
    mappings.py
    requests.py
    timeframe.py
  trading/
    __init__.py
    client.py
    enums.py
    models.py
    requests.py
    stream.py
  __init__.py
tools/
  scripts/
    generate-docs.sh
.dockerignore
.gitattributes
.gitignore
.pre-commit-config.yaml
cloudbuild.yaml
CODEOWNERS
CONTRIBUTING.md
Dockerfile
LICENSE
Makefile
pyproject.toml
README.md
```

# Files

## File: .github/ISSUE_TEMPLATE/bug_report.yaml
````yaml
name: üêû Bug report
description: Create a bug report to help us improve the SDK
title: "[Bug]: "
labels: [ kind/bug ]
assignees:
  -
body:
  - type: markdown
    attributes:
      value: |
        Thanks for taking the time to fill out this bug report! Please fill the form in English!
  - type: checkboxes
    attributes:
      label: Is there an existing issue for this?
      description: Please search to see if an issue already exists for the bug you encountered.
      options:
        - label: I have searched the existing issues
          required: true
  - type: textarea
    attributes:
      label: Current Behavior
      description: A concise description of what you're experiencing.
      placeholder: |
        When I do <X>, <Y> happens and I see the error message attached below:
        ```...```
    validations:
      required: true

  - type: textarea
    attributes:
      label: Expected Behavior
      description: A concise description of what you expected to happen.
      placeholder: When I do <X>, <Z> should happen instead.
    validations:
      required: false

  - type: textarea
    attributes:
      label: SDK Version I encountered this issue in
      description: |
        What versions of the SDK have you tried in which the issue is present.
        Before opening an issue please make sure you try the latest version of the SDK in case a fix has already been made.
      placeholder: |
        alpaca-py version: 0.x.x
    validations:
      required: true

  - type: textarea
    attributes:
      label: Steps To Reproduce
      description: Steps to reproduce the behavior.
      placeholder: |
        1. In this environment...
        2. With this config...
        3. Run '...'
        4. See error...
      render: markdown
    validations:
      required: true

  - type: checkboxes
    attributes:
      label: Filled out the Steps to Reproduce section?
      description: Please verify you have filled out the above section in regards to attaching steps or code that can reproduce your issue so that Alpaca developers can investigate. Not filling out the section will have your issue flagged as invalid and might not be investigated.
      options:
        - label: I have entered valid steps to reproduce my issue or have attached a minimally reproducible case in code that shows my issue happening; and understand that without this my issue will be flagged as invalid and closed after 30 days.
          required: true

  - type: textarea
    attributes:
      label: Anything else?
      description: |
        Links? References? Anything that will give us more context about the issue you are encountering!
    validations:
      required: false
````

## File: .github/ISSUE_TEMPLATE/feature-request.yml
````yaml
name: üöÄ Feature request
description: As a user, I would like to see this new feature implemented into the SDK
labels: [ kind/feature ]
assignees:
  -
body:
  - type: markdown
    attributes:
      value: |
        Thanks for taking the time to request a feature for Alpaca! Please fill the form in English!
  - type: checkboxes
    attributes:
      label: Is there an existing issue for this?
      description: Please search to see if an issue related to this feature request already exists.
      options:
        - label: I have searched the existing issues
          required: true
  - type: textarea
    attributes:
      label: Is your feature request related to a problem? Please describe.
      description: A concise description of the problem you are facing or the motivetion behind this feature request.
      placeholder: |
        I faced a problem due to which ...
    validations:
      required: true
  - type: textarea
    attributes:
      label: Describe the solution you'd like.
      description: A concise description of the solution for the issue.
    validations:
      required: false
  - type: textarea
    attributes:
      label: Describe an alternate solution.
      description: Is there any other app issue to solve the problem?
    validations:
      required: false
  - type: textarea
    attributes:
      label: Anything else? (Additional Context)
      description: |
        Links? References? Anything that will give us more context about this!
    validations:
      required: false
````

## File: .github/ISSUE_TEMPLATE/question.yaml
````yaml
name: ‚ùì Questions About the SDK ‚ùì
description: I have a question about the SDK I can't find an answer to in the documentation or README.
title: "[Question]: "
labels: [ kind/question ]
assignees:
  -
body:
  - type: markdown
    attributes:
      value: |
        Please fill the form in English!
  - type: checkboxes
    attributes:
      label: Question form pre-submit checklist.
      description: |
        Please verify that all these checkboxes are true before opening an issue.
        If your issue is determined to violate one of the below questions it will be closed for being invalid.
      options:
        - label: I have searched the existing issues to ensure there isn't already an issue about this question.
          required: true
        - label: My question has to do with the Python SDK and isn't a general question about the API. (If it is please open your issue [here](https://github.com/alpacahq/Alpaca-API))
          required: true
        - label: My question isn't about how to do a specific algorithm or asking for trade advice (answers to these are outside the scope of this repo).
          required: true
  - type: textarea
    attributes:
      label: Question
      description: Please describe your question here
      placeholder: |
        I couldn't find an example or documentation on X. How do I do X ?
        ```...```
    validations:
      required: true
````

## File: .github/workflows/ci.yaml
````yaml
name: Run Tests and other CI Steps

on:
  - push
  - pull_request

jobs:
  lints-ci:
    #The lint jobs don't need to run on other OS's or python versions
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      # install poetry first for cache
      - name: setup poetry
        run: pipx install poetry
      - uses: actions/setup-python@v4
        with:
          python-version: 3.11
          cache: "poetry"
      - name: Poetry install
        run: poetry install
      - name: run lint checks
        run: poetry run black --check alpaca/ tests/
      - name: build doc html to lint for errors
        run: ./tools/scripts/generate-docs.sh

  tests-ci:
    strategy:
      fail-fast: false
      matrix:
        python-version: [ "3.8", "3.9", "3.10", "3.11" ] #we'll want to add other versions down the road
        os: [ ubuntu-latest ] #in the future we should add windows here
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      # install poetry first for cache
      - name: setup poetry
        run: pipx install poetry
      - uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
          cache: "poetry"
      - name: Poetry install
        run: poetry install
      - name: run tests
        run: poetry run pytest
````

## File: .github/workflows/publish-pypi.yaml
````yaml
name: Publish python package
on:
  push:
    tags:
      - "v*.*.*"

jobs:

  tests-ci:
    strategy:
      fail-fast: false
      matrix:
        python-version: [ 3.8 ] #we'll want to add other versions down the road
        poetry-version: [ 1.1.13 ]
        os: [ ubuntu-latest ] #in the future we should add windows here
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      # install poetry first for cache
      - name: setup poetry
        run: pipx install poetry
      - uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
          cache: "poetry"
      - name: Poetry install
        run: poetry install
      - name: run tests
        run: poetry run pytest
  build-and-publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build and publish to pypi
        uses: JRubics/poetry-publish@v1.16
        with:
          pypi_token: ${{ secrets.PYPI_API_TOKEN }}
          plugins: "poetry-dynamic-versioning"
````

## File: alpaca/broker/models/__init__.py
````python
from .accounts import *
from .cip import *
from .documents import *
from .funding import *
from .trading import *
from .journals import *
from .rebalancing import *
````

## File: alpaca/broker/models/accounts.py
````python
from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import TypeAdapter, ValidationInfo, field_validator, model_validator

from alpaca.broker.enums import (
    AgreementType,
    ClearingBroker,
    EmploymentStatus,
    FundingSource,
    TaxIdType,
    VisaType,
)
from alpaca.broker.models.documents import AccountDocument
from alpaca.common.models import ModelWithID
from alpaca.common.models import ValidateBaseModel as BaseModel
from alpaca.trading.enums import AccountStatus
from alpaca.trading.models import TradeAccount as BaseTradeAccount


class KycResults(BaseModel):
    """
    Hold information about the result of KYC.
    ref. https://docs.alpaca.markets/reference/getaccount

    Attributes:
        reject (Optional[Dict[str, Any]]): The reason for the rejection
        accept (Optional[Dict[str, Any]]): The reason for the acceptance
        indeterminate (Optional[Dict[str, Any]]): The reason for the indeterminate result
        additional_information (Optional[str]): Used to display a custom message
        summary (Optional[str]): Either pass or fail. Used to indicate if KYC has completed and passed or not.
    """

    reject: Optional[Dict[str, Any]] = None
    accept: Optional[Dict[str, Any]] = None
    indeterminate: Optional[Dict[str, Any]] = None
    additional_information: Optional[str] = None
    summary: Optional[str] = None


class Contact(BaseModel):
    """User contact details within Account Model

    see https://alpaca.markets/docs/broker/api-references/accounts/accounts/#the-account-model

    Attributes:
        email_address (str): The user's email address
        phone_number (str): The user's phone number. It should include the country code.
        street_address (List[str]): The user's street address lines.
        unit (Optional[str]): The user's apartment unit, if any.
        city (str): The city the user resides in.
        state (Optional[str]): The state the user resides in. This is required if country is 'USA'.
        postal_code (str): The user's postal
        country (str): The country the user resides in. 3 letter country code is permissible.
    """

    email_address: str
    phone_number: Optional[str] = None
    street_address: List[str]
    unit: Optional[str] = None
    city: str
    state: Optional[str] = None
    postal_code: Optional[str] = None
    country: Optional[str] = None

    @field_validator("state")
    def usa_state_has_value(cls, v: str, validation: ValidationInfo, **kwargs) -> str:
        """Validates that the state has a value if the country is USA

        Args:
            v (str): The state field's value
            values (dict): The values of each field

        Raises:
            ValueError: State is required for country USA

        Returns:
            str: The value of the state field
        """
        values: dict = validation.data
        if "country" in values and values["country"] == "USA" and v is None:
            raise ValueError("State is required for country USA.")
        return v


class Identity(BaseModel):
    """User identity details within Account Model

    see https://alpaca.markets/docs/broker/api-references/accounts/accounts/#the-account-model

    Attributes:
        given_name (str): The user's first name
        middle_name (Optional[str]): The user's middle name, if any
        family_name (str): The user's last name
        date_of_birth (str): The user's date of birth
        tax_id (Optional[str]): The user's country specific tax id, required if tax_id_type is provided
        tax_id_type (Optional[TaxIdType]): The tax_id_type for the tax_id provided, required if tax_id provided
        country_of_citizenship (Optional[str]): The country the user is a citizen
        country_of_birth (Optional[str]): The country the user was born
        country_of_tax_residence (str): The country the user files taxes
        visa_type (Optional[VisaType]): Only used to collect visa types for users residing in the USA.
        visa_expiration_date (Optional[str]): The date of expiration for visa, Required if visa_type is set.
        date_of_departure_from_usa (Optional[str]): Required if visa_type = B1 or B2
        permanent_resident (Optional[bool]): Only used to collect permanent residence status in the USA.
        funding_source (Optional[List[FundingSource]]): How the user will fund their account
        annual_income_min (Optional[float]): The minimum of the user's income range
        annual_income_max (Optional[float]): The maximum of the user's income range
        liquid_net_worth_min (Optional[float]): The minimum of the user's liquid net worth range
        liquid_net_worth_max (Optional[float]): The maximum of the user's liquid net worth range
        total_net_worth_min (Optional[float]): The minimum of the user's total net worth range
        total_net_worth_max (Optional[float]): The maximum of the user's total net worth range
    """

    given_name: str
    middle_name: Optional[str] = None
    family_name: str
    date_of_birth: Optional[str] = None
    tax_id: Optional[str] = None
    tax_id_type: Optional[TaxIdType] = None
    country_of_citizenship: Optional[str] = None
    country_of_birth: Optional[str] = None
    country_of_tax_residence: str
    visa_type: Optional[VisaType] = None
    visa_expiration_date: Optional[str] = None
    date_of_departure_from_usa: Optional[str] = None
    permanent_resident: Optional[bool] = None
    funding_source: Optional[List[FundingSource]] = None
    annual_income_min: Optional[float] = None
    annual_income_max: Optional[float] = None
    liquid_net_worth_min: Optional[float] = None
    liquid_net_worth_max: Optional[float] = None
    total_net_worth_min: Optional[float] = None
    total_net_worth_max: Optional[float] = None


class Disclosures(BaseModel):
    """User disclosures within Account Model

    see https://alpaca.markets/docs/broker/api-references/accounts/accounts/#the-account-model

    Attributes:
        is_control_person (bool): Whether user holds a controlling position in a publicly traded company
        is_affiliated_exchange_or_finra (bool): If user is affiliated with any exchanges or FINRA
        is_politically_exposed (bool): If user is politically exposed
        immediate_family_exposed (bool): If user‚Äôs immediate family member is either politically exposed or holds a control position.
        employment_status (EmploymentStatus): The employment status of the user
        employer_name (str): The user's employer's name, if any
        employer_address (str): The user's employer's address, if any
        employment_position (str): The user's employment position, if any
    """

    is_control_person: Optional[bool] = None
    is_affiliated_exchange_or_finra: Optional[bool] = None
    is_politically_exposed: Optional[bool] = None
    immediate_family_exposed: bool
    employment_status: Optional[EmploymentStatus] = None
    employer_name: Optional[str] = None
    employer_address: Optional[str] = None
    employment_position: Optional[str] = None


class Agreement(BaseModel):
    """User agreements signed within Account Model

    see https://alpaca.markets/docs/broker/api-references/accounts/accounts/#the-account-model

    Attributes:
        agreement (Agreement): The type of agreement signed by the user
        signed_at (str): The timestamp the agreement was signed
        ip_address (str): The ip_address the signed agreements were sent from by the user
        revision (str): The revision date
    """

    agreement: AgreementType
    signed_at: str
    ip_address: str
    revision: Optional[str] = None


class TrustedContact(BaseModel):
    """User's trusted contact details within Account Model

    see https://alpaca.markets/docs/broker/api-references/accounts/accounts/#the-account-model

    Attributes:given_name
        given_name (str): The first name of the user's trusted contact
        family_name (str): The last name of the user's trusted contact
        email_address (Optional[str]): The email address of the user's trusted contact
        phone_number (Optional[str]): The email address of the user's trusted contact
        city (Optional[str]): The email address of the user's trusted contact
        state (Optional[str]): The email address of the user's trusted contact
        postal_code (Optional[str]): The email address of the user's trusted contact
        country (Optional[str]): The email address of the user's trusted contact
    """

    given_name: str
    family_name: str
    email_address: Optional[str] = None
    phone_number: Optional[str] = None
    street_address: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    postal_code: Optional[str] = None
    country: Optional[str] = None

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        has_phone_number = (
            "phone_number" in values and values["phone_number"] is not None
        )
        has_street_address = (
            "street_address" in values and values["street_address"] is not None
        )
        has_email_address = (
            "email_address" in values and values["email_address"] is not None
        )

        if has_phone_number or has_street_address or has_email_address:
            return values

        raise ValueError("At least one method of contact required for trusted contact")


class Account(ModelWithID):
    """Contains information pertaining to a specific brokerage account

    see https://alpaca.markets/docs/broker/api-references/accounts/accounts/#the-account-model

    The fields contact, identity, disclosures, agreements, documents, trusted_contact, and trading_configurations
    are all optional and won't always be provided by the api depending on what endpoint you use and what options you
    pass

    Attributes:
        id (str): The account uuid used to reference this account
        account_number (str): A more human friendly identifier for this account
        status (AccountStatus): The approval status of this account
        crypto_status (Optional[AccountStatus]): The crypto trading status. Only present if crypto trading is enabled.
        kyc_results (Optional[KycResult]): Hold information about the result of KYC.
        currency (str): The currency the account's values are returned in
        last_equity (str): The total equity value stored in the account
        created_at (str): The timestamp when the account was created
        contact (Optional[Contact]): The contact details for the account holder
        identity (Optional[Identity]): The identity details for the account holder
        disclosures (Optional[Disclosures]): The account holder's political disclosures
        agreements (Optional[List[Agreement]]): The agreements the account holder has signed
        documents (Optional[List[AccountDocument]]): The documents the account holder has submitted
        trusted_contact (Optional[TrustedContact]): The account holder's trusted contact details
    """

    account_number: str
    status: AccountStatus
    crypto_status: Optional[AccountStatus] = None
    kyc_results: Optional[KycResults] = None
    currency: str
    last_equity: str
    created_at: str
    contact: Optional[Contact] = None
    identity: Optional[Identity] = None
    disclosures: Optional[Disclosures] = None
    agreements: Optional[List[Agreement]] = None
    documents: Optional[List[AccountDocument]] = None
    trusted_contact: Optional[TrustedContact] = None

    def __init__(self, **response):
        super().__init__(
            id=(UUID(response["id"])),
            account_number=(response["account_number"]),
            status=(response["status"]),
            crypto_status=(
                response["crypto_status"] if "crypto_status" in response else None
            ),
            kyc_results=(
                TypeAdapter(KycResults).validate_python(response["kyc_results"])
                if "kyc_results" in response and response["kyc_results"] is not None
                else None
            ),
            currency=(response["currency"]),
            last_equity=(response["last_equity"]),
            created_at=(response["created_at"]),
            contact=(
                TypeAdapter(Contact).validate_python(response["contact"])
                if "contact" in response
                else None
            ),
            identity=(
                TypeAdapter(Identity).validate_python(response["identity"])
                if "identity" in response
                else None
            ),
            disclosures=(
                TypeAdapter(Disclosures).validate_python(response["disclosures"])
                if "disclosures" in response
                else None
            ),
            agreements=(
                TypeAdapter(List[Agreement]).validate_python(response["agreements"])
                if "agreements" in response
                else None
            ),
            documents=(
                TypeAdapter(List[AccountDocument]).validate_python(
                    response["documents"]
                )
                if "documents" in response
                else None
            ),
            trusted_contact=(
                TypeAdapter(TrustedContact).validate_python(response["trusted_contact"])
                if "trusted_contact" in response
                else None
            ),
        )


class TradeAccount(BaseTradeAccount):
    """
    See Base TradeAccount model in common for full details on available fields.
    Represents trading account information for an Account.

    Attributes:
        cash_withdrawable (Optional[str]): Cash available for withdrawal from the account
        cash_transferable (Optional[str]): Cash available for transfer (JNLC) from the account
        previous_close (Optional[datetime]): Previous sessions close time
        last_long_market_value (Optional[str]): Value of all long positions as of previous trading day at 16:00:00 ET
        last_short_market_value (Optional[str]): Value of all short positions as of previous trading day at 16:00:00 ET
        last_cash (Optional[str]): Value of all cash as of previous trading day at 16:00:00 ET
        last_initial_margin (Optional[str]): Value of initial_margin as of previous trading day at 16:00:00 ET
        last_regt_buying_power (Optional[str]): Value of regt_buying_power as of previous trading day at 16:00:00 ET
        last_daytrading_buying_power (Optional[str]): Value of daytrading_buying_power as of previous trading day at 16:00:00 ET
        last_daytrade_count (Optional[int]): Value of daytrade_count as of previous trading day at 16:00:00 ET
        last_buying_power (Optional[str]): Value of buying_power as of previous trading day at 16:00:00 ET
        clearing_broker (Optional[ClearingBroker]): The Clearing broker for this account
    """

    cash_withdrawable: Optional[str]
    cash_transferable: Optional[str]
    previous_close: Optional[datetime]
    last_long_market_value: Optional[str]
    last_short_market_value: Optional[str]
    last_cash: Optional[str]
    last_initial_margin: Optional[str]
    last_regt_buying_power: Optional[str]
    last_daytrading_buying_power: Optional[str]
    last_daytrade_count: Optional[int]
    last_buying_power: Optional[str]
    clearing_broker: Optional[ClearingBroker]
````

## File: alpaca/broker/models/cip.py
````python
from datetime import datetime
from typing import List, Optional
from uuid import UUID

from alpaca.common.models import ModelWithID, ValidateBaseModel as BaseModel

from alpaca.broker.enums import CIPApprovalStatus, CIPProvider, CIPResult, CIPStatus


class CIPKYCInfo(BaseModel):
    """
    Represents Know Your Customer (KYC) info for a CIPInfo

    Attributes:
        id (str): Your internal ID of check
        risk_score (Optional[int]): Overall risk score returned by KYC provider or assessed
        risk_level (Optional[str]): Overall risk level returned by KYC provider or assessed
        risk_categories (Optional[List[str]]): The list of risk categories returned by the KYC provider or assessed
        applicant_name (Optional[str]): Given and family name of applicant
        email_address (Optional[str]): email address of applicant
        nationality (Optional[str]): nationality of applicant
        date_of_birth (Optional[datetime]): DOB of applicant
        address (Optional[str]): Concatenated street address, city, state and country of applicant
        postal_code (Optional[str]): postal code for `address` field
        country_of_residency (Optional[str]): country for `address` field
        kyc_completed_at (Optional[datetime]): Datetime that KYC check was completed at
        ip_address (Optional[str]): ip address of applicant at time of KYC check
        check_initiated_at (Optional[datetime]): start datetime of KYC check
        check_completed_at (Optional[datetime]): completion datetime of KYC check
        approval_status (Optional[CIPApprovalStatus]): Approval status of KYC check
        approved_by (Optional[str]): Identifier of who approved KYC check
        approved_reason (Optional[str]): Reason for approving this KYC check
        approved_at (Optional[datetime]): Datetime that this KYC check was approved
    """

    id: str
    risk_score: Optional[int] = None
    risk_level: Optional[str] = None
    risk_categories: Optional[List[str]] = None
    applicant_name: Optional[str] = None
    email_address: Optional[str] = None
    nationality: Optional[str] = None
    date_of_birth: Optional[datetime] = None
    address: Optional[str] = None
    postal_code: Optional[str] = None
    country_of_residency: Optional[str] = None
    kyc_completed_at: Optional[datetime] = None
    ip_address: Optional[str] = None
    check_initiated_at: Optional[datetime] = None
    check_completed_at: Optional[datetime] = None
    approval_status: Optional[CIPApprovalStatus] = None
    approved_by: Optional[str] = None
    approved_reason: Optional[str] = None
    approved_at: Optional[datetime] = None


class CIPDocument(BaseModel):
    """
    Represents results of checking a document for CIPInfo

    Attributes:
        id (str): Your internal ID of check
        result (Optional[CIPResult]): Overall result of specific check
        status (Optional[CIPStatus]): Overall status of specific check
        created_at (Optional[datetime]): Datetime for when this check was done
        date_of_birth (Optional[datetime]): DOB for applicant if found on document
        date_of_expiry (Optional[datetime]): date of expiry for the checked document
        document_numbers (Optional[List[str]]): Number of the document that was checked
        document_type (Optional[str]): Type of the document that was checked
        first_name (Optional[str]): First name extracted from the document
        last_name (Optional[str]): Last name extracted from the document
        gender (Optional[str]): Gender info extracted from the document
        issuing_country (Optional[str]): Country for which issued the document
        nationality (Optional[str]): Nationality extracted from the document
        age_validation (Optional[CIPResult]): Result of checks on whether the age calculated from the document‚Äôs date
          of birth data point is greater than or equal to the minimum accepted age set at account level
        compromised_document (Optional[CIPResult]): Result of check on whether the image of the document has been found
          in our internal database of compromised documents
        police_record (Optional[CIPStatus]): Result of check on whether the document has been identified as lost,
          stolen or otherwise compromised
        data_comparison (Optional[CIPResult]): Result of check on whether data on the document is consistent with data
          provided when creating an applicant through the API
        data_comparison_breakdown (Optional[str]): json object representing the results of the various sub-checks
          done when calculating the result on `data_comparison`. Example: {‚Äúdate_of_birth‚Äù: ‚Äúclear‚Äù,
          ‚Äúdate_of_expiry‚Äù: ‚Äúclear‚Äù ‚Äúdocument_numbers‚Äù: ‚Äúclear‚Äù, ‚Äúdocument_type‚Äù: ‚Äúclear‚Äù, ‚Äúfirst_name‚Äù: ‚Äúclear‚Äù,
          ‚Äúgender‚Äù: ‚Äúclear‚Äù, ‚Äúissuing_country‚Äù: ‚Äúclear‚Äù, ‚Äúlast_name‚Äù: ‚Äúclear‚Äù}
        image_integrity (Optional[CIPResult]): Result of checks on whether the document was of sufficient quality to
          verify
        image_integrity_breakdown (Optional[str]): json object representing the results of the various sub-checks done
          when calculating the result on `image_integrity`. Example: example: {‚Äúcolour_picture‚Äù: ‚Äúclear‚Äù,
          ‚Äúconclusive_document_quality‚Äù: ‚Äúclear‚Äù, ‚Äúimage_quality‚Äù: ‚Äúclear‚Äù, ‚Äúsupported_document‚Äù: ‚Äúclear‚Äù}
        visual_authenticity (Optional[str]): json object representing the the various sub-checks done when determening
          whether visual (non-textual) elements are correct given the document type. Example: {
          ‚Äúdigital_tampering‚Äù: ‚Äúclear‚Äù, ‚Äúface_detection‚Äù: ‚Äúclear‚Äù, ‚Äúfonts‚Äù: ‚Äúclear‚Äù, ‚Äúoriginal_document_present‚Äù:
          ‚Äúclear‚Äù, ‚Äúpicture_face_integrity‚Äù: ‚Äúclear‚Äù, ‚Äúsecurity_features‚Äù: ‚Äúclear‚Äù, ‚Äútemplate‚Äù: ‚Äúclear‚Äù}

    """

    id: str
    result: Optional[CIPResult] = None
    status: Optional[CIPStatus] = None
    created_at: Optional[datetime] = None
    date_of_birth: Optional[datetime] = None
    date_of_expiry: Optional[datetime] = None
    document_numbers: Optional[List[str]] = None
    document_type: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    gender: Optional[str] = None
    issuing_country: Optional[str] = None
    nationality: Optional[str] = None
    age_validation: Optional[CIPResult] = None
    compromised_document: Optional[CIPResult] = None
    police_record: Optional[CIPStatus] = None
    data_comparison: Optional[CIPResult] = None
    data_comparison_breakdown: Optional[str] = None
    image_integrity: Optional[CIPResult] = None
    image_integrity_breakdown: Optional[str] = None
    visual_authenticity: Optional[str] = None


class CIPPhoto(BaseModel):
    """
    Represents the results of checking a Photo for CIPInfo

    Attributes:
        id (str): Your internal ID of check
        result (Optional[CIPResult]): Overall result of check
        status (Optional[CIPStatus]): Overall status of check
        created_at (Optional[datetime]): datetime of when check happened
        face_comparision (Optional[CIPResult]): Checks whether the face in the document matches the face in the
          live photo
        face_comparison_breakdown (Optional[str]): a json object representing the breakdown of sub-checks done in
          `face_comparison`. Example: {‚Äúface_match‚Äù:{‚Äúresult‚Äù: ‚Äúclear‚Äù,‚Äúproperties‚Äù:{‚Äúscore‚Äù: ‚Äú80‚Äù}}}
        image_integrity (Optional[CIPResult]): Checks whether the quality and integrity of the uploaded files were
          sufficient to perform a face comparison
        image_integrity_breakdown (Optional[str]): a json object representing the breakdown of sub-checks done in
          `image_integrity`. Example  {‚Äúface_detected‚Äù:{‚Äúresult‚Äù: ‚Äúclear‚Äù},‚Äúsource_integrity‚Äù: {‚Äúresult‚Äù: ‚Äúclear‚Äù}}
        visual_authenticity (Optional[CIPResult]): Checks whether the person in the live photo is real (not a spoof)
        visual_authenticity_breakdown (Optional[str]): a json object representing the breakdown of sub-checks don in
          `visual_authenticity`. Example {‚Äúspoofing_detection‚Äù: {‚Äúresult‚Äù: ‚Äúclear‚Äù,‚Äúproperties‚Äù: {‚Äúscore‚Äù: ‚Äú26‚Äù}}}}
    """

    id: str
    result: Optional[CIPResult] = None
    status: Optional[CIPStatus] = None
    created_at: Optional[datetime] = None
    face_comparision: Optional[CIPResult] = None
    face_comparison_breakdown: Optional[str] = None
    image_integrity: Optional[CIPResult] = None
    image_integrity_breakdown: Optional[str] = None
    visual_authenticity: Optional[CIPResult] = None
    visual_authenticity_breakdown: Optional[str] = None


class CIPIdentity(BaseModel):
    """
    Represents the results of running an identity check for a CIPInfo

    Attributes:
        id (str): Your internal ID of check
        result (Optional[CIPResult]): Overall result of check
        status (Optional[CIPStatus]): Overall status of check
        created_at (Optional[datetime]): datetime when identity check happened
        matched_address (Optional[CIPResult]): Represents of the address matched for the applicant
        matched_addresses (Optional[str]): a json object representing the results of the check done in `matched_address`
          Example: [{‚Äúid‚Äù: ‚Äú19099121‚Äù,‚Äúmatch_types‚Äù:[‚Äúcredit_agencies‚Äù,‚Äúvoting_register‚Äù]}]
        sources (Optional[CIPResult]):  Shows the total number of sources found for applicant‚Äôs identity.
          (TODO: What? This doesnt make any sense its a CIPResult not a number but that's whats in the docs)
        sources_breakdown (Optional[str]): a json object representing the breakdown of `sources` field. For example:
          {‚Äútotal_sources‚Äù: {‚Äúresult‚Äù: ‚Äúclear‚Äù,‚Äúproperties‚Äù: {‚Äútotal_number_of_sources‚Äù: ‚Äú3‚Äù}}}
        address (Optional[CIPResult]): Result if it was cleared against a data source
        address_breakdown (Optional[str]): a json object representing the breakdown of the `address` field. For example:
          {‚Äúcredit_agencies‚Äù: {‚Äúresult‚Äù: ‚Äúclear‚Äù,‚Äúproperties‚Äù:{‚Äúnumber_of_matches‚Äù:‚Äú1‚Äù}}
        date_of_birth (Optional[CIPResult]): Result if it was cleared against a data source
        date_of_birth_breakdown (Optional[str]): a json object representing the breakdown of the `date_of_birth` field.
          For example: example: {‚Äúcredit_agencies‚Äù:{‚Äúresult‚Äù: ‚Äúclear‚Äù,‚Äúproperties‚Äù: {‚Äúnumber_of_matches‚Äù: ‚Äú1‚Äù}}
        tax_id (Optional[CIPResult]): Result if it was cleared against a data source
        tax_id_breakdown (Optional[str]): a json object representing the breakdown of the `tax_id` field
    """

    id: str
    result: Optional[CIPResult] = None
    status: Optional[CIPStatus] = None
    created_at: Optional[datetime] = None
    matched_address: Optional[CIPResult] = None
    matched_addresses: Optional[str] = None
    sources: Optional[CIPResult] = None
    sources_breakdown: Optional[str] = None
    address: Optional[CIPResult] = None
    address_breakdown: Optional[str] = None
    date_of_birth: Optional[CIPResult] = None
    date_of_birth_breakdown: Optional[str] = None
    tax_id: Optional[CIPResult] = None
    tax_id_breakdown: Optional[str] = None


class CIPWatchlist(BaseModel):
    """
    Represents the result of checking to see if the applicant is in any watchlists for a CIPInfo

    TODO: We're missing almost entirely documentation in prod for this as well as even internal documentation
      no clue what these fields are supposed to be or if they're even close to correct.

    Attributes:
        id (str): Your internal ID of check
        result (Optional[CIPResult]): Overall result of specific check
        status (Optional[CIPStatus]): Overall status of specific check
        created_at (Optional[datetime]): datetime when check happened
        records (Optional[str]): a json object. Example [{‚Äútext‚Äù: ‚ÄúRecord info‚Äù}]
        politically_exposed_person (Optional[CIPResult]): Result if it was cleared against a data source
        sanction (Optional[CIPResult]): Result if it was cleared against a data source
        adverse_media (Optional[CIPResult]): Result if it was cleared against a data source
        monitored_lists (Optional[CIPResult]): Result if it was cleared against a data source
    """

    id: str
    result: Optional[CIPResult] = None
    status: Optional[CIPStatus] = None
    created_at: Optional[datetime] = None
    records: Optional[str] = None
    politically_exposed_person: Optional[CIPResult] = None
    sanction: Optional[CIPResult] = None
    adverse_media: Optional[CIPResult] = None
    monitored_lists: Optional[CIPResult] = None


class CIPInfo(ModelWithID):
    """
    The Customer Identification Program (CIP) API allows you to submit the CIP results received from your KYC provider.

    This model is how to represent that information when talking to Alpaca

    Args:
        id (UUID): ID of this CIPInfo
        account_id (UUID): UUID of the Account instance this CIPInfo is for
        provider_name (List[CIPProvider]): List of KYC providers this information came from
        created_at (datetime): date and time this CIPInfo was first uploaded to Alpaca
        updated_at (datetime): date and time that this CIPInfo was last update
        kyc (Optional[CIPKYCInfo]): KYC info for this Account if any
        document (Optional[CIPDocument]): Any CIP documents uploaded for this Account
        photo (Optional[CIPPhoto]): Any photos attached for CIP
        identity (Optional[CIPIdentity]): Any CIP Identity information
        watchlist (Optional[CIPWatchlist]): Any CIP watchlist information
    """

    account_id: UUID
    provider_name: List[CIPProvider]
    created_at: datetime
    updated_at: datetime
    kyc: Optional[CIPKYCInfo] = None
    document: Optional[CIPDocument] = None
    photo: Optional[CIPPhoto] = None
    identity: Optional[CIPIdentity] = None
    watchlist: Optional[CIPWatchlist] = None

    def __init__(self, *args, **kwargs):
        # upcast into uuid
        if "id" in kwargs and type(kwargs["id"]) == str:
            kwargs["id"] = UUID(kwargs["id"])

        if "account_id" in kwargs and type(kwargs["account_id"]) == str:
            kwargs["account_id"] = UUID(kwargs["account_id"])

        super().__init__(*args, **kwargs)
````

## File: alpaca/broker/models/documents.py
````python
from datetime import date as datetime_date
from datetime import datetime
from ipaddress import IPv4Address, IPv6Address
from typing import Any, Optional, Union
from uuid import UUID

from pydantic import model_validator

from alpaca.broker.enums import DocumentType, TradeDocumentSubType, TradeDocumentType
from alpaca.common.models import ModelWithID
from alpaca.common.models import ValidateBaseModel as BaseModel

IPAddress = Union[IPv4Address, IPv6Address]


class AccountDocument(BaseModel):
    """
    User documents provided within Account Model.

    This model is different from the TradeDocument model in that this model represents documents having to do with a
    brokerage Account.

    see https://alpaca.markets/docs/broker/api-references/accounts/accounts/#the-account-model

    Attributes:
        id (UUID): ID of the Document
        document_type (DocumentType): The type of document uploaded
        document_sub_type (Optional[str]): The specific type of document, e.g. passport
        name (Optional(str)): Name of the document if present
        content (str): Base64 string representing the document
        mime_type (str): The format of content encoded by the string
    """

    id: Optional[UUID]
    document_type: Optional[DocumentType]
    document_sub_type: Optional[str] = None
    content: Optional[str] = None
    mime_type: Optional[str] = None

    def __init__(self, **data: Any) -> None:
        # validate the incoming id field for uuid
        _id = data.get("id", None)
        if isinstance(_id, str):
            data["id"] = UUID(_id)

        super().__init__(**data)


class TradeDocument(ModelWithID):
    """
    Similar to the AccountDocument model but this represents documents having to do with a TradeAccount not a regular
    Account.

    IE:  Account Monthly Statements or Trade Confirmations.

    Attributes:
        id (UUID): Unique id of the TradeDocument
        name (str): Name of the document
        type (TradeDocumentType): The kind of TradeDocument this is
        sub_type (Optional[TradeDocumentSubType]): The subtype of the document. The API returns "" in the case of this
          not being specified, however we transform this case into None for convenience.
        date (date): Date on when this TradeDocument was generated
    """

    name: str
    type: TradeDocumentType
    sub_type: Optional[TradeDocumentSubType] = None
    date: datetime_date

    def __init__(self, **data: Any) -> None:
        if "id" in data and isinstance(data["id"], str):
            data["id"] = UUID(data["id"])

        if "sub_type" in data and data["sub_type"] == "":
            data["sub_type"] = None

        super().__init__(**data)


class W8BenDocument(BaseModel):
    """
    Represents the information normally contained in a W8BEN document as fields for convenience if you don't
    want to upload a file.

    Please see https://docs.alpaca.markets/docs/international-accounts
    for more information.

    TODO: None of the docs or code explain what any of these fields mean. Guessing based on name alone for
      all of them; but we really need the docs updated.

    Attributes:
        additional_conditions (Optional[str]): Any additional conditions to specify
        country_citizen (str): The Country that the applicant is a citizen of
        date (date): date signed
        date_of_birth (date): DOB of applicant
        foreign_tax_id (Optional[str]): Applicant's tax id in their home country
        ftin_not_required (Optional[bool]): Required if foreign_tax_id and tax_id_ssn are empty.
        full_name (str): Full name of applicant
        income_type (Optional[str]): income type of applicant
        ip_address (IPAddress): ip address of applicant when signed
        mailing_address_city_state (Optional[str]): mailing city/state of applicant
        mailing_address_country (Optional[str]): mailing country for applicant
        mailing_address_street (Optional[str]): mailing street address for applicant
        paragraph_number (Optional[str]): TODO: get documentation for this field
        percent_rate_withholding (Optional[str]): TODO: get documentation for this field
        permanent_address_city_state (str): permanent city/state of applicant
        permanent_address_country (str): permanent country of residence of applicant
        permanent_address_street (str): permanent street address of applicant
        reference_number (Optional[str]): TODO: Get documentation for this field
        residency (Optional[str]): Country of residency of applicant
          TODO: get real documentation for this field. current is just guess based on example
        revision (str): Revision of the W8BEN form
        signer_full_name (str): Full name of signing user
        tax_id_ssn (Optional[str]): TaxID/SSN of applicant
        timestamp (datetime): timestamp when form data was gathered
    """

    country_citizen: str
    date: datetime_date
    date_of_birth: datetime_date
    full_name: str
    ip_address: IPAddress
    permanent_address_city_state: str
    permanent_address_country: str
    permanent_address_street: str
    revision: str
    signer_full_name: str
    timestamp: datetime

    # optional fields
    additional_conditions: Optional[str] = None
    foreign_tax_id: Optional[str] = None
    ftin_not_required: Optional[bool] = None
    income_type: Optional[str] = None
    mailing_address_city_state: Optional[str] = None
    mailing_address_country: Optional[str] = None
    mailing_address_street: Optional[str] = None
    paragraph_number: Optional[str] = None
    percent_rate_withholding: Optional[str] = None
    reference_number: Optional[str] = None
    residency: Optional[str] = None
    tax_id_ssn: Optional[str] = None

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        foreign_tax_set = (
            "foreign_tax_id" in values and values["foreign_tax_id"] is not None
        )
        tax_id_set = "tax_id_ssn" in values and values["tax_id_ssn"] is not None
        ftin_set = (
            "ftin_not_required" in values and values["ftin_not_required"] is not None
        )

        if not foreign_tax_set and not tax_id_set and not ftin_set:
            raise ValueError(
                "ftin_not_required must be set if foreign_tax_id and tax_id_ssn are not"
            )

        return values
````

## File: alpaca/broker/models/funding.py
````python
from datetime import datetime
from typing import Optional
from uuid import UUID

from alpaca.broker.enums import (
    ACHRelationshipStatus,
    BankAccountType,
    BankStatus,
    IdentifierType,
    TransferType,
    TransferStatus,
    TransferDirection,
    FeePaymentMethod,
)
from alpaca.common.models import ModelWithID


class ACHRelationship(ModelWithID):
    """
    Attributes:
        id (UUID): ID of Relationship
        account_id (UUID): ID of the Account this ACHRelationship is tied to
        created_at (datetime): Date and time this relationship was created
        updated_at (datetime): Date and time of when this relationship was last updated
        status (ACHRelationshipStatus): Current status of the relationship
        account_owner_name (str): Full name of the account owner
        bank_account_type (BankAccountType): The kind of bank account this relationship points to
        bank_account_number (str): The number of bank account that the relationship points to
        bank_routing_number (str): Routing number for the bank account
        nickname (str): User provided name for account
        processor_token (Optional[str]): If you are using Plaid, then this is a Plaid processor token.
    """

    account_id: UUID
    created_at: datetime
    updated_at: datetime
    status: ACHRelationshipStatus
    account_owner_name: str
    bank_account_type: BankAccountType
    bank_account_number: str
    bank_routing_number: str
    nickname: Optional[str] = None
    processor_token: Optional[str] = None


class Bank(ModelWithID):
    """
    Attributes:
        id (UUID): ID of Bank.
        account_id (UUID): ID of the Account this Bank is tied to.
        created_at (datetime): Date and time this Bank was created.
        updated_at (datetime): Date and time of when this Bank was last updated.
        name (str): Name of the bank.
        status (BankStatus): The status of the bank connection.
        country (str): Country where bank account is located.
        state_province (str): State/Province where bank is located.
        postal_code (str): Postal code where bank is located.
        city (str): City where bank is located.
        street_address (str): Street address where bank is located.
        account_number (str): The bank account number.
        bank_code (str): The bank account code.
        bank_code_type (IdentifierType): The bank identifier.
    """

    account_id: UUID
    created_at: datetime
    updated_at: datetime
    name: str
    status: BankStatus
    country: str
    state_province: str
    postal_code: str
    city: str
    street_address: str
    account_number: str
    bank_code: str
    bank_code_type: IdentifierType


class Transfer(ModelWithID):
    """
    Attributes:
        id (UUID): ID of Transfer.
        account_id (UUID): ID of the Account this Transfer is tied to.
        created_at (datetime): Date and time when this Transfer was created.
        updated_at (datetime): Date and time of when this Transfer was last updated.
        expires_at (datetime): Date and time of when this Transfer will expire.
        relationship_id (UUID): ID of the funding relationship used to make the transfer.
        amount (str): The amount the recipient will receive after any applicable fees are deducted.
        type (TransferType): The type of transfer.
        status (TransferStatus): The status of the transfer.
        direction (TransferDirection): The direction of the transfer.
        reason (Optional[str]): Reasoning associated with the current status.
        requested_amount (Optional[str]): Amount entered upon creation of a transfer entity.
        fee (Optional[str]): Dollar amount of any applicable fees.
        fee_payment_method (Optional[FeePaymentMethod]): Denotes how any applicable fees will be paid.
        additional_information (Optional[str]): Additional information provided with wire transfers.
    """

    account_id: UUID
    created_at: datetime
    updated_at: Optional[datetime] = None
    expires_at: Optional[datetime] = None
    relationship_id: Optional[UUID] = None
    bank_id: Optional[UUID] = None
    amount: str
    type: TransferType
    status: TransferStatus
    direction: TransferDirection
    reason: Optional[str] = None
    requested_amount: Optional[str] = None
    fee: Optional[str] = None
    fee_payment_method: Optional[FeePaymentMethod] = None
    additional_information: Optional[str] = None
````

## File: alpaca/broker/models/journals.py
````python
from datetime import date
from typing import Optional
from uuid import UUID

from alpaca.broker.enums import JournalEntryType, JournalStatus
from alpaca.common.models import ModelWithID
from alpaca.common.enums import SupportedCurrencies


class Journal(ModelWithID):
    """
    Represents a transfer of cash or securities from one account to another.

    There are two types of journals Cash Journals and Security Journals.

    **Travel Rule**
    In an effort to fight the criminal financial transactions, FinCEN enacted the
    Travel Rule that applies to fund transfers of more than $3,000.
    When you use Journal API to bundle a bulk of transfers for the end-users, you will need to tell about
    the breakdown and each transmitter information using the optional fields of the POST request.

    Learn more about journals here: https://alpaca.markets/docs/api-references/broker-api/journals/

    Attributes:
        id (UUID): The journal ID
        to_account (UUID): The account ID that received the journal.
        from_account (UUID): The account ID that initiates the journal.
        entry_type (JournalEntryType): Whether the journal is a cash or security journal.
        status (JournalStatus): The lifecycle status of the journal.
        symbol (Optional[str]): For security journals, the symbol identifier of the security being journaled.
        qty (Optional[float]): For security journals, the quantity of the security being journaled.
        price (Optional[float]): For security journals, the price at which the security is being journaled at.
        net_amount (Optional[float]): For cash journals, the total cash amount journaled
        description (Optional[str]): Journal description. It can include fixtures for sandbox API.
        settle_date (Optional[date]):
        system_date (Optional[date]):
        transmitter_name (Optional[str]): For cash journals, travel rule related name info.
        transmitter_account_number (Optional[str]): For cash journals, travel rule account number info.
        transmitter_address (Optional[str]): For cash journals, travel rule related address info.
        transmitter_financial_institution (Optional[str]): For cash journals, travel rule related institution info.
        transmitter_timestamp (Optional[str]): For cash journals, travel rule related timestamp info.
    """

    to_account: UUID
    from_account: UUID
    entry_type: JournalEntryType
    status: JournalStatus
    net_amount: Optional[float] = None
    symbol: Optional[str] = None
    qty: Optional[float] = None
    price: Optional[float] = None
    description: Optional[str] = None
    settle_date: Optional[date] = None
    system_date: Optional[date] = None
    transmitter_name: Optional[str] = None
    transmitter_account_number: Optional[str] = None
    transmitter_address: Optional[str] = None
    transmitter_financial_institution: Optional[str] = None
    transmitter_timestamp: Optional[str] = None
    currency: Optional[SupportedCurrencies] = None


class BatchJournalResponse(Journal):
    """
    Represents a journal response from a batch journal request.

    Attributes:
        error_message (Optional[str]): An message that contains error details for failed journals.
    """

    error_message: Optional[str] = None
````

## File: alpaca/broker/models/rebalancing.py
````python
from datetime import datetime
from typing import List, Optional
from uuid import UUID

from alpaca.broker.enums import PortfolioStatus, RunInitiatedFrom, RunStatus, RunType
from alpaca.broker.models import Order
from alpaca.broker.requests import RebalancingConditions, Weight
from alpaca.common.models import ValidateBaseModel as BaseModel


class Portfolio(BaseModel):
    """
    Portfolio response model.

    https://docs.alpaca.markets/reference/get-v1-rebalancing-portfolios
    """

    id: UUID
    name: str
    description: str
    status: PortfolioStatus
    cooldown_days: int
    created_at: datetime
    updated_at: datetime
    weights: List[Weight]
    rebalance_conditions: Optional[List[RebalancingConditions]] = None


class Subscription(BaseModel):
    """
    Subscription response model.

    https://docs.alpaca.markets/reference/get-v1-rebalancing-subscriptions-1
    """

    id: UUID
    account_id: UUID
    portfolio_id: UUID
    created_at: datetime
    last_rebalanced_at: Optional[datetime] = None


class SkippedOrder(BaseModel):
    """
    Skipped order response model.

    https://docs.alpaca.markets/reference/get-v1-rebalancing-runs-run_id-1
    """

    symbol: str
    side: Optional[str] = None
    notional: Optional[str] = None
    currency: Optional[str] = None
    reason: str
    reason_details: str


class RebalancingRun(BaseModel):
    """
    Rebalancing run response model.

    https://docs.alpaca.markets/reference/get-v1-rebalancing-runs
    """

    id: UUID
    account_id: UUID
    type: RunType
    amount: Optional[str] = None
    portfolio_id: UUID
    weights: List[Weight]
    initiated_from: Optional[RunInitiatedFrom] = None
    created_at: datetime
    updated_at: datetime
    completed_at: Optional[datetime] = None
    canceled_at: Optional[datetime] = None
    status: RunStatus
    reason: Optional[str] = None
    orders: Optional[List[Order]] = None
    failed_orders: Optional[List[Order]] = None
    skipped_orders: Optional[List[SkippedOrder]] = None
````

## File: alpaca/broker/models/trading.py
````python
from typing import Optional
from alpaca.trading.models import Order as BaseOrder


class Order(BaseOrder):
    """
    See base alpaca.trading.models.Order model for full list of base attributes.

    Attributes:
        commission (float): The dollar value commission you want to charge the end user.
    """

    commission: Optional[float] = None
````

## File: alpaca/broker/__init__.py
````python
from alpaca.broker.client import BrokerClient
from alpaca.broker.enums import *
from alpaca.broker.models import *
from alpaca.broker.requests import *

__all__ = [
    "BrokerClient",
]
````

## File: alpaca/broker/client.py
````python
import base64
import warnings
from typing import Any, Callable, Dict, Iterator, List, Optional, Type, Union
from uuid import UUID

import sseclient
from pydantic import TypeAdapter
from requests import HTTPError, Response

from alpaca.broker.enums import ACHRelationshipStatus
from alpaca.broker.models import (
    Account,
    ACHRelationship,
    Bank,
    BaseModel,
    BatchJournalResponse,
    Journal,
    Order,
    Portfolio,
    RebalancingRun,
    Subscription,
    TradeAccount,
    TradeDocument,
    Transfer,
)
from alpaca.broker.requests import (
    CreateAccountRequest,
    CreateACHRelationshipRequest,
    CreateACHTransferRequest,
    CreateBankRequest,
    CreateBankTransferRequest,
    CreateBatchJournalRequest,
    CreateJournalRequest,
    CreateOptionExerciseRequest,
    CreatePlaidRelationshipRequest,
    CreatePortfolioRequest,
    CreateReverseBatchJournalRequest,
    CreateRunRequest,
    CreateSubscriptionRequest,
    GetAccountActivitiesRequest,
    GetEventsRequest,
    GetJournalsRequest,
    GetPortfoliosRequest,
    GetRunsRequest,
    GetSubscriptionsRequest,
    GetTradeDocumentsRequest,
    GetTransfersRequest,
    ListAccountsRequest,
    OrderRequest,
    UpdateAccountRequest,
    UpdatePortfolioRequest,
    UploadDocumentRequest,
)
from alpaca.common import RawData
from alpaca.common.constants import (
    ACCOUNT_ACTIVITIES_DEFAULT_PAGE_SIZE,
    BROKER_DOCUMENT_UPLOAD_LIMIT,
)
from alpaca.common.enums import BaseURL, PaginationType
from alpaca.common.exceptions import APIError
from alpaca.common.rest import HTTPResult, RESTClient
from alpaca.common.utils import (
    validate_symbol_or_asset_id,
    validate_symbol_or_contract_id,
    validate_uuid_id_param,
)
from alpaca.trading.enums import ActivityType
from alpaca.trading.models import AccountConfiguration as TradeAccountConfiguration
from alpaca.trading.models import (
    AllAccountsPositions,
    Asset,
    BaseActivity,
    Calendar,
    Clock,
    ClosePositionResponse,
    CorporateActionAnnouncement,
    NonTradeActivity,
    PortfolioHistory,
    Position,
    TradeActivity,
    Watchlist,
)
from alpaca.trading.requests import (
    CancelOrderResponse,
    ClosePositionRequest,
    CreateWatchlistRequest,
    GetAssetsRequest,
    GetCalendarRequest,
    GetCorporateAnnouncementsRequest,
    GetOrderByIdRequest,
    GetOrdersRequest,
    GetPortfolioHistoryRequest,
    ReplaceOrderRequest,
    UpdateWatchlistRequest,
)

from ..common import RawData
from ..common.rest import HTTPResult, RESTClient
from .enums import ACHRelationshipStatus
from .requests import (
    CreateAccountRequest,
    CreateACHRelationshipRequest,
    CreateACHTransferRequest,
    CreateBankRequest,
    CreateBankTransferRequest,
    CreateBatchJournalRequest,
    CreateJournalRequest,
    CreatePlaidRelationshipRequest,
    CreateReverseBatchJournalRequest,
    GetAccountActivitiesRequest,
    GetEventsRequest,
    GetJournalsRequest,
    GetTradeDocumentsRequest,
    GetTransfersRequest,
    ListAccountsRequest,
    OrderRequest,
    UpdateAccountRequest,
    UploadDocumentRequest,
    UploadW8BenDocumentRequest,
)


class BrokerClient(RESTClient):
    """
    Client for accessing Broker API services

    **Note on the `handle_pagination` param you'll see across these methods**

    By default, these methods will attempt to handle the fact that the API paginates results for the specific endpoint
    for you by returning it all as one List.

    However, that could:

    1. Take a long time if there are many results to paginate or if you request a small page size and have moderate
    network latency
    2. Use up a large amount of memory to build all the results at once

    So for those cases where a single list all at once would be prohibitive you can specify what kind of pagination you
    want with the `handle_pagination` parameter. Please see the PaginationType enum for an explanation as to what the
    different values mean for what you get back.
    """

    def __init__(
        self,
        api_key: Optional[str] = None,
        secret_key: Optional[str] = None,
        api_version: str = "v1",
        sandbox: bool = True,
        raw_data: bool = False,
        url_override: Optional[str] = None,
    ):
        """
        Args:
            api_key (Optional[str]): Broker API key - set sandbox to true if using sandbox keys. Defaults to None.
            secret_key (Optional[str]): Broker API secret key - set sandbox to true if using sandbox keys. Defaults to None.
            api_version (str): API version. Defaults to 'v1'.
            sandbox (bool): True if using sandbox mode. Defaults to True.
            raw_data (bool): True if you want raw response instead of wrapped responses. Defaults to False.
                This has not been implemented yet.
            url_override (Optional[str]): A url to override and use as the base url.
        """
        base_url = (
            url_override
            if url_override is not None
            else BaseURL.BROKER_SANDBOX.value if sandbox else BaseURL.BROKER_PRODUCTION
        )

        super().__init__(
            base_url=base_url,
            api_key=api_key,
            secret_key=secret_key,
            api_version=api_version,
            sandbox=sandbox,
            raw_data=raw_data,
        )

    def _get_auth_headers(self) -> dict:
        # We override this since we use Basic auth
        auth_string = f"{self._api_key}:{self._secret_key}"
        auth_string_encoded = base64.b64encode(str.encode(auth_string))

        return {"Authorization": "Basic " + auth_string_encoded.decode("utf-8")}

    def _iterate_over_pages(
        self,
        endpoint: str,
        params: Dict[str, Any],
        response_field: str,
        base_model_type: Type[BaseModel],
        max_items_limit: Optional[int] = None,
    ) -> Iterator[Union[RawData, BaseModel]]:
        """
        Internal method to iterate over the result pages.
        """

        # we need to track total items retrieved
        total_items = 0
        page_size = params.get("limit", 100)

        while True:
            if max_items_limit is not None:
                normalized_page_size = min(
                    int(max_items_limit) - total_items, page_size
                )
                params["limit"] = normalized_page_size

            response = self.get(endpoint, params)
            if response is None:
                break
            result = response.get(response_field, None)

            if not isinstance(result, List) or len(result) == 0:
                break

            num_items_returned = len(result)
            if (
                max_items_limit is not None
                and num_items_returned + total_items > max_items_limit
            ):
                result = result[: (max_items_limit - total_items)]
                total_items += max_items_limit - total_items
            else:
                total_items += num_items_returned

            if self._use_raw_data:
                yield result
            else:
                yield TypeAdapter(type=List[base_model_type]).validate_python(result)

            if max_items_limit is not None and total_items >= max_items_limit:
                break

            page_token = response.get("next_page_token", None)

            if page_token is None:
                break

            params["page_token"] = page_token

    # ############################## ACCOUNTS/TRADING ACCOUNTS ################################# #

    def create_account(
        self,
        account_data: CreateAccountRequest,
    ) -> Union[Account, RawData]:
        """
        Create an account.

        Args:
            account_data (CreateAccountRequest): The data representing the Account you wish to create

        Returns:
            Account: The newly created Account instance as returned from the API. Should now have id
            and other generated fields filled out.
        """

        data = account_data.to_request_fields()
        response = self.post("/accounts", data)

        return Account(**response)

    def get_account_by_id(
        self,
        account_id: Union[UUID, str],
    ) -> Union[Account, RawData]:
        """
        Get an Account by its associated account_id.

        Note: If no account is found the api returns a 401, not a 404

        Args:
            account_id (Union[UUID, str]): The id of the account you wish to get. str uuid values will be upcast
            into UUID instances

        Returns:
            Account: Returns the requested account.
        """

        account_id = validate_uuid_id_param(account_id)

        resp = self.get(f"/accounts/{account_id}", {"params": ""})
        return Account(**resp)

    def update_account(
        self,
        account_id: Union[UUID, str],
        update_data: UpdateAccountRequest,
    ) -> Union[Account, RawData]:
        """
        Updates data for an account with an id of `account_id`. Note that not all data for an account is modifiable
        after creation so there is a special data type of AccountUpdateRequest representing the data that is
        allowed to be modified.

        see: https://alpaca.markets/docs/api-references/broker-api/accounts/accounts/#updating-an-account for more info

        Args:
            account_id (Union[UUID, str]): The id for the account you with to update. str uuid values will be upcast
            into UUID instances
            update_data (UpdateAccountRequest): The data you wish to update this account to

        Returns:
            Account: Returns an Account instance with the updated data as returned from the api
        """
        account_id = validate_uuid_id_param(account_id)
        params = update_data.to_request_fields()

        if len(params) < 1:
            raise ValueError("update_data must contain at least 1 field to change")

        response = self.patch(f"/accounts/{account_id}", params)

        if self._use_raw_data:
            return response

        return Account(**response)

    def delete_account(
        self,
        account_id: Union[UUID, str],
    ) -> None:
        """
        DEPRECATED:
            delete_account is deprecated and will be removed in a future version.
            Please use `close_account(account_id)` instead

        Args:
            account_id (Union[UUID, str]): The id of the account to be closed

        Returns:
            None:
        """
        warnings.warn(
            "delete_account is deprecated and will be removed in a future version."
            "Please use `close_account(account_id)` instead",
            DeprecationWarning,
        )

        self.close_account(account_id)

    def close_account(
        self,
        account_id: Union[UUID, str],
    ) -> None:
        """
        This operation closes an active account. The underlying records and information of the account are not deleted by this operation.

        Before closing an account, you are responsible for closing all the positions and withdrawing all the money associated with that account.

        ref. https://docs.alpaca.markets/reference/post-v1-accounts-account_id-actions-close-1

        Args:
            account_id (Union[UUID, str]): The id of the account to be closed

        Returns:
            None:
        """

        account_id = validate_uuid_id_param(account_id)

        self.post(f"/accounts/{account_id}/actions/close")

    def list_accounts(
        self,
        search_parameters: Optional[ListAccountsRequest] = None,
    ) -> Union[List[Account], RawData]:
        """
        Get a List of Accounts allowing for passing in some filters.

        Args:
            search_parameters (Optional[ListAccountsRequest]): The various filtering criteria you can specify.

        Returns:
            List[Account]: The filtered list of Accounts
        """

        params = search_parameters.to_request_fields() if search_parameters else {}

        # API expects comma separated for entities not multiple params
        if "entities" in params and params["entities"] is not None:
            params["entities"] = ",".join(params["entities"])

        response = self.get(
            f"/accounts",
            params,
        )

        if self._use_raw_data:
            return response
        return TypeAdapter(List[Account]).validate_python(response)

    def get_trade_account_by_id(
        self,
        account_id: Union[UUID, str],
    ) -> Union[TradeAccount, RawData]:
        """
        Gets TradeAccount information for a given Account id.

        Args:
            account_id (Union[UUID, str]): The UUID identifier for the Account you wish to get the info for. str values
              will be upcast into UUID instances and checked for validity.

        Returns:
            alpaca.broker.models.accounts.TradeAccount: TradeAccount info for the given account if found.
        """

        account_id = validate_uuid_id_param(account_id)

        result = self.get(f"/trading/accounts/{account_id}/account")

        if self._use_raw_data:
            return result

        return TradeAccount(**result)

    def upload_documents_to_account(
        self,
        account_id: Union[UUID, str],
        document_data: List[Union[UploadDocumentRequest, UploadW8BenDocumentRequest]],
    ) -> None:
        """
        Allows you to upload up to 10 documents at a time for an Account.

        Document data must be a binary objects whose contents are encoded in base64. Each encoded content size is
        limited to 10MB if you use Alpaca for KYCaaS.

        If you perform your own KYC there are no document size limitations.

        Args:
            account_id (Union[UUID, str]): The id of the Account you wish to upload the document data to.
            document_data (List[UploadDocumentRequest]): List of UploadDocumentRequest's that contain the relevant
              Document data

        Returns:
            None: This function returns nothing on success and will raise an APIError in case of a failure

        Raises:
            APIError: this will be raised if the API didn't return a 204 for your request.
        """

        account_id = validate_uuid_id_param(account_id)

        if len(document_data) > BROKER_DOCUMENT_UPLOAD_LIMIT:
            raise ValueError(
                f"document_data cannot be longer than {BROKER_DOCUMENT_UPLOAD_LIMIT}"
            )

        self.post(
            f"/accounts/{account_id}/documents/upload",
            [document.to_request_fields() for document in document_data],
        )

    def get_trade_configuration_for_account(
        self,
        account_id: Union[UUID, str],
    ) -> Union[TradeAccountConfiguration, RawData]:
        """
        Gets the TradeAccountConfiguration for a given Account.

        Args:
            account_id (Union[UUID, str]): The id of the Account you wish to get the TradeAccountConfiguration for

        Returns:
            TradeAccountConfiguration: The resulting TradeAccountConfiguration for the Account
        """

        account_id = validate_uuid_id_param(account_id, "account_id")

        resp = self.get(f"/trading/accounts/{account_id}/account/configurations")

        if self._use_raw_data:
            return resp

        return TradeAccountConfiguration(**resp)

    def update_trade_configuration_for_account(
        self,
        account_id: Union[UUID, str],
        config: TradeAccountConfiguration,
    ) -> Union[TradeAccountConfiguration, RawData]:
        """
        Updates an Account with new TradeAccountConfiguration information.

        Args:
            account_id (Union[UUID, str]): The id of the Account you wish to update.
            config (UpdateTradeConfigurationRequest): The Updated Options you wish to set on the Account

        Returns:
            TradeAccountConfiguration: The resulting TradeAccountConfiguration with updates.
        """
        account_id = validate_uuid_id_param(account_id, "account_id")

        result = self.patch(
            f"/trading/accounts/{account_id}/account/configurations",
            config.model_dump(),
        )

        if self._use_raw_data:
            return result

        return TradeAccountConfiguration(**result)

    def get_cip_data_for_account_by_id(
        self,
        account_id: Union[UUID, str],
    ) -> None:
        """
        Get CIP Info for an account.

        Args:
            account_id (Union[UUID, str]): The Account id you wish to retrieve CIPInfo for

        Returns:
            CIPInfo: The CIP info for the Account
        """
        account_id = validate_uuid_id_param(account_id)
        # TODO: can't verify the CIP routes in sandbox they always return 404.
        #  Need to ask broker team how we'll even test this
        pass

    def upload_cip_data_for_account_by_id(
        self,
        account_id: Union[UUID, str],
    ):
        # TODO: can't verify the CIP routes in sandbox they always return 404.
        #  Need to ask broker team how we'll even test this
        pass

    # ############################## ACCOUNT ACTIVITIES ################################# #

    def get_account_activities(
        self,
        activity_filter: GetAccountActivitiesRequest,
        max_items_limit: Optional[int] = None,
        handle_pagination: Optional[PaginationType] = None,
    ) -> Union[List[BaseActivity], Iterator[List[BaseActivity]]]:
        """
        Gets a list of Account activities, with various filtering options. Please see the documentation for
        GetAccountActivitiesRequest for more information as to what filters are available.

        The return type of this function is List[BaseActivity] however the list will contain concrete instances of one
        of the child classes of BaseActivity, either TradeActivity or NonTradeActivity. It can be a mixed list depending
        on what filtering criteria you pass through `activity_filter`


        Args:
            activity_filter (GetAccountActivitiesRequest): The various filtering fields you can specify to restrict
              results
            max_items_limit (Optional[int]): A maximum number of items to return over all for when handle_pagination is
              of type `PaginationType.FULL`. Ignored otherwise.
            handle_pagination (Optional[PaginationType]): What kind of pagination you want. If None then defaults to
              `PaginationType.FULL`

        Returns:
            Union[List[BaseActivity], Iterator[List[BaseActivity]]]: Either a list or an Iterator of lists of
              BaseActivity child classes
        """
        handle_pagination = BrokerClient._validate_pagination(
            max_items_limit, handle_pagination
        )

        # otherwise, user wants pagination so we grab an interator
        iterator = self._get_account_activities_iterator(
            activity_filter=activity_filter,
            max_items_limit=max_items_limit,
            mapping=lambda raw_activities: [
                self._parse_activity(activity) for activity in raw_activities
            ],
        )

        return BrokerClient._return_paginated_result(iterator, handle_pagination)

    def _get_account_activities_iterator(
        self,
        activity_filter: GetAccountActivitiesRequest,
        mapping: Callable[[HTTPResult], List[BaseActivity]],
        max_items_limit: Optional[int] = None,
    ) -> Iterator[List[BaseActivity]]:
        """
        Private method for handling the iterator parts of get_account_activities
        """

        # we need to track total items retrieved
        total_items = 0
        request_fields = activity_filter.to_request_fields()

        while True:
            """
            we have a couple cases to handle here:
              - max limit isn't set, so just handle normally
              - max is set, and page_size isn't
                - date isn't set. So we'll fall back to the default page size
                - date is set, in this case the api is allowed to not page and return all results. Need to  make
                  sure only take the we allow for making still a single request here but only taking the items we
                  need, in case user wanted only 1 request to happen.
              - max is set, and page_size is also set. Keep track of total_items and run a min check every page to
                see if we need to take less than the page_size items
            """

            if max_items_limit is not None:
                page_size = (
                    activity_filter.page_size
                    if activity_filter.page_size is not None
                    else ACCOUNT_ACTIVITIES_DEFAULT_PAGE_SIZE
                )

                normalized_page_size = min(
                    int(max_items_limit) - total_items, page_size
                )

                request_fields["page_size"] = normalized_page_size

            result = self.get("/accounts/activities", request_fields)

            # the api returns [] when it's done

            if not isinstance(result, List) or len(result) == 0:
                break

            num_items_returned = len(result)

            # need to handle the case where the api won't page and returns all results, ie `date` is set
            if (
                max_items_limit is not None
                and num_items_returned + total_items > max_items_limit
            ):
                result = result[: (max_items_limit - total_items)]

                total_items += max_items_limit - total_items
            else:
                total_items += num_items_returned

            yield mapping(result)

            if max_items_limit is not None and total_items >= max_items_limit:
                break

            # ok we made it to the end, we need to ask for the next page of results
            last_result = result[-1]

            if "id" not in last_result:
                raise APIError(
                    "AccountActivity didn't contain an `id` field to use for paginating results"
                )

            # set the pake token to the id of the last activity so we can get the next page
            request_fields["page_token"] = last_result["id"]

    @staticmethod
    def _parse_activity(data: dict) -> Union[TradeActivity, NonTradeActivity]:
        """
        We cannot just use TypeAdapter for Activity types since we need to know what child instance to cast it into.

        So this method does just that.

        Args:
            data (dict): a dict of raw data to attempt to convert into an Activity instance

        Raises:
            ValueError: Will raise a ValueError if `data` doesn't contain an `activity_type` field to compare
        """

        if "activity_type" not in data or data["activity_type"] is None:
            raise ValueError(
                "Failed parsing raw activity data, `activity_type` is not present in fields"
            )

        if ActivityType.is_str_trade_activity(data["activity_type"]):
            return TypeAdapter(TradeActivity).validate_python(data)
        else:
            return TypeAdapter(NonTradeActivity).validate_python(data)

    # ############################## TRADE ACCOUNT DOCUMENTS ################################# #

    def get_trade_documents_for_account(
        self,
        account_id: Union[UUID, str],
        documents_filter: Optional[GetTradeDocumentsRequest] = None,
    ) -> Union[List[TradeDocument], RawData]:
        """
        Gets the list of TradeDocuments for an Account.

        Args:
            account_id (Union[UUID, str]): The id of the Account you wish to retrieve documents for. str values will
              attempt to be upcast into UUID instances
            documents_filter (Optional[GetTradeDocumentsRequest]): The optional set of filters you can apply to filter the
              returned list.

        Returns:
            List[TradeDocument]: The filtered list of TradeDocuments
        """
        account_id = validate_uuid_id_param(account_id)

        result = self.get(
            f"/accounts/{account_id}/documents",
            documents_filter.to_request_fields() if documents_filter else {},
        )

        if self._use_raw_data:
            return result

        return TypeAdapter(List[TradeDocument]).validate_python(result)

    def get_trade_document_for_account_by_id(
        self,
        account_id: Union[UUID, str],
        document_id: Union[UUID, str],
    ) -> Union[TradeDocument, RawData]:
        """
        Gets a single TradeDocument by its id

        Args:
            account_id (Union[UUID, str]): The id of the Account that owns the document
            document_id (Union[UUID, str]): The id of the TradeDocument

        Returns:
            TradeDocument: The requested TradeDocument

        Raises:
            APIError: Will raise an APIError if the account_id or a matching document_id for the account are not found.
        """

        account_id = validate_uuid_id_param(account_id)
        document_id = validate_uuid_id_param(document_id, "document_id")

        response = self.get(f"/accounts/{account_id}/documents/{document_id}")

        if self._use_raw_data:
            return response

        return TypeAdapter(TradeDocument).validate_python(response)

    def download_trade_document_for_account_by_id(
        self,
        account_id: Union[UUID, str],
        document_id: Union[UUID, str],
        file_path: str,
    ) -> None:
        """
        Downloads a TradeDocument to `file_path`

        Args:
            account_id (Union[UUID, str]): ID of the account to pull the document from
            document_id (Union[UUID, str]): ID of the document itself
            file_path (str): A full path for where to save the file to

        Returns:
            None:
        """

        account_id = validate_uuid_id_param(account_id)
        document_id = validate_uuid_id_param(document_id, "document_id")
        response: Optional[Response] = None

        # self.get/post/etc all set follow redirects to false, however API will return a 301 redirect we need to follow,
        # so we just do a raw request

        # force base_url to be a string value instead of enum name
        base_url = self._base_url + ""

        target_url = f"{base_url}/{self._api_version}/accounts/{account_id}/documents/{document_id}/download"
        num_tries = 0

        while num_tries <= self._retry:
            response = self._session.get(
                url=target_url,
                headers=self._get_default_headers(),
                allow_redirects=True,
                stream=True,
            )
            num_tries += 1

            try:
                response.raise_for_status()
            except HTTPError as http_error:
                if response.status_code in self._retry_codes:
                    continue
                if "code" in response.text:
                    error = response.json()
                    if "code" in error:
                        raise APIError(error, http_error)
                else:
                    raise http_error

            # if we got here there were no issues', so response is now a value
            break

        if response is None:
            # we got here either by error or someone has mis-configured us, so we didn't even try
            raise Exception("Somehow we never made a request for download!")

        with open(file_path, "wb") as f:
            # we specify chunk_size none which is okay since we set stream to true above, so chunks will be as we
            # receive them from the api
            for chunk in response.iter_content(chunk_size=None):
                f.write(chunk)

    # ############################## FUNDING ################################# #

    def create_ach_relationship_for_account(
        self,
        account_id: Union[UUID, str],
        ach_data: Union[CreateACHRelationshipRequest, CreatePlaidRelationshipRequest],
    ) -> Union[ACHRelationship, RawData]:
        """
        Creates a single ACH relationship for the given account.

        Args:
            account_id (Union[UUID, str]): The ID of the Account that has the ACH Relationship.
            ach_data (Union[CreateACHRelationshipRequest, CreatePlaidRelationshipRequest]): The request data used to
              create the ACH relationship.

        Returns:
            ACHRelationship: The ACH relationship that was created.
        """
        account_id = validate_uuid_id_param(account_id)

        if not isinstance(
            ach_data, (CreateACHRelationshipRequest, CreatePlaidRelationshipRequest)
        ):
            raise ValueError(
                f"Request data must either be a CreateACHRelationshipRequest instance, or a "
                f"CreatePlaidRelationshipRequest instance. Got unsupported {type(ach_data)} instead."
            )

        response = self.post(
            f"/accounts/{account_id}/ach_relationships", ach_data.to_request_fields()
        )

        if self._use_raw_data:
            return response

        return ACHRelationship(**response)

    def get_ach_relationships_for_account(
        self,
        account_id: Union[UUID, str],
        statuses: Optional[List[ACHRelationshipStatus]] = None,
    ) -> Union[List[ACHRelationship], RawData]:
        """
        Gets the ACH relationships for an account.

        Args:
            account_id (Union[UUID, str]): The ID of the Account to get the ACH relationships for.
            statuses (Optional[List[ACHRelationshipStatus]]): Optionally filter a subset of ACH relationship statuses.

        Returns:
            List[ACHRelationship]: List of ACH relationships returned by the query.
        """
        account_id = validate_uuid_id_param(account_id)

        params = {}
        if statuses is not None and len(statuses) != 0:
            params["statuses"] = ",".join(statuses)

        response = self.get(f"/accounts/{account_id}/ach_relationships", params)

        if self._use_raw_data:
            return response

        return TypeAdapter(List[ACHRelationship]).validate_python(response)

    def delete_ach_relationship_for_account(
        self,
        account_id: Union[UUID, str],
        ach_relationship_id: Union[UUID, str],
    ) -> None:
        """
        Delete an ACH Relation by its ID.

        As the api itself returns a 204 on success this function returns nothing in the successful case and will raise
        an exception in any other case.

        Args:
            account_id (Union[UUID, str]): The ID of the Account which has the ACH relationship to be deleted.
            ach_relationship_id (Union[UUID, str]): The ID of the ACH relationship to delete.
        """
        account_id = validate_uuid_id_param(account_id)
        ach_relationship_id = validate_uuid_id_param(
            ach_relationship_id, "ach_relationship_id"
        )
        self.delete(f"/accounts/{account_id}/ach_relationships/{ach_relationship_id}")

    def create_bank_for_account(
        self,
        account_id: Union[UUID, str],
        bank_data: CreateBankRequest,
    ) -> Union[Bank, RawData]:
        """
        Creates a single bank relationship for the given account.

        Args:
            account_id (Union[UUID, str]): The ID of the Account to create the bank connection for.
            bank_data (CreateBankRequest): The request data used to create the bank connection.

        Returns:
            Bank: The Bank that was created.
        """
        account_id = validate_uuid_id_param(account_id)
        response = self.post(
            f"/accounts/{account_id}/recipient_banks", bank_data.to_request_fields()
        )

        if self._use_raw_data:
            return response

        return Bank(**response)

    def get_banks_for_account(
        self,
        account_id: Union[UUID, str],
    ) -> Union[List[Bank], RawData]:
        """
        Gets the Banks for an account.

        Args:
            account_id (Union[UUID, str]): The ID of the Account to get the Banks for.

        Returns:
            List[Bank]: List of Banks returned by the query.
        """
        account_id = validate_uuid_id_param(account_id)
        response = self.get(f"/accounts/{account_id}/recipient_banks")

        if self._use_raw_data:
            return response

        return TypeAdapter(List[Bank]).validate_python(response)

    def delete_bank_for_account(
        self,
        account_id: Union[UUID, str],
        bank_id: Union[UUID, str],
    ) -> None:
        """
        Delete a Bank by its ID.

        As the api itself returns a 204 on success this function returns nothing in the successful case and will raise
        an exception in any other case.

        Args:
            account_id (Union[UUID, str]): The ID of the Account which has the Bank to be deleted.
            bank_id (Union[UUID, str]): The ID of the Bank to delete.
        """
        account_id = validate_uuid_id_param(account_id)
        bank_id = validate_uuid_id_param(bank_id, "bank_id")
        self.delete(f"/accounts/{account_id}/recipient_banks/{bank_id}")

    def create_transfer_for_account(
        self,
        account_id: Union[UUID, str],
        transfer_data: Union[CreateACHTransferRequest, CreateBankTransferRequest],
    ) -> Union[Transfer, RawData]:
        """
        Creates a single Transfer for the given account.

        Args:
            account_id (Union[UUID, str]): The ID of the Account to create the bank connection for.
            transfer_data (Union[CreateACHTransferRequest, CreateBankTransferRequest]): The request data used to
              create the bank connection.

        Returns:
            Transfer: The Transfer that was created.
        """
        account_id = validate_uuid_id_param(account_id)
        response = self.post(
            f"/accounts/{account_id}/transfers", transfer_data.to_request_fields()
        )

        if self._use_raw_data:
            return response

        return Transfer(**response)

    def get_transfers_for_account(
        self,
        account_id: Union[UUID, str],
        transfers_filter: Optional[GetTransfersRequest] = None,
        max_items_limit: Optional[int] = None,
        handle_pagination: Optional[PaginationType] = None,
    ) -> Union[List[Transfer], Iterator[List[Transfer]]]:
        """
        Gets the transfers for an account.

        Args:
            account_id (Union[UUID, str]): The ID of the Account to create the bank connection for.
            transfers_filter (Optional[GetTransferRequest]): The various filtering parameters to apply to the request.
            max_items_limit (Optional[int]): A maximum number of items to return over all for when handle_pagination is
              of type `PaginationType.FULL`. Ignored otherwise.
            handle_pagination (Optional[PaginationType]): What kind of pagination you want. If None then defaults to
              `PaginationType.FULL`.

        Returns:
            Union[List[Transfer], Iterator[List[Transfer]]]: Either a list or an Iterator of lists of Transfer child
              classes.
        """
        account_id = validate_uuid_id_param(account_id)
        handle_pagination = BrokerClient._validate_pagination(
            max_items_limit, handle_pagination
        )

        iterator = self._get_transfers_iterator(
            account_id=account_id,
            transfers_filter=(
                transfers_filter
                if transfers_filter is not None
                else GetTransfersRequest()
            ),
            max_items_limit=max_items_limit,
        )

        return BrokerClient._return_paginated_result(iterator, handle_pagination)

    def _get_transfers_iterator(
        self,
        account_id: UUID,
        transfers_filter: GetTransfersRequest,
        max_items_limit: Optional[int],
    ) -> Iterator[List[Transfer]]:
        """
        Private method for handling the iterator parts of get_transfers_for_account.
        """
        # We need to track total items retrieved.
        total_items = 0
        request_fields = transfers_filter.to_request_fields()

        while True:
            request_fields["offset"] = total_items
            result = self.get(f"/accounts/{account_id}/transfers", request_fields)

            # The api returns [] when it's done.
            if not isinstance(result, List) or len(result) == 0:
                break

            num_items_returned = len(result)

            if (
                max_items_limit is not None
                and num_items_returned + total_items > max_items_limit
            ):
                result = result[: (max_items_limit - total_items)]
                total_items += max_items_limit - total_items
            else:
                total_items += num_items_returned

            yield TypeAdapter(List[Transfer]).validate_python(result)

            if max_items_limit is not None and total_items >= max_items_limit:
                break

    def cancel_transfer_for_account(
        self,
        account_id: Union[UUID, str],
        transfer_id: Union[UUID, str],
    ) -> None:
        """
        Cancel a Transfer by its ID.

        As the api itself returns a 204 on success this function returns nothing in the successful case and will raise
        an exception in any other case.

        Args:
            account_id (Union[UUID, str]): The ID of the Account which has the Transfer to be canceled.
            transfer_id (Union[UUID, str]): The ID of the Transfer to cancel.
        """
        account_id = validate_uuid_id_param(account_id)
        transfer_id = validate_uuid_id_param(transfer_id, "transfer_id")
        self.delete(f"/accounts/{account_id}/transfers/{transfer_id}")

    # ############################## TRADING ################################# #

    def get_all_positions_for_account(
        self,
        account_id: Union[UUID, str],
    ) -> Union[List[Position], RawData]:
        """
        Gets all the current positions for an account.

        Args:
            account_id (Union[UUID, str]): The ID of the Account to get the open positions for.

        Returns:
            List[Position]: List of open positions from the account.
        """
        account_id = validate_uuid_id_param(account_id)
        response = self.get(f"/trading/accounts/{account_id}/positions")

        if self._use_raw_data:
            return response
        return TypeAdapter(List[Position]).validate_python(response)

    def get_all_accounts_positions(
        self,
    ) -> Union[AllAccountsPositions, RawData]:
        """
        Gets all the current positions for every account in bulk.

        Returns:
            AllAccountsPositions: The collection of open positions keyed by account_id.
        """
        response = self.get("/accounts/positions")

        if self._use_raw_data:
            return response

        return AllAccountsPositions(**response)

    def get_open_position_for_account(
        self, account_id: Union[UUID, str], symbol_or_asset_id: Union[UUID, str]
    ) -> Union[Position, RawData]:
        """
        Gets the open position for an account for a single asset. Throws an APIError if the position does not exist.

        Args:
            account_id (Union[UUID, str]): The ID of the Account to get the open position for.
            symbol_or_asset_id (Union[UUID, str]): The symbol name of asset id of the position to get from the account.

        Returns:
            Position: Open position of the asset from the account.
        """
        account_id = validate_uuid_id_param(account_id)
        symbol_or_asset_id = validate_symbol_or_asset_id(symbol_or_asset_id)
        response = self.get(
            f"/trading/accounts/{account_id}/positions/{symbol_or_asset_id}"
        )

        if self._use_raw_data:
            return response

        return Position(**response)

    def close_all_positions_for_account(
        self,
        account_id: Union[UUID, str],
        cancel_orders: Optional[bool] = None,
    ) -> Union[List[ClosePositionResponse], RawData]:
        """
        Liquidates all positions for an account.

        Places an order for each open position to liquidate.

        Args:
            account_id (Union[UUID, str]): The ID of the Account to close the positions for.
            cancel_orders (Optional[bool]): If true is specified, cancel all open orders before liquidating all positions.

        Returns:
            List[ClosePositionResponse]: A list of responses from each closed position containing the status code and
              order id.
        """
        account_id = validate_uuid_id_param(account_id)
        response = self.delete(
            f"/trading/accounts/{account_id}/positions",
            {"cancel_orders": cancel_orders} if cancel_orders else None,
        )

        if self._use_raw_data:
            return response
        return TypeAdapter(List[ClosePositionResponse]).validate_python(response)

    def close_position_for_account(
        self,
        account_id: Union[UUID, str],
        symbol_or_asset_id: Union[UUID, str],
        close_options: Optional[ClosePositionRequest] = None,
    ) -> Union[Order, RawData]:
        """
        Liquidates the position for an account for a single asset.

        Places a single order to close the position for the asset.

        Args:
            account_id (Union[UUID, str]): The ID of the Account to close the position for.
            symbol_or_asset_id (Union[UUID, str]): The symbol name of asset id of the position to close on the account.
            close_options: The various close position request parameters.

        Returns:
            alpaca.broker.models.Order: The order that was placed to close the position.
        """
        account_id = validate_uuid_id_param(account_id)
        symbol_or_asset_id = validate_symbol_or_asset_id(symbol_or_asset_id)
        response = self.delete(
            f"/trading/accounts/{account_id}/positions/{symbol_or_asset_id}",
            close_options.to_request_fields() if close_options else {},
        )

        if self._use_raw_data:
            return response

        return Order(**response)

    def get_portfolio_history_for_account(
        self,
        account_id: Union[UUID, str],
        history_filter: Optional[GetPortfolioHistoryRequest] = None,
    ) -> Union[PortfolioHistory, RawData]:
        """
        Gets the portfolio history statistics for an account.

        Args:
            account_id (Union[UUID, str]): The ID of the Account to get the portfolio history for.
            history_filter: The various portfolio history request parameters.

        Returns:
            PortfolioHistory: The portfolio history statistics for the account.
        """
        account_id = validate_uuid_id_param(account_id)

        response = self.get(
            f"/trading/accounts/{account_id}/account/portfolio/history",
            history_filter.to_request_fields() if history_filter else {},
        )

        if self._use_raw_data:
            return response

        return PortfolioHistory(**response)

    # ############################## CLOCK & CALENDAR ################################# #

    def get_clock(self) -> Union[Clock, RawData]:
        """
        Gets the current market timestamp, whether or not the market is currently open, as well as the times
        of the next market open and close.

        Returns:
            Clock: The market Clock data
        """

        response = self.get("/clock")

        if self._use_raw_data:
            return response

        return Clock(**response)

    def get_calendar(
        self,
        filters: Optional[GetCalendarRequest] = None,
    ) -> Union[List[Calendar], RawData]:
        """
        The calendar API serves the full list of market days from 1970 to 2029. It can also be queried by specifying a
        start and/or end time to narrow down the results.

        In addition to the dates, the response also contains the specific open and close times for the market days,
        taking into account early closures.

        Args:
            filters: Any optional filters to limit the returned market days

        Returns:
            List[Calendar]: A list of Calendar objects representing the market days.
        """

        result = self.get(
            "/calendar", filters.to_request_fields() if filters is not None else {}
        )

        if self._use_raw_data:
            return result

        return TypeAdapter(List[Calendar]).validate_python(result)

    # ############################## WATCHLISTS ################################# #

    def get_watchlists_for_account(
        self,
        account_id: Union[UUID, str],
    ) -> Union[List[Watchlist], RawData]:
        """
        Returns all watchlists for an account.

        Args:
            account_id (Union[UUID, str]): The account to retrieve watchlists for

        Returns:
            List[Watchlist]: The watchlists for that account
        """
        account_id = validate_uuid_id_param(account_id, "account_id")

        result = self.get(f"/trading/accounts/{account_id}/watchlists")

        if self._use_raw_data:
            return result

        return TypeAdapter(List[Watchlist]).validate_python(result)

    def get_watchlist_for_account_by_id(
        self,
        account_id: Union[UUID, str],
        watchlist_id: Union[UUID, str],
    ) -> Union[Watchlist, RawData]:
        """
        Returns a specific watchlist by its id for a given account.

        Args:
            account_id (Union[UUID, str]): The account to retrieve watchlist data for.
            watchlist_id (Union[UUID, str]): The watchlist to retrieve.

        Returns:
            Watchlist: The watchlist.
        """
        account_id = validate_uuid_id_param(account_id, "account_id")
        watchlist_id = validate_uuid_id_param(watchlist_id, "watchlist_id")

        result = self.get(f"/trading/accounts/{account_id}/watchlists/{watchlist_id}")

        if self._use_raw_data:
            return result

        return Watchlist(**result)

    def create_watchlist_for_account(
        self,
        account_id: Union[UUID, str],
        watchlist_data: CreateWatchlistRequest,
    ) -> Union[Watchlist, RawData]:
        """
        Creates a new watchlist for a given account.

        Args:
            account_id (Union[UUID, str]): The account to create a new watchlist for.
            watchlist_data (CreateWatchlistRequest): The watchlist to create.

        Returns:
            Watchlist: The new watchlist.
        """
        account_id = validate_uuid_id_param(account_id, "account_id")

        result = self.post(
            f"/trading/accounts/{account_id}/watchlists",
            watchlist_data.to_request_fields(),
        )

        if self._use_raw_data:
            return result

        return Watchlist(**result)

    def update_watchlist_for_account_by_id(
        self,
        account_id: Union[UUID, str],
        watchlist_id: Union[UUID, str],
        # Might be worth taking a union of this and Watchlist itself; but then we should make a change like that SDK
        # wide. Probably a good 0.2.x change
        watchlist_data: UpdateWatchlistRequest,
    ) -> Union[Watchlist, RawData]:
        """
        Updates a watchlist with new data.

        Args:
            account_id (Union[UUID, str]): The account whose watchlist to be updated.
            watchlist_id (Union[UUID, str]): The watchlist to be updated.
            watchlist_data (UpdateWatchlistRequest): The new watchlist data.

        Returns:
            Watchlist: The watchlist with updated data.
        """
        watchlist_id = validate_uuid_id_param(watchlist_id, "watchlist_id")
        account_id = validate_uuid_id_param(account_id, "account_id")

        result = self.put(
            f"/trading/accounts/{account_id}/watchlists/{watchlist_id}",
            watchlist_data.to_request_fields(),
        )

        if self._use_raw_data:
            return result

        return Watchlist(**result)

    def add_asset_to_watchlist_for_account_by_id(
        self,
        account_id: Union[UUID, str],
        watchlist_id: Union[UUID, str],
        symbol: str,
    ) -> Union[Watchlist, RawData]:
        """
        Adds an asset by its symbol to a specified watchlist for a given account.
        Args:
            account_id (Union[UUID, str]): The account id that the watchlist belongs to.
            watchlist_id (Union[UUID, str]): The watchlist to add the symbol to.
            symbol (str): The symbol for the asset to add.

        Returns:
            Watchlist: The updated watchlist.
        """
        account_id = validate_uuid_id_param(account_id, "account_id")
        watchlist_id = validate_uuid_id_param(watchlist_id, "watchlist_id")

        params = {"symbol": symbol}

        result = self.post(
            f"/trading/accounts/{account_id}/watchlists/{watchlist_id}", params
        )

        if self._use_raw_data:
            return result

        return Watchlist(**result)

    def delete_watchlist_from_account_by_id(
        self,
        account_id: Union[UUID, str],
        watchlist_id: Union[UUID, str],
    ) -> None:
        """
        Deletes a watchlist. This is permanent.

        Args:
            account_id (Union[UUID, str]): The account the watchlist belongs to.
            watchlist_id (Union[UUID, str]): The watchlist to delete.

        Returns:
            None
        """
        account_id = validate_uuid_id_param(account_id, "account_id")
        watchlist_id = validate_uuid_id_param(watchlist_id, "watchlist_id")

        self.delete(f"/trading/accounts/{account_id}/watchlists/{watchlist_id}")

    def remove_asset_from_watchlist_for_account_by_id(
        self,
        account_id: Union[UUID, str],
        watchlist_id: Union[UUID, str],
        symbol: str,
    ) -> Union[Watchlist, RawData]:
        """
        Removes an asset from a watchlist for a given account.

        Args:
            account_id (Union[UUID, str]): The account the watchlist belongs to.
            watchlist_id (Union[UUID, str]): The watchlist to remove the asset from.
            symbol (str): The symbol for the asset to add.

        Returns:
            Watchlist: The updated watchlist.
        """
        account_id = validate_uuid_id_param(account_id, "account_id")
        watchlist_id = validate_uuid_id_param(watchlist_id, "watchlist_id")

        result = self.delete(
            f"/trading/accounts/{account_id}/watchlists/{watchlist_id}/{symbol}"
        )

        if self._use_raw_data:
            return result

        return Watchlist(**result)

    # ############################## JOURNALS ################################# #

    def create_journal(
        self,
        journal_data: CreateJournalRequest,
    ) -> Union[Journal, RawData]:
        """
        The journal API allows you to transfer cash and securities between accounts.

        Creates a new journal request.

        Args:
            journal_data (CreateJournalRequest): THe journal to be submitted.

        Returns:
            Journal: The submitted journal.
        """
        params = journal_data.to_request_fields() if journal_data else {}

        response = self.post("/journals", params)

        if self._use_raw_data:
            return response

        return Journal(**response)

    def create_batch_journal(
        self,
        batch_data: CreateBatchJournalRequest,
    ) -> Union[List[BatchJournalResponse], RawData]:
        """
        A batch journal moves assets from one account into many others.

        Currently, cash batch journals are supported.

        Args:
            batch_data (CreateBatchJournalRequest): The batch journals to be submitted.

        Returns:
            BatchJournalResponse: The submitted batch journals.
        """
        params = batch_data.to_request_fields() if batch_data else {}

        response = self.post("/journals/batch", params)

        if self._use_raw_data:
            return response

        return TypeAdapter(List[BatchJournalResponse]).validate_python(response)

    def create_reverse_batch_journal(
        self,
        reverse_batch_data: CreateReverseBatchJournalRequest,
    ) -> Union[List[BatchJournalResponse], RawData]:
        """
        A  reverse batch journal moves assets into one account from many others.

        Currently, cash reverse batch journals are supported.

        Args:
            reverse_batch_data (CreateReverseBatchJournalRequest): The reverse batch journals to be submitted.

        Returns:
            BatchJournalResponse: The submitted reverse batch journals.
        """
        params = reverse_batch_data.to_request_fields() if reverse_batch_data else {}

        response = self.post("/journals/reverse_batch", params)

        if self._use_raw_data:
            return response

        return TypeAdapter(List[BatchJournalResponse]).validate_python(response)

    def get_journals(
        self, journal_filter: Optional[GetJournalsRequest] = None
    ) -> Union[List[Journal], RawData]:
        """
        Returns journals from the master list.

        Args:
            journal_filter (Optional[GetJournalsRequest]): The parameters to filter the query by.

        Returns:
            List[Journal]: The journals from the query.
        """
        params = journal_filter.to_request_fields() if journal_filter else {}

        response = self.get("/journals", params)

        if self._use_raw_data:
            return response

        return TypeAdapter(List[Journal]).validate_python(response)

    def get_journal_by_id(
        self, journal_id: Union[UUID, str] = None
    ) -> Union[Journal, RawData]:
        """
        Returns a specific journal by its id.

        Args:
            journal_id (Union[UUID, str]): The id of the journal to retrieve.

        Returns:
            Journal: The journal with given id.
        """
        journal_id = validate_uuid_id_param(journal_id, "journal id")

        response = self.get(f"/journals/{journal_id}")

        if self._use_raw_data:
            return response

        return Journal(**response)

    def cancel_journal_by_id(
        self,
        journal_id: Union[UUID, str],
    ) -> None:
        """
        Cancels a specific journal by its id.

        Args:
            journal_id (Union[UUID, str]): The id of the journal to be cancelled.

        Returns:
            None
        """
        journal_id = validate_uuid_id_param(journal_id, "journal id")

        self.delete(f"/journals/{journal_id}")

    # ############################## Assets ################################# #

    def get_all_assets(
        self, filter: Optional[GetAssetsRequest] = None
    ) -> Union[List[Asset], RawData]:
        """
        The assets API serves as the master list of assets available for trade and data consumption from Alpaca.
        Some assets are not tradable with Alpaca. These assets will be marked with the flag tradable=false.

        Args:
            filter (Optional[GetAssetsRequest]): The parameters that can be assets can be queried by.

        Returns:
            List[Asset]: The list of assets.
        """
        # checking to see if we specified at least one param
        params = filter.to_request_fields() if filter is not None else {}

        response = self.get(f"/assets", params)

        if self._use_raw_data:
            return response

        return TypeAdapter(
            List[Asset],
        ).validate_python(response)

    def get_asset(self, symbol_or_asset_id: Union[UUID, str]) -> Union[Asset, RawData]:
        """
        Returns a specific asset by its symbol or asset id. If the specified asset does not exist
        a 404 error will be thrown.

        Args:
            symbol_or_asset_id (Union[UUID, str]): The symbol or asset id for the specified asset

        Returns:
            Asset: The asset if it exists.
        """

        symbol_or_asset_id = validate_symbol_or_asset_id(symbol_or_asset_id)

        response = self.get(f"/assets/{symbol_or_asset_id}")

        if self._use_raw_data:
            return response

        return Asset(**response)

    # ############################## ORDERS ################################# #

    def submit_order_for_account(
        self, account_id: Union[UUID, str], order_data: OrderRequest
    ) -> Union[Order, RawData]:
        """Creates an order to buy or sell an asset for an account.

        Args:
            account_id (Union[UUID, str]): The account the order will be created for.
            order_data (alpaca.broker.requests.OrderRequest): The request data for creating a new order.

        Returns:
            alpaca.broker.models.OrderOrder: The resulting submitted order.
        """

        account_id = validate_uuid_id_param(account_id, "account_id")

        data = order_data.to_request_fields()

        response = self.post(f"/trading/accounts/{account_id}/orders", data)

        if self._use_raw_data:
            return response

        return Order(**response)

    def get_orders_for_account(
        self, account_id: Union[UUID, str], filter: Optional[GetOrdersRequest] = None
    ) -> Union[List[Order], RawData]:
        """
        Returns all orders for an account. Orders can be filtered by parameters.

        Args:
            account_id (Union[UUID, str]): The account to get the orders for.
            filter (Optional[GetOrdersRequest]): The parameters to filter the orders with.

        Returns:
            List[alpaca.broker.models.Order]: The queried orders.
        """
        account_id = validate_uuid_id_param(account_id, "account_id")

        # checking to see if we specified at least one param
        params = filter.to_request_fields() if filter is not None else {}

        if "symbols" in params and isinstance(params["symbols"], list):
            params["symbols"] = ",".join(params["symbols"])

        response = self.get(f"/trading/accounts/{account_id}/orders", params)

        if self._use_raw_data:
            return response

        return TypeAdapter(
            List[Order],
        ).validate_python(response)

    def get_order_for_account_by_id(
        self,
        account_id: Union[UUID, str],
        order_id: Union[UUID, str],
        filter: Optional[GetOrderByIdRequest] = None,
    ) -> Union[Order, RawData]:
        """
        Returns a specific order by its order id.

        Args:
            account_id (Union[UUID, str]): The account to get the order for.
            order_id (Union[UUID, str]): The unique uuid identifier for the order.
            filter (Optional[GetOrderByIdRequest]): The parameters for the query.

        Returns:
            alpaca.broker.models.Order: The order that was queried.
        """
        account_id = validate_uuid_id_param(account_id, "account_id")
        order_id = validate_uuid_id_param(order_id, "order_id")

        # checking to see if we specified at least one param
        params = filter.to_request_fields() if filter is not None else {}

        response = self.get(f"/trading/accounts/{account_id}/orders/{order_id}", params)

        if self._use_raw_data:
            return response

        return Order(**response)

    def get_order_for_account_by_client_id(
        self, account_id: Union[UUID, str], client_id: str
    ) -> Union[Order, RawData]:
        """
        Returns a specific order by its client order id.

        Args:
            account_id (Union[UUID, str]): The account to get the order for.
            client_id (str): The client order identifier for the order.

        Returns:
            alpaca.broker.models.Order: The queried order.
        """
        account_id = validate_uuid_id_param(account_id, "account_id")

        params = {"client_order_id": client_id}

        response = self.get(
            f"/trading/accounts/{account_id}/orders:by_client_order_id", params
        )

        if self._use_raw_data:
            return response

        return Order(**response)

    def replace_order_for_account_by_id(
        self,
        account_id: Union[UUID, str],
        order_id: Union[UUID, str],
        order_data: Optional[ReplaceOrderRequest] = None,
    ) -> Union[Order, RawData]:
        """
        Updates an order with new parameters.

        Args:
            account_id (Union[UUID, str]): The account to replace the order for.
            order_id (Union[UUID, str]): The unique uuid identifier for the order being replaced.
            order_data (Optional[ReplaceOrderRequest]): The parameters we wish to update.

        Returns:
            alpaca.broker.models.Order: The updated order.
        """
        account_id = validate_uuid_id_param(account_id, "account_id")
        order_id = validate_uuid_id_param(order_id, "order_id")

        # checking to see if we specified at least one param
        params = order_data.to_request_fields() if order_data is not None else {}

        response = self.patch(
            f"/trading/accounts/{account_id}/orders/{order_id}", params
        )

        if self._use_raw_data:
            return response

        return Order(**response)

    def cancel_orders_for_account(
        self, account_id: Union[UUID, str]
    ) -> Union[List[CancelOrderResponse], RawData]:
        """
        Cancels all orders.

        Args:
            account_id (Union[UUID, str]): The account to cancel the orders for.

        Returns:
            List[CancelOrderResponse]: The list of HTTP statuses for each order attempted to be cancelled.
        """
        account_id = validate_uuid_id_param(account_id, "account_id")

        response = self.delete(f"/trading/accounts/{account_id}/orders")

        if self._use_raw_data:
            return response

        return TypeAdapter(
            List[CancelOrderResponse],
        ).validate_python(response)

    def cancel_order_for_account_by_id(
        self, account_id: Union[UUID, str], order_id: Union[UUID, str]
    ) -> None:
        """
        Cancels a specific order by its order id.

        Args:
            account_id (Union[UUID, str]): The account to cancel the order for.
            order_id (Union[UUID, str]): The unique uuid identifier of the order being cancelled.

        """
        account_id = validate_uuid_id_param(account_id, "account_id")
        order_id = validate_uuid_id_param(order_id, "order_id")

        # TODO: Should ideally return some information about the order's cancel status (Issue #78)
        # TODO: Currently no way to retrieve status details for empty responses with base REST implementation
        self.delete(f"/trading/accounts/{account_id}/orders/{order_id}")

    # ############################## CORPORATE ACTIONS ################################# #

    def get_corporate_announcements(
        self, filter: GetCorporateAnnouncementsRequest
    ) -> Union[List[CorporateActionAnnouncement], RawData]:
        """
        Returns corporate action announcements data given specified search criteria.
        Args:
            filter (GetCorporateAnnouncementsRequest): The parameters to filter the search by.
        Returns:
            List[CorporateActionAnnouncement]: The resulting announcements from the search.
        """
        params = filter.to_request_fields() if filter else {}

        if "ca_types" in params and isinstance(params["ca_types"], list):
            params["ca_types"] = ",".join(params["ca_types"])

        response = self.get("/corporate_actions/announcements", params)

        if self._use_raw_data:
            return response

        return TypeAdapter(
            List[CorporateActionAnnouncement],
        ).validate_python(response)

    def get_corporate_announcement_by_id(
        self, corporate_announcment_id: Union[UUID, str]
    ) -> Union[CorporateActionAnnouncement, RawData]:
        """
        Returns a specific corporate action announcement.
        Args:
            corporate_announcment_id: The id of the desired corporate action announcement
        Returns:
            CorporateActionAnnouncement: The corporate action queried.
        """
        corporate_announcment_id = validate_uuid_id_param(
            corporate_announcment_id, "corporate_announcment_id"
        )

        response = self.get(
            f"/corporate_actions/announcements/{corporate_announcment_id}"
        )

        if self._use_raw_data:
            return response

        return CorporateActionAnnouncement(**response)

    # ############################## EVENTS ################################# #

    def get_account_status_events(
        self, filter: Optional[GetEventsRequest] = None
    ) -> Iterator:
        """
        Subscribes to SSE stream for account status events.

        Args:
            filter: The arguments for filtering the events stream.

        Returns:
            Iterator: Yields events as they arrive
        """

        params = {}

        if filter:
            params = filter.to_request_fields()

        url = self._base_url + "/" + self._api_version + "/events/accounts/status"

        response = self._session.get(
            url=url,
            params=params,
            stream=True,
            headers=self._get_sse_headers(),
        )

        client = sseclient.SSEClient(response)

        for event in client.events():
            yield event.data

    def get_trade_events(self, filter: Optional[GetEventsRequest] = None) -> Iterator:
        """
        Subscribes to SSE stream for trade events.

        Args:
            filter: The arguments for filtering the events stream.

        Returns:
            Iterator: Yields events as they arrive
        """
        params = {}

        if filter:
            params = filter.to_request_fields()

        url = self._base_url + "/" + self._api_version + "/events/trades"

        response = self._session.get(
            url=url,
            params=params,
            stream=True,
            headers=self._get_sse_headers(),
        )

        client = sseclient.SSEClient(response)

        for event in client.events():
            yield event.data

    def get_journal_events(self, filter: Optional[GetEventsRequest] = None) -> Iterator:
        """
        Subscribes to SSE stream for journal status events.

        Args:
            filter: The arguments for filtering the events stream.

        Returns:
            Iterator: Yields events as they arrive
        """
        params = {}

        if filter:
            params = filter.to_request_fields()

        url = self._base_url + "/" + self._api_version + "/events/journals/status"

        response = self._session.get(
            url=url,
            params=params,
            stream=True,
            headers=self._get_sse_headers(),
        )

        client = sseclient.SSEClient(response)

        for event in client.events():
            yield event.data

    def get_transfer_events(
        self, filter: Optional[GetEventsRequest] = None
    ) -> Iterator:
        """
        Subscribes to SSE stream for transfer status events.

        Args:
            filter: The arguments for filtering the events stream.

        Returns:
            Iterator: Yields events as they arrive
        """
        params = {}

        if filter:
            params = filter.to_request_fields()

        url = self._base_url + "/" + self._api_version + "/events/transfers/status"

        response = self._session.get(
            url=url,
            params=params,
            stream=True,
            headers=self._get_sse_headers(),
        )

        client = sseclient.SSEClient(response)

        for event in client.events():
            yield event.data

    def get_non_trading_activity_events(
        self, filter: Optional[GetEventsRequest] = None
    ) -> Iterator:
        """
        Subscribes to SSE stream for non trading activity events.

        Args:
            filter: The arguments for filtering the events stream.

        Returns:
            Iterator: Yields events as they arrive
        """
        params = {}

        if filter:
            params = filter.to_request_fields()

        url = self._base_url + "/" + self._api_version + "/events/nta"

        response = self._session.get(
            url=url,
            params=params,
            stream=True,
            headers=self._get_sse_headers(),
        )

        client = sseclient.SSEClient(response)

        for event in client.events():
            yield event.data

    def _get_sse_headers(self) -> dict:
        headers = self._get_default_headers()

        headers["Connection"] = "keep-alive"
        headers["Cache-Control"] = "no-cache"
        headers["Content-Type"] = "text/event-stream"
        headers["Accept"] = "text/event-stream"

        return headers

    # ############################## REBALANCING ################################# #

    def create_portfolio(
        self, portfolio_request: CreatePortfolioRequest
    ) -> Union[Portfolio, RawData]:
        """
        Create a new portfolio.

        ref. https://docs.alpaca.markets/reference/post-v1-rebalancing-portfolios

        Args:
            portfolio_request (CreatePortfolioRequest): The details required to create a new portfolio.

        Returns:
            Portfolio: Newly created portfolio.
        """

        response = self.post(
            "/rebalancing/portfolios", data=portfolio_request.to_request_fields()
        )

        if self._use_raw_data:
            return response

        return Portfolio(**response)

    def get_all_portfolios(
        self,
        filter: Optional[GetPortfoliosRequest] = None,
    ) -> Union[List[Portfolio], List[RawData]]:
        """
        Retrieves all portfolios based on the filter provided.

        ref. https://docs.alpaca.markets/reference/get-v1-rebalancing-portfolios

        Args:
            filter (Optional[GetPortfoliosRequest]): Filter criteria to narrow down portfolio list.

        Returns:
            List[Portfolio]: List of portfolios.
        """

        response = self.get(
            "/rebalancing/portfolios", filter.to_request_fields() if filter else {}
        )

        if self._use_raw_data:
            return response

        return TypeAdapter(
            List[Portfolio],
        ).validate_python(response)

    def get_portfolio_by_id(
        self, portfolio_id: Union[UUID, str]
    ) -> Union[Portfolio, RawData]:
        """
        Retrieves a specific portfolio using its ID.

        Args:
            portfolio_id (Union[UUID, str]): The ID of the desired portfolio.

        Returns:
            Portfolio: The portfolio queried.
        """

        response = self.get(f"/rebalancing/portfolios/{portfolio_id}")

        if self._use_raw_data:
            return response

        return Portfolio(**response)

    def update_portfolio_by_id(
        self,
        portfolio_id: Union[UUID, str],
        update_request: UpdatePortfolioRequest,
    ) -> Union[Portfolio, RawData]:
        """
        Updates a portfolio by ID.
        If weights or conditions are changed, all subscribed accounts will be evaluated for rebalancing at the next opportunity (normal market hours).
        If a cooldown is active on the portfolio, the rebalancing will occur after the cooldown expired.

        ref. https://docs.alpaca.markets/reference/patch-v1-rebalancing-portfolios-portfolio_id-1

        Args:
            portfolio_id (Union[UUID, str]): The ID of the portfolio to be updated.
            update_request: The details to be updated for the portfolio.

        Returns:
            Portfolio: Updated portfolio.
        """
        portfolio_id = validate_uuid_id_param(portfolio_id)

        response = self.patch(
            f"/rebalancing/portfolios/{portfolio_id}",
            data=update_request.to_request_fields(),
        )

        if self._use_raw_data:
            return response

        return Portfolio(**response)

    def inactivate_portfolio_by_id(self, portfolio_id: Union[UUID, str]) -> None:
        """
        Sets a portfolio to ‚Äúinactive‚Äù, so it can be filtered out of the list request.
        Only permitted if there are no active subscriptions to this portfolio and this portfolio is not a listed in the weights of any active portfolios.
        Inactive portfolios cannot be linked in new subscriptions or added as weights to new portfolios.

        ref. https://docs.alpaca.markets/reference/delete-v1-rebalancing-portfolios-portfolio_id-1

        Args:
            portfolio_id (Union[UUID, str]): The ID of the portfolio to be inactivated.
        """
        portfolio_id = validate_uuid_id_param(portfolio_id)

        self.delete(
            f"/rebalancing/portfolios/{portfolio_id}",
        )

    def create_subscription(
        self, subscription_request: CreateSubscriptionRequest
    ) -> Union[Subscription, RawData]:
        """
        Create a new subscription.

        Args:
            subscription_request (CreateSubscriptionRequest): The details required to create a new subscription.

        Returns:
            Subscription: Newly created subscription.
        """

        response = self.post(
            "/rebalancing/subscriptions", data=subscription_request.to_request_fields()
        )

        if self._use_raw_data:
            return response

        return Subscription(**response)

    def get_all_subscriptions(
        self,
        filter: Optional[GetSubscriptionsRequest] = None,
        max_items_limit: Optional[int] = None,
        handle_pagination: Optional[PaginationType] = None,
    ) -> Union[List[Subscription], List[RawData]]:
        """
        Retrieves all subscriptions based on the filter provided.

        ref. https://docs.alpaca.markets/reference/get-v1-rebalancing-subscriptions-1

        Args:
            filter (Optional[GetSubscriptionsRequest]): Filter criteria to narrow down subscription list.
            max_items_limit (Optional[int]): A maximum number of items to return over all for when handle_pagination is
              of type `PaginationType.FULL`. Ignored otherwise.
            handle_pagination (Optional[PaginationType]): What kind of pagination you want. If None then defaults to
              `PaginationType.FULL`.

        Returns:
            List[Subscription]: List of subscriptions.
        """
        handle_pagination = BrokerClient._validate_pagination(
            max_items_limit, handle_pagination
        )

        subscriptions_iterator = self._iterate_over_pages(
            endpoint="/rebalancing/subscriptions",
            params=filter.to_request_fields() if filter else {},
            response_field="subscriptions",
            base_model_type=Subscription,
            max_items_limit=max_items_limit,
        )

        return BrokerClient._return_paginated_result(
            subscriptions_iterator, handle_pagination
        )

    def get_subscription_by_id(
        self, subscription_id: Union[UUID, str]
    ) -> Union[Subscription, RawData]:
        """
        Get a subscription by its ID.

        Args:
            subscription_id (Union[UUID, str]): The ID of the desired subscription.

        Returns:
            Subscription: The subscription queried.
        """
        subscription_id = validate_uuid_id_param(subscription_id)

        response = self.get(f"/rebalancing/subscriptions/{subscription_id}")

        if self._use_raw_data:
            return response

        return Subscription(**response)

    def unsubscribe_account(self, subscription_id: Union[UUID, str]) -> None:
        """
        Deletes the subscription which stops the rebalancing of an account.

        Args:
            subscription_id (Union[UUID, str]): The ID of the subscription to be removed.
        """
        subscription_id = validate_uuid_id_param(subscription_id)

        self.delete(
            f"/rebalancing/subscriptions/{subscription_id}",
        )

    def create_manual_run(
        self, rebalancing_run_request: CreateRunRequest
    ) -> Union[RebalancingRun, RawData]:
        """
        Create a new manual rebalancing run.

        Args:
            rebalancing_run_request: The details required to create a new rebalancing run.

        Returns:
            RebalancingRun: The rebalancing run initiated.
        """

        response = self.post(
            "/rebalancing/runs", data=rebalancing_run_request.to_request_fields()
        )

        if self._use_raw_data:
            return response

        return RebalancingRun(**response)

    def get_all_runs(
        self,
        filter: Optional[GetRunsRequest] = None,
        max_items_limit: Optional[int] = None,
        handle_pagination: Optional[PaginationType] = None,
    ) -> Union[List[RebalancingRun], List[RawData]]:
        """
        Get all runs.

        Args:
            filter (Optional[GetRunsRequest]): Filter criteria to narrow down run list.
            max_items_limit (Optional[int]): A maximum number of items to return over all for when handle_pagination is
              of type `PaginationType.FULL`. Ignored otherwise.
            handle_pagination (Optional[PaginationType]): What kind of pagination you want. If None then defaults to
              `PaginationType.FULL`.

        Returns:
            List[RebalancingRun]: List of rebalancing runs.
        """
        handle_pagination = BrokerClient._validate_pagination(
            max_items_limit, handle_pagination
        )

        runs_iterator = self._iterate_over_pages(
            endpoint="/rebalancing/runs",
            params=filter.to_request_fields() if filter else {},
            response_field="runs",
            base_model_type=RebalancingRun,
            max_items_limit=max_items_limit,
        )

        return BrokerClient._return_paginated_result(runs_iterator, handle_pagination)

    def get_run_by_id(self, run_id: Union[UUID, str]) -> Union[RebalancingRun, RawData]:
        """
        Get a run by its ID.

        Args:
            run_id (Union[UUID, str]): The ID of the desired rebalancing run.

        Returns:
            RebalancingRun: The rebalancing run queried.
        """
        run_id = validate_uuid_id_param(run_id)

        response = self.get(f"/rebalancing/runs/{run_id}")

        if self._use_raw_data:
            return response

        return RebalancingRun(**response)

    def cancel_run_by_id(self, run_id: Union[UUID, str]) -> None:
        """
        Cancels a run.

        Only runs within certain statuses (QUEUED, CANCELED, SELLS_IN_PROGRESS, BUYS_IN_PROGRESS) are cancelable.
        If this endpoint is called after orders have been submitted, we‚Äôll attempt to cancel the orders.

        Args:
            run_id (Union[UUID, str]): The ID of the desired rebalancing run.
        """
        run_id = validate_uuid_id_param(run_id)

        self.delete(f"/rebalancing/runs/{run_id}")

    def exercise_options_position_for_account_by_id(
        self,
        symbol_or_contract_id: Union[UUID, str],
        account_id: Union[UUID, str],
        commission: Optional[float] = None,
    ) -> None:
        """
        This endpoint enables the correspondent to exercise a held option contract for an account, converting it into the underlying asset based on the specified terms.
        All available held shares of this option contract will be exercised.
        By default, Alpaca will automatically exercise in-the-money (ITM) contracts at expiry.
        Exercise requests will be processed immediately once received. Exercise requests submitted outside market hours will be rejected.
        To cancel an exercise request or to submit a Do-not-exercise (DNE) instruction, please contact our support team.

        Args:
            account_id (Union[UUID, str]): The Account id you wish to retrieve CIPInfo for
            symbol_or_contract_id (Union[UUID, str]): Option contract symbol or ID.
            commission (Optional[float]): The dollar value commission you want to charge the end user.

        Returns:
            None
        """

        account_id = validate_uuid_id_param(account_id)
        symbol_or_contract_id = validate_symbol_or_contract_id(symbol_or_contract_id)
        req = CreateOptionExerciseRequest(commission=commission)

        params = req.to_request_fields()
        self.post(
            f"/trading/accounts/{account_id}/positions/{symbol_or_contract_id}/exercise",
            params,
        )
````

## File: alpaca/broker/enums.py
````python
from enum import Enum


class TaxIdType(str, Enum):
    """The various country specific tax identification numbers

    see https://alpaca.markets/docs/broker/api-references/accounts/accounts/#tax-id-type
    """

    USA_SSN = "USA_SSN"
    ARG_AR_CUIT = "ARG_AR_CUIT"
    AUS_TFN = "AUS_TFN"
    AUS_ABN = "AUS_ABN"
    BOL_NIT = "BOL_NIT"
    BRA_CPF = "BRA_CPF"
    CHL_RUT = "CHL_RUT"
    COL_NIT = "COL_NIT"
    CRI_NITE = "CRI_NITE"
    DEU_TAX_ID = "DEU_TAX_ID"
    DOM_RNC = "DOM_RNC"
    ECU_RUC = "ECU_RUC"
    FRA_SPI = "FRA_SPI"
    GBR_UTR = "GBR_UTR"
    GBR_NINO = "GBR_NINO"
    GTM_NIT = "GTM_NIT"
    HND_RTN = "HND_RTN"
    HUN_TIN = "HUN_TIN"
    IDN_KTP = "IDN_KTP"
    IND_PAN = "IND_PAN"
    ISR_TAX_ID = "ISR_TAX_ID"
    ITA_TAX_ID = "ITA_TAX_ID"
    JPN_TAX_ID = "JPN_TAX_ID"
    MEX_RFC = "MEX_RFC"
    NIC_RUC = "NIC_RUC"
    NLD_TIN = "NLD_TIN"
    PAN_RUC = "PAN_RUC"
    PER_RUC = "PER_RUC"
    PRY_RUC = "PRY_RUC"
    SGP_NRIC = "SGP_NRIC"
    SGP_FIN = "SGP_FIN"
    SGP_ASGD = "SGP_ASGD"
    SGP_ITR = "SGP_ITR"
    SLV_NIT = "SLV_NIT"
    SWE_TAX_ID = "SWE_TAX_ID"
    URY_RUT = "URY_RUT"
    VEN_RIF = "VEN_RIF"
    NOT_SPECIFIED = "NOT_SPECIFIED"


class VisaType(str, Enum):
    """
    In addition to the following USA visa categories, we accept any sub visas of the list below.
    Sub visas must be passed in according to their parent category.
    Note that United States green card holders are considered permanent residents and should not pass in a visa type.

    Please feel free to reach out to Alpaca if you need other tax ID types.

    see https://alpaca.markets/docs/broker/api-references/accounts/accounts/#visa-type
    """

    B1 = "B1"
    B2 = "B2"
    DACA = "DACA"
    E1 = "E1"
    E2 = "E2"
    E3 = "E3"
    F1 = "F1"
    G4 = "G4"
    H1B = "H1B"
    J1 = "J1"
    L1 = "L1"
    Other = "OTHER"
    O1 = "O1"
    TN1 = "TN1"


class FundingSource(str, Enum):
    """
    Various sources of funding for brokerage accounts.

    see https://alpaca.markets/docs/broker/api-references/accounts/accounts/#funding-source
    """

    EMPLOYMENT_INCOME = "employment_income"
    INVESTMENTS = "investments"
    INHERITANCE = "inheritance"
    BUSINESS_INCOME = "business_income"
    SAVINGS = "savings"
    FAMILY = "family"


class EmploymentStatus(str, Enum):
    """
    The possible employment statuses of the user

    see https://alpaca.markets/docs/broker/api-references/accounts/accounts/#employment-status
    """

    UNEMPLOYED = "UNEMPLOYED"
    EMPLOYED = "EMPLOYED"
    STUDENT = "STUDENT"
    RETIRED = "RETIRED"


class AgreementType(str, Enum):
    """
    The types of agreements that are to be signed by the user

    see https://docs.alpaca.markets/reference/createaccount
    """

    MARGIN = "margin_agreement"
    ACCOUNT = "account_agreement"
    CUSTOMER = "customer_agreement"
    CRYPTO = "crypto_agreement"
    OPTIONS = "options_agreement"
    CUSTODIAL_CUSTOMER = "custodial_customer_agreement"


class DocumentType(str, Enum):
    """
    Represents the kind of document data you're uploading

    please see https://alpaca.markets/docs/broker/api-references/accounts/accounts/#document-type
    and https://alpaca.markets/docs/api-references/broker-api/documents/#enumuploaddocumenttype
    for more info
    """

    IDENTITY_VERIFICATION = "identity_verification"
    ADDRESS_VERIFICATION = "address_verification"
    DATE_OF_BIRTH_VERIFICATION = "date_of_birth_verification"
    TAX_ID_VERIFICATION = "tax_id_verification"
    ACCOUNT_APPROVAL_LETTER = "account_approval_letter"
    LIMITED_TRADING_AUTHORIZATION = "limited_trading_authorization"
    W8BEN = "w8ben"
    SOCIAL_SECURITY_NUMBER_VERIFICATION = "social_security_number_verification"
    NULL = ""
    CIP_RESULT = "cip_result"


class AccountEntities(str, Enum):
    """
    An enum representing the different fields to query for when listing accounts.

    ie: asking for CONTACT and IDENTITY will have the api fill those fields when returning the list of Accounts however
    other fields on the account will be nulled out where possible.
    """

    CONTACT = "contact"
    IDENTITY = "identity"
    DISCLOSURES = "disclosures"
    AGREEMENTS = "agreements"
    DOCUMENTS = "documents"
    TRUSTED_CONTACT = "trusted_contact"
    USER_CONFIGURATIONS = "trading_configurations"


class ClearingBroker(str, Enum):
    """
    An enum for representing what Clearing broker an Account is assigned to
    """

    Apex = "APEX"
    ETC = "ETC"
    IC = "IC"
    Velox = "VELOX"
    Vision = "VISION"
    Self = "SELF"
    Alpaca_APCA = "ALPACA_APCA"


class CIPProvider(str, Enum):
    """
    Enum representing what CIP provider was used.

    see https://alpaca.markets/docs/api-references/broker-api/accounts/accounts/#cip-provider for more info
    """

    ALLOY = "alloy"
    TRULIOO = "trulioo"
    ONFIDO = "onfido"
    VERIFF = "veriff"
    JUMIO = "jumio"
    GETMATI = "getmati"


class CIPStatus(str, Enum):
    """
    An enum representing the status of the CIPInfo

    see https://alpaca.markets/docs/api-references/broker-api/accounts/accounts/#cip-status for more info
    """

    COMPLETE = "complete"
    WITHDRAWN = "withdrawn"


class CIPResult(str, Enum):
    """
    see https://alpaca.markets/docs/api-references/broker-api/accounts/accounts/#cip-result for more info
    """

    CLEAR = "clear"
    CONSIDER = "consider"


class CIPApprovalStatus(str, Enum):
    """
    Either `approved` or `rejected`
    """

    APPROVED = "approved"
    REJECTED = "rejected"


class TradeDocumentType(str, Enum):
    """
    Represents what kind information is inside a TradeDocument

    Most likely will be either of these 3:
      -  ACCOUNT_STATEMENT
      -  TRADE_CONFIRMATION
      -  TAX_STATEMENT

    However, for older accounts with legacy documents the other legacy values might show up.

    please see https://alpaca.markets/docs/api-references/broker-api/documents/#enumdocumenttype for more info
    """

    ACCOUNT_STATEMENT = "account_statement"
    TRADE_CONFIRMATION = "trade_confirmation"
    TRADE_CONFIRMATION_JSON = "trade_confirmation_json"

    TAX_STATEMENT = "tax_statement"

    ACCOUNT_APPLICATION = "account_application"

    # Legacy Values
    TAX_1099_B_DETAILS = "tax_1099_b_details"
    TAX_1099_B_FORM = "tax_1099_b_form"
    TAX_1099_DIV_DETAILS = "tax_1099_div_details"
    TAX_1099_DIV_FORM = "tax_1099_div_form"
    TAX_1099_INT_DETAILS = "tax_1099_int_details"
    TAX_1099_INT_FORM = "tax_1099_int_form"
    TAX_W8 = "tax_w8"


class TradeDocumentSubType(str, Enum):
    """
    Represents additional information for whats inside a TradeDocument in combination with a TradeDocumentType

    please see https://alpaca.markets/docs/api-references/broker-api/documents/#the-document-object for more info
    """

    TYPE_1099_COMP = "1099-Comp"
    TYPE_1042_S = "1042-S"
    TYPE_480_6 = "480.6"
    COURTESY_STATEMENT = "courtesy_statement"


class UploadDocumentSubType(str, Enum):
    """
    Represents a sub type for an UploadDocumentRequest

    please see: https://alpaca.markets/docs/api-references/broker-api/documents/#enumuploaddocumentsubtype
    for more info
    """

    ACCOUNT_APPLICATION = "Account Application"
    FORM_W8_BEN = "Form W-8BEN"
    PASSPORT = "passport"


class UploadDocumentMimeType(str, Enum):
    """
    specifies the mime type of the base64 data you're uploading as part of a UploadDocumentRequest

    please see https://alpaca.markets/docs/api-references/broker-api/documents/#parameters for more info
    """

    PDF = "application/pdf"
    PNG = "image/png"
    JPEG = "image/jpeg"
    JSON = "application/json"


class ACHRelationshipStatus(str, Enum):
    """
    Represents the state that an ACHRelationship is in.

    Please see https://alpaca.markets/docs/api-references/broker-api/funding/ach/#attributes for more details
    """

    QUEUED = "QUEUED"
    APPROVED = "APPROVED"
    PENDING = "PENDING"


class BankAccountType(str, Enum):
    """
    Represents a kind of bank account.

    Please see https://alpaca.markets/docs/api-references/broker-api/funding/ach/#attributes
    """

    CHECKING = "CHECKING"
    SAVINGS = "SAVINGS"
    # responses from plaid token connections sometimes return empty
    NONE = ""


class IdentifierType(str, Enum):
    """
    Represents a type of bank account.

    Please see https://alpaca.markets/docs/api-references/broker-api/funding/bank/#creating-a-new-bank-relationship for
    more details.
    """

    ABA = "ABA"
    BIC = "BIC"


class BankStatus(str, Enum):
    """
    Represents the states a Bank instance can be in.

    Please see https://alpaca.markets/docs/api-references/broker-api/funding/bank/#enumbankstatus for more details.
    """

    QUEUED = "QUEUED"
    SENT_TO_CLEARING = "SENT_TO_CLEARING"
    APPROVED = "APPROVED"
    CANCELED = "CANCELED"


class TransferType(str, Enum):
    """
    Represents the types of transfers that can be made.

    Please see https://alpaca.markets/docs/api-references/broker-api/funding/transfers/#enumtransfertype for more
    details.
    """

    ACH = "ach"
    WIRE = "wire"


class TransferStatus(str, Enum):
    """
    Represents the states a Transfer instance can be in.

    Please see https://alpaca.markets/docs/api-references/broker-api/funding/transfers/#enumtransferstatus for more
    details.
    """

    QUEUED = "QUEUED"
    APPROVAL_PENDING = "APPROVAL_PENDING"
    PENDING = "PENDING"
    SENT_TO_CLEARING = "SENT_TO_CLEARING"
    REJECTED = "REJECTED"
    CANCELED = "CANCELED"
    APPROVED = "APPROVED"
    COMPLETE = "COMPLETE"
    RETURNED = "RETURNED"


class TransferDirection(str, Enum):
    """
    Represents the direction of the transfer.

    Please see https://alpaca.markets/docs/api-references/broker-api/funding/transfers/#enumtransferdirection for more
    details.
    """

    INCOMING = "INCOMING"
    OUTGOING = "OUTGOING"


class TransferTiming(str, Enum):
    """
    Represents the timing of a transfer.

    Please see https://alpaca.markets/docs/api-references/broker-api/funding/transfers/#creating-a-transfer-entity for
    more details.
    """

    IMMEDIATE = "immediate"


class FeePaymentMethod(str, Enum):
    """
    Represents who is responsible for paying fees associated with the transfer.

    Please see https://alpaca.markets/docs/api-references/broker-api/funding/transfers/#enumfeepaymentmethod for more
    details.
    """

    USER = "user"
    INVOICE = "invoice"


class JournalEntryType(str, Enum):
    """
    Represents the types of journals. Cash journals are transfers of cash.
    Security journals are transfers of securities like stocks.

    Please see https://alpaca.markets/docs/api-references/broker-api/journals/ for more details.
    """

    CASH = "JNLC"
    SECURITY = "JNLS"


class JournalStatus(str, Enum):
    """
    The various states a journal can be in during its lifecycle.

    Please see https://alpaca.markets/docs/api-references/broker-api/journals/#enumjournalstatus for more details.
    """

    QUEUED = "queued"
    SENT_TO_CLEARING = "sent_to_clearing"
    PENDING = "pending"
    EXECUTED = "executed"
    REJECTED = "rejected"
    CANCELED = "canceled"
    REFUSED = "refused"
    CORRECT = "correct"
    DELETED = "deleted"


class PortfolioStatus(str, Enum):
    """
    The possible values of the Portfolio status.

    See https://docs.alpaca.markets/reference/get-v1-rebalancing-portfolios
    """

    ACTIVE = "active"
    INACTIVE = "inactive"
    NEEDS_ADJUSTMENT = "needs_adjustment"


class WeightType(str, Enum):
    """
    The possible values of the Weight type.

    See https://docs.alpaca.markets/reference/post-v1-rebalancing-portfolios
    """

    CASH = "cash"
    ASSET = "asset"


class RebalancingConditionsType(str, Enum):
    """
    The possible values of the Rebalancing Conditions type.

    See https://docs.alpaca.markets/reference/post-v1-rebalancing-portfolios
    """

    DRIFT_BAND = "drift_band"
    CALENDAR = "calendar"


class DriftBandSubType(str, Enum):
    """
    The possible values of the Rebalancing Conditions subtype for drift_band.

    See https://docs.alpaca.markets/reference/post-v1-rebalancing-portfolios
    """

    ABSOLUTE = "absolute"
    RELATIVE = "relative"


class CalendarSubType(str, Enum):
    """
    The possible values of the Rebalancing Conditions subtype for drift_band.

    See https://docs.alpaca.markets/reference/post-v1-rebalancing-portfolios
    """

    WEEKLY = "weekly"
    MONTHLY = "monthly"
    QUARTERLY = "quarterly"
    ANNUALLY = "annually"


class RunType(str, Enum):
    """
    The possible values of the Run type.

    See https://docs.alpaca.markets/reference/post-v1-rebalancing-runs
    """

    FULL_REBALANCE = "full_rebalance"
    INVEST_CASH = "invest_cash"


class RunInitiatedFrom(str, Enum):
    """
    The possible values of the initiated_from field.

    See https://docs.alpaca.markets/docs/portfolio-rebalancing
    """

    SYSTEM = "system"
    API = "api"


class RunStatus(str, Enum):
    """
    The possible values of the Run status.

    See https://docs.alpaca.markets/reference/get-v1-rebalancing-runs
    """

    QUEUED = "QUEUED"
    IN_PROGRESS = "IN_PROGRESS"
    CANCELED = "CANCELED"
    CANCELED_MID_RUN = "CANCELED_MID_RUN"
    ERROR = "ERROR"
    TIMEOUT = "TIMEOUT"
    COMPLETED_SUCCESS = "COMPLETED_SUCCESS"
    COMPLETED_ADJUSTED = "COMPLETED_ADJUSTED"
````

## File: alpaca/broker/requests.py
````python
from datetime import date, datetime
from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from pydantic import field_validator, model_validator

from alpaca.broker.enums import (
    AccountEntities,
    BankAccountType,
    CalendarSubType,
    DocumentType,
    DriftBandSubType,
    FeePaymentMethod,
    FundingSource,
    IdentifierType,
    JournalEntryType,
    JournalStatus,
    PortfolioStatus,
    RebalancingConditionsType,
    RunType,
    TradeDocumentType,
    TransferDirection,
    TransferTiming,
    TransferType,
    UploadDocumentMimeType,
    UploadDocumentSubType,
    VisaType,
    WeightType,
)
from alpaca.broker.models.accounts import (
    AccountDocument,
    Agreement,
    Contact,
    Disclosures,
    Identity,
    TrustedContact,
)
from alpaca.broker.models.documents import W8BenDocument
from alpaca.common.enums import Sort, SupportedCurrencies
from alpaca.common.models import BaseModel
from alpaca.common.requests import NonEmptyRequest
from alpaca.trading.enums import AccountStatus, ActivityType, AssetClass, OrderType
from alpaca.trading.requests import LimitOrderRequest as BaseLimitOrderRequest
from alpaca.trading.requests import MarketOrderRequest as BaseMarketOrderRequest
from alpaca.trading.requests import OrderRequest as BaseOrderRequest
from alpaca.trading.requests import StopLimitOrderRequest as BaseStopLimitOrderRequest
from alpaca.trading.requests import StopOrderRequest as BaseStopOrderRequest
from alpaca.trading.requests import (
    TrailingStopOrderRequest as BaseTrailingStopOrderRequest,
)

# ############################## Accounts ################################# #


class UploadW8BenDocumentRequest(NonEmptyRequest):
    """
    Attributes:
        content (Optional[str]): A string containing Base64 encoded data to upload. Must be set if `content_data` is not
          set.
        content_data (Optional[W8BenDocument]): The data representing a W8BEN document in field form. Must be set if
          `content` is not set.
        mime_type (UploadDocumentMimeType): The mime type of the data in `content`, or if using `content_data` must be
          UploadDocumentMimeType.JSON. If `content_data` is set this will default to JSON
    """

    # These 2 are purposely undocumented as they should be here for NonEmptyRequest but they shouldn't be touched or
    # set by users since they always need to be set values
    document_type: DocumentType
    document_sub_type: UploadDocumentSubType

    content: Optional[str] = None
    content_data: Optional[W8BenDocument] = None
    mime_type: UploadDocumentMimeType

    def __init__(self, **data) -> None:
        # Always set these to their expected values
        data["document_type"] = DocumentType.W8BEN
        data["document_sub_type"] = UploadDocumentSubType.FORM_W8_BEN

        if (
            "mime_type" not in data
            and "content_data" in data
            and data["content_data"] is not None
        ):
            data["mime_type"] = UploadDocumentMimeType.JSON

        super().__init__(**data)

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        content_is_none = values.get("content", None) is None
        content_data_is_none = values.get("content_data", None) is None

        if content_is_none and content_data_is_none:
            raise ValueError(
                "You must specify one of either the `content` or `content_data` fields"
            )

        if not content_is_none and not content_data_is_none:
            raise ValueError(
                "You can only specify one of either the `content` or `content_data` fields"
            )

        if values["document_type"] != DocumentType.W8BEN:
            raise ValueError("document_type must be W8BEN.")

        if values["document_sub_type"] != UploadDocumentSubType.FORM_W8_BEN:
            raise ValueError("document_sub_type must be FORM_W8_BEN.")

        if (
            not content_data_is_none
            and values["mime_type"] != UploadDocumentMimeType.JSON
        ):
            raise ValueError("If `content_data` is set then `mime_type` must be JSON")

        return values


class CreateAccountRequest(NonEmptyRequest):
    """Class used to format data necessary for making a request to create a brokerage account

    Attributes:
        contact (Contact): The contact details for the account holder
        identity (Identity): The identity details for the account holder
        disclosures (Disclosures): The account holder's political disclosures
        agreements (List[Agreement]): The agreements the account holder has signed
        documents (List[Union[AccountDocument, UploadW8BenDocumentRequest]]): The documents the account holder has submitted
        trusted_contact (TrustedContact): The account holder's trusted contact details
    """

    contact: Contact
    identity: Identity
    disclosures: Disclosures
    agreements: List[Agreement]
    documents: Optional[List[Union[AccountDocument, UploadW8BenDocumentRequest]]] = None
    trusted_contact: Optional[TrustedContact] = None
    currency: Optional[SupportedCurrencies] = None  # None = USD
    enabled_assets: Optional[List[AssetClass]] = None  # None = Default to server

    @model_validator(mode="before")
    def validate_parameters_only_optional_in_response(cls, values: dict) -> dict:
        """
        Validate parameters that are optional in the response but not in the request.
        """
        nullable_fields_by_model = {
            "contact": "phone_number",
            "identity": "date_of_birth",
            "disclosures": "is_control_person",
            "disclosures": "is_affiliated_exchange_or_finra",
            "disclosures": "is_politically_exposed",
        }
        for model, field in nullable_fields_by_model.items():
            if dict(values[model]).get(field, None) is None:
                raise ValueError(f"{field} is required to create a new account.")
        return values


class UpdatableContact(Contact):
    """
    An extended version of Contact that has all fields as optional, so you don't need to specify all fields if you only
    want to update a subset of them.

    Attributes:
        email_address (Optional[str]): The user's email address
        phone_number (Optional[str]): The user's phone number. It should include the country code.
        street_address (Optional[List[str]]): The user's street address lines.
        unit (Optional[str]): The user's apartment unit, if any.
        city (Optional[str]): The city the user resides in.
        state (Optional[str]): The state the user resides in. This is required if country is 'USA'.
        postal_code (Optional[str]): The user's postal
        country (Optional[str]): The country the user resides in. 3 letter country code is permissible.
    """

    # override the non-optional fields to now be optional
    email_address: Optional[str] = None
    phone_number: Optional[str] = None
    street_address: Optional[List[str]] = None
    city: Optional[str] = None


# We don't extend the Identity model because we have to remove fields, not all of them are updatable
class UpdatableIdentity(NonEmptyRequest):
    """
       This class is a subset version of Identity. Currently, not all fields on accounts are modifiable so this class
       represents which ones are modifiable on the `identity` field of an account when making an
       BrokerClient::update_account call.

       Also has all fields as optional, so you don't need to specify all fields if you only want to update a subset

    Attributes:
           given_name (Optional[str]): The user's first name
           middle_name (Optional[str]): The user's middle name, if any
           family_name (Optional[str]): The user's last name
           tax_id (Optional[str]): The user's country specific tax id, required if tax_id_type is provided
           tax_id_type (Optional[TaxIdType]): The tax_id_type for the tax_id provided, required if tax_id provided
           country_of_citizenship (Optional[str]): The country the user is a citizen
           country_of_birth (Optional[str]): The country the user was born
           country_of_tax_residence (Optional[str]): The country the user files taxes
           visa_type (Optional[VisaType]): Only used to collect visa types for users residing in the USA.
           visa_expiration_date (Optional[str]): The date of expiration for visa, Required if visa_type is set.
           date_of_departure_from_usa (Optional[str]): Required if visa_type = B1 or B2
           permanent_resident (Optional[bool]): Only used to collect permanent residence status in the USA.
           funding_source (Optional[List[FundingSource]]): How the user will fund their account
           annual_income_min (Optional[float]): The minimum of the user's income range
           annual_income_max (Optional[float]): The maximum of the user's income range
           liquid_net_worth_min (Optional[float]): The minimum of the user's liquid net worth range
           liquid_net_worth_max (Optional[float]): The maximum of the user's liquid net worth range
           total_net_worth_min (Optional[float]): The minimum of the user's total net worth range
           total_net_worth_max (Optional[float]): The maximum of the user's total net worth range
    """

    given_name: Optional[str] = None
    middle_name: Optional[str] = None
    family_name: Optional[str] = None
    visa_type: Optional[VisaType] = None
    visa_expiration_date: Optional[str] = None
    date_of_departure_from_usa: Optional[str] = None
    permanent_resident: Optional[bool] = None
    funding_source: Optional[List[FundingSource]] = None
    annual_income_min: Optional[float] = None
    annual_income_max: Optional[float] = None
    liquid_net_worth_min: Optional[float] = None
    liquid_net_worth_max: Optional[float] = None
    total_net_worth_min: Optional[float] = None
    total_net_worth_max: Optional[float] = None


class UpdatableDisclosures(Disclosures):
    """
    An extended version of Disclosures that has all fields as optional, so you don't need to specify all fields if you
    only want to update a subset of them.

    Attributes:
        is_control_person (Optional[bool]): Whether user holds a controlling position in a publicly traded company
        is_affiliated_exchange_or_finra (Optional[bool]): If user is affiliated with any exchanges or FINRA
        is_politically_exposed (Optional[bool]): If user is politically exposed
        immediate_family_exposed (Optional[bool]): If user‚Äôs immediate family member is either politically exposed or holds a control position.
        employment_status (Optional[EmploymentStatus]): The employment status of the user
        employer_name (Optional[str]): The user's employer's name, if any
        employer_address (Optional[str]): The user's employer's address, if any
        employment_position (Optional[str]): The user's employment position, if any
    """

    is_control_person: Optional[bool] = None
    is_affiliated_exchange_or_finra: Optional[bool] = None
    is_politically_exposed: Optional[bool] = None
    immediate_family_exposed: Optional[bool] = None


class UpdatableTrustedContact(TrustedContact):
    """
    An extended version of TrustedContact that has all fields as optional, so you don't need to specify all fields if
    you only want to update a subset of them.

    Attributes:
        given_name (Optional[str]): The first name of the user's trusted contact
        family_name (Optional[str]): The last name of the user's trusted contact
        email_address (Optional[str]): The email address of the user's trusted contact
        phone_number (Optional[str]): The email address of the user's trusted contact
        city (Optional[str]): The email address of the user's trusted contact
        state (Optional[str]): The email address of the user's trusted contact
        postal_code (Optional[str]): The email address of the user's trusted contact
        country (Optional[str]): The email address of the user's trusted contact
    """

    # only need to override these 2 as other fields were already optional
    given_name: Optional[str] = None
    family_name: Optional[str] = None

    # override the parent and set a new root field_validator that just allows all
    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        """Override parent method to allow null contact info"""
        return values


class UpdateAccountRequest(NonEmptyRequest):
    """
    Represents the data allowed in a request to update an Account. Note not all fields of an account
    are currently modifiable so this model uses models that represent the subset of modifiable fields.

    Attributes:
        contact (Optional[UpdatableContact]): Contact details to update to
        identity (Optional[UpdatableIdentity]): Identity details to update to
        disclosures (Optional[UpdatableDisclosures]): Disclosure details to update to
        trusted_contact (Optional[UpdatableTrustedContact]): TrustedContact details to update to
    """

    contact: Optional[UpdatableContact] = None
    identity: Optional[UpdatableIdentity] = None
    disclosures: Optional[UpdatableDisclosures] = None
    trusted_contact: Optional[UpdatableTrustedContact] = None


class ListAccountsRequest(NonEmptyRequest):
    """
    Represents the values you can specify when making a request to list accounts

    Attributes:
        query (Optional[str]): Pass space-delimited tokens. The response will contain accounts that match with each of
         the tokens (logical AND). A match means the token is present in either the account‚Äôs associated account number,
         phone number, name, or e-mail address (logical OR).
        created_before (Optional[datetime]): Accounts that were created before this date
        created_after (Optional[datetime]): Accounts that were created after this date
        status (Optional[AccountStatus]): Accounts that have their status field as one of these
        sort (Sort, optional): The chronological order of response based on the submission time. Defaults to DESC.
        entities (Optional[List[AccountEntities]]): By default, this endpoint doesn't return all information for each
         account to save space in the response. This field lets you specify what additional information you want to be
         included on each account.

         ie, specifying [IDENTITY, CONTACT] would ensure that each returned account has its `identity` and `contact`
         fields filled out.
    """

    query: Optional[str] = None
    created_before: Optional[datetime] = None
    created_after: Optional[datetime] = None
    status: Optional[List[AccountStatus]] = None
    sort: Sort
    entities: Optional[List[AccountEntities]] = None

    def __init__(self, *args, **kwargs):
        # The api itself actually defaults to DESC, but this way our docs won't be incorrect if the api changes under us
        if "sort" not in kwargs or kwargs["sort"] is None:
            kwargs["sort"] = Sort.DESC

        super().__init__(*args, **kwargs)


class GetAccountActivitiesRequest(NonEmptyRequest):
    """
    Represents the filtering values you can specify when getting AccountActivities for an Account

    **Notes on pagination and the `page_size` and `page_token` fields**.

    The BrokerClient::get_account_activities function by default will automatically handle the pagination of results
    for you to get all results at once. However, if you're requesting a very large amount of results this can use a
    large amount of memory and time to gather all the results. If you instead want to handle
    pagination yourself `page_size` and `page_token` are how you would handle this.

    Say you put in a request with `page_size` set to 4, you'll only get 4 results back to get
    the next "page" of results you would set `page_token` to be the `id` field of the last Activity returned in the
    result set.

    This gets more indepth if you start specifying the `sort` field as well. If specified with a direction of Sort.DESC,
    for example, the results will end before the activity with the specified ID. However, specified with a direction of
    Sort.ASC, results will begin with the activity immediately after the one specified.

    Also, to note if `date` is not specified, the default and maximum `page_size` value is 100. If `date` is specified,
    the default behavior is to return all results, and there is no maximum page size; page size is still supported in
    this state though.

    Please see https://alpaca.markets/docs/api-references/broker-api/accounts/account-activities/#retrieving-account-activities
    for more information

    Attributes:
        account_id (Optional[Union[UUID, str]]): Specifies to filter to only activities for this Account
        activity_types (Optional[List[ActivityType]]): A list of ActivityType's to filter results down to
        date (Optional[datetime]): Filter to Activities only on this date.
        until (Optional[datetime]): Filter to Activities before this date. Cannot be used if `date` is also specified.
        after (Optional[datetime]): Filter to Activities after this date. Cannot be used if `date` is also specified.
        direction (Optional[Sort]): Which direction to sort results in. Defaults to Sort.DESC
        page_size (Optional[int]): The maximum number of entries to return in the response
        page_token (Optional[Union[UUID, str]]): If you're not using the built-in pagination this field is what you
          would use to mark the end of the results of your last page.
    """

    account_id: Optional[Union[UUID, str]] = None
    activity_types: Optional[List[ActivityType]] = None
    date: Optional[datetime] = None
    until: Optional[datetime] = None
    after: Optional[datetime] = None
    direction: Optional[Sort] = None
    page_size: Optional[int] = None
    page_token: Optional[Union[UUID, str]] = None

    def __init__(self, *args, **kwargs):
        if "account_id" in kwargs and type(kwargs["account_id"]) == str:
            kwargs["account_id"] = UUID(kwargs["account_id"])

        super().__init__(*args, **kwargs)

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        """Verify that certain conflicting params aren't set"""

        date_set = "date" in values and values["date"] is not None
        after_set = "after" in values and values["after"] is not None
        until_set = "until" in values and values["until"] is not None

        if date_set and after_set:
            raise ValueError("Cannot set date and after at the same time")

        if date_set and until_set:
            raise ValueError("Cannot set date and until at the same time")

        return values


# ############################## Documents ################################# #


class GetTradeDocumentsRequest(NonEmptyRequest):
    """
    Represents the various filters you can specify when making a call to get TradeDocuments for an Account

    Attributes:
        start (Optional[Union[date, str]]): Filter to TradeDocuments created after this Date. str values will attempt to
          be upcast into date instances. Format must be in YYYY-MM-DD.
        end (Optional[Union[date, str]]): Filter to TradeDocuments created before this Date. str values will attempt to
          be upcast into date instances. Format must be in YYYY-MM-DD.
        type (Optional[TradeDocumentType]): Filter to only these types of TradeDocuments
    """

    start: Optional[Union[date, str]] = None
    end: Optional[Union[date, str]] = None
    type: Optional[TradeDocumentType] = None

    def __init__(self, **data) -> None:
        if "start" in data and isinstance(data["start"], str):
            data["start"] = date.fromisoformat(data["start"])

        if "end" in data and isinstance(data["end"], str):
            data["end"] = date.fromisoformat(data["end"])

        super().__init__(**data)

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        if (
            "start" in values
            and values["start"] is not None
            and "end" in values
            and values["end"] is not None
            and values["start"] > values["end"]
        ):
            raise ValueError("start must not be after end!!")

        return values


class UploadDocumentRequest(NonEmptyRequest):
    """
    Attributes:
        document_type (DocumentType): The type of document you are uploading
        document_sub_type (Optional[UploadDocumentSubType]): If supported for the corresponding `document_type` this
          field allows you to specify a sub type to be even more specific.
        content (str): A string containing Base64 encoded data to upload.
        mime_type (UploadDocumentMimeType): The mime type of the data in `content`
    """

    document_type: DocumentType
    document_sub_type: Optional[UploadDocumentSubType] = None
    content: str
    mime_type: UploadDocumentMimeType

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        if values["document_type"] == DocumentType.W8BEN:
            raise ValueError(
                "Error please use the UploadW8BenDocument class for uploading W8BEN documents"
            )

        if values.get("document_sub_type", None) == UploadDocumentSubType.FORM_W8_BEN:
            raise ValueError(
                "Error please use the UploadW8BenDocument class for uploading W8BEN documents"
            )

        return values


# ############################## Banking and Transfers ################################# #


class CreateACHRelationshipRequest(NonEmptyRequest):
    """
    Attributes:
        account_owner_name (str): The name of the ACH account owner for the relationship that is being created.
        bank_account_type (BankAccountType): Specifies the type of bank account for the ACH relationship that is being
          created.
        bank_account_number (str): The bank account number associated with the ACH relationship.
        bank_routing_number (str): THe bank routing number associated with the ACH relationship.
        nickname (Optional[str]): Optionally specify a nickname to assign to the created ACH relationship.
    """

    account_owner_name: str
    bank_account_type: BankAccountType
    bank_account_number: str  # TODO: Validate bank account number format.
    bank_routing_number: str  # TODO: Validate bank routing number format.
    nickname: Optional[str] = None


class CreatePlaidRelationshipRequest(NonEmptyRequest):
    """
    This request is made following the Plaid bank account link user flow.

    Upon the user completing their connection with Plaid, a public token specific to the user is returned by Plaid. This
    token is used to get an Alpaca processor token via Plaid's /processor/token/create endpoint, which is subsequently
    used by this endpoint to transfer the user's Plaid information to Alpaca.

    Attributes:
        processor_token (str): The processor token that is specific to Alpaca and was returned by Plaid.
    """

    processor_token: str


class CreateBankRequest(NonEmptyRequest):
    """
    Attributes:
        name (str): The name of the recipient bank.
        bank_code_type (IdentifierType): Specifies the type of the bank (international or domestic). See
          enums.IdentifierType for more details.
        bank_code (str): The 9-digit ABA routing number (domestic) or bank identifier code (BIC, international).
        account_number (str): The bank account number.
        country (Optional[str]): The country of the bank, if and only if creating an international bank account
          connection.
        state_province (Optional[str]): The state/province of the bank, if and only if creating an international bank
          account connection.
        postal_code (Optional[str]): The postal code of the bank, if and only if creating an international bank account
          connection.
        city (Optional[str]): The city of the bank, if and only if creating an international bank account connection.
        street_address (Optional[str]): The street address of the bank, if and only if creating an international bank
          account connection.
    """

    name: str
    bank_code_type: IdentifierType
    bank_code: str
    account_number: str
    country: Optional[str] = None
    state_province: Optional[str] = None
    postal_code: Optional[str] = None
    city: Optional[str] = None
    street_address: Optional[str] = None

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        if "bank_code_type" not in values:
            # Bank code type was not valid, so a ValueError will be thrown regardless.
            return values

        international_parameters = [
            "country",
            "state_province",
            "postal_code",
            "city",
            "street_address",
        ]

        bank_code_type = values["bank_code_type"]
        if bank_code_type == IdentifierType.ABA:
            for international_param in international_parameters:
                if (
                    international_param in values
                    and values[international_param] is not None
                ):
                    raise ValueError(
                        f"You may only specify the {international_param} for international bank accounts."
                    )
        elif bank_code_type == IdentifierType.BIC:
            for international_param in international_parameters:
                if (
                    international_param not in values
                    or values[international_param] is None
                ):
                    raise ValueError(
                        f"You must specify the {international_param} for international bank accounts."
                    )

        return values


class _CreateTransferRequest(NonEmptyRequest):
    """
    Attributes:
        amount (str): Amount of transfer, must be > 0. Any applicable fees will be deducted from this value.
        direction (TransferDirection): Direction of the transfer.
        timing (TransferTiming): Timing of the transfer.
        fee_payment_method (Optional[FeePaymentMethod]): Determines how any applicable fees will be paid. Default value
          is invoice.
    """

    amount: str
    direction: TransferDirection
    timing: TransferTiming
    fee_payment_method: Optional[FeePaymentMethod] = None

    @field_validator("amount")
    def amount_must_be_positive(cls, value: str) -> str:
        if float(value) <= 0:
            raise ValueError("You must provide an amount > 0.")
        return value


class CreateACHTransferRequest(_CreateTransferRequest):
    """
    Attributes:
        transfer_type (TransferType): Type of the transfer.
        relationship_id (Optional[UUID]): ID of the relationship to use for the transfer, required for ACH transfers.
    """

    relationship_id: UUID
    transfer_type: TransferType = TransferType.ACH

    @field_validator("transfer_type")
    def transfer_type_must_be_ach(cls, value: TransferType) -> TransferType:
        if value != TransferType.ACH:
            raise ValueError(
                "Transfer type must be TransferType.ACH for ACH transfer requests."
            )
        return value


class CreateBankTransferRequest(_CreateTransferRequest):
    """
    Attributes:
        bank_id (UUID): ID of the bank to use for the transfer, required for wire transfers.
        additional_information (Optional[str]): Additional wire transfer details.
    """

    bank_id: UUID
    transfer_type: TransferType = TransferType.WIRE
    additional_information: Optional[str] = None

    @field_validator("transfer_type")
    def transfer_type_must_be_wire(cls, value: TransferType) -> TransferType:
        if value != TransferType.WIRE:
            raise ValueError(
                "Transfer type must be TransferType.WIRE for bank transfer requests."
            )
        return value


class GetTransfersRequest(NonEmptyRequest):
    """
    Attributes:
        direction: Optionally filter for transfers of only a single TransferDirection.
    """

    direction: Optional[TransferDirection] = None
    limit: Optional[int] = None
    offset: Optional[int] = None


# ############################## Orders ################################# #


class OrderRequest(BaseOrderRequest):
    """
    See base alpaca.trading.requests.OrderRequest model for more information.

    Attributes:
        symbol (str): The symbol identifier for the asset being traded
        qty (Optional[float]): The number of shares to trade. Fractional qty for stocks only with market orders.
        notional (Optional[float]): The base currency value of the shares to trade. For stocks, only works with MarketOrders.
            **Does not work with qty**.
        side (OrderSide): Whether the order will buy or sell the asset.
        type (OrderType): The execution logic type of the order (market, limit, etc).
        time_in_force (TimeInForce): The expiration logic of the order.
        extended_hours (Optional[float]): Whether the order can be executed during regular market hours.
        client_order_id (Optional[float]): A string to identify which client submitted the order.
        order_class (Optional[OrderClass]): The class of the order. Simple orders have no other legs.
        take_profit (Optional[TakeProfitRequest]): For orders with multiple legs, an order to exit a profitable trade.
        stop_loss (Optional[StopLossRequest]): For orders with multiple legs, an order to exit a losing trade.
        commission (Optional[float]): The dollar value commission you want to charge the end user.
    """

    commission: Optional[float] = None
    currency: Optional[SupportedCurrencies] = None  # None = USD

    @model_validator(mode="before")
    def order_type_must_be_market_for_lct(
        cls, values: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Order type must always be market if currency is not USD.
        See https://alpaca.markets/docs/broker/integration/lct/#submit-stock-trade
        """
        if (
            values.get("type") != OrderType.MARKET
            and "currency" in values
            and values.get("currency", SupportedCurrencies.USD)
            != SupportedCurrencies.USD
        ):
            raise ValueError(
                "Order type must be OrderType.MARKET if the order is in a local currency."
            )
        return values


class MarketOrderRequest(BaseMarketOrderRequest):
    """
    See base alpaca.trading.requests.MarketOrderRequest model for more information.

    Attributes:
        symbol (str): The symbol identifier for the asset being traded
        qty (Optional[float]): The number of shares to trade. Fractional qty for stocks only with market orders.
        notional (Optional[float]): The base currency value of the shares to trade. For stocks, only works with MarketOrders.
            **Does not work with qty**.
        side (OrderSide): Whether the order will buy or sell the asset.
        type (OrderType): The execution logic type of the order (market, limit, etc).
        time_in_force (TimeInForce): The expiration logic of the order.
        extended_hours (Optional[float]): Whether the order can be executed during regular market hours.
        client_order_id (Optional[float]): A string to identify which client submitted the order.
        order_class (Optional[OrderClass]): The class of the order. Simple orders have no other legs.
        take_profit (Optional[TakeProfitRequest]): For orders with multiple legs, an order to exit a profitable trade.
        stop_loss (Optional[StopLossRequest]): For orders with multiple legs, an order to exit a losing trade.
        commission (Optional[float]): The dollar value commission you want to charge the end user.
    """

    commission: Optional[float] = None


class LimitOrderRequest(BaseLimitOrderRequest):
    """
    See base alpaca.trading.requests.LimitOrderRequest model for more information.

    Attributes:
        symbol (str): The symbol identifier for the asset being traded
        qty (Optional[float]): The number of shares to trade. Fractional qty for stocks only with market orders.
        notional (Optional[float]): The base currency value of the shares to trade. For stocks, only works with MarketOrders.
            **Does not work with qty**.
        side (OrderSide): Whether the order will buy or sell the asset.
        type (OrderType): The execution logic type of the order (market, limit, etc).
        time_in_force (TimeInForce): The expiration logic of the order.
        extended_hours (Optional[float]): Whether the order can be executed during regular market hours.
        client_order_id (Optional[float]): A string to identify which client submitted the order.
        order_class (Optional[OrderClass]): The class of the order. Simple orders have no other legs.
        take_profit (Optional[TakeProfitRequest]): For orders with multiple legs, an order to exit a profitable trade.
        stop_loss (Optional[StopLossRequest]): For orders with multiple legs, an order to exit a losing trade.
        limit_price (float): The worst fill price for a limit or stop limit order.
        commission (Optional[float]): The dollar value commission you want to charge the end user.
    """

    commission: Optional[float] = None


class StopOrderRequest(BaseStopOrderRequest):
    """
    See base alpaca.trading.requests.StopOrderRequest model for more information.

    Attributes:
        symbol (str): The symbol identifier for the asset being traded
        qty (Optional[float]): The number of shares to trade. Fractional qty for stocks only with market orders.
        notional (Optional[float]): The base currency value of the shares to trade. For stocks, only works with MarketOrders.
            **Does not work with qty**.
        side (OrderSide): Whether the order will buy or sell the asset.
        type (OrderType): The execution logic type of the order (market, limit, etc).
        time_in_force (TimeInForce): The expiration logic of the order.
        extended_hours (Optional[float]): Whether the order can be executed during regular market hours.
        client_order_id (Optional[float]): A string to identify which client submitted the order.
        order_class (Optional[OrderClass]): The class of the order. Simple orders have no other legs.
        take_profit (Optional[TakeProfitRequest]): For orders with multiple legs, an order to exit a profitable trade.
        stop_loss (Optional[StopLossRequest]): For orders with multiple legs, an order to exit a losing trade.
        stop_price (float): The price at which the stop order is converted to a market order or a stop limit
            order is converted to a limit order.
        commission (Optional[float]): The dollar value commission you want to charge the end user.
    """

    commission: Optional[float] = None


class StopLimitOrderRequest(BaseStopLimitOrderRequest):
    """
    See base alpaca.trading.requests.StopLimitOrderRequest model for more information.

    Attributes:
        symbol (str): The symbol identifier for the asset being traded
        qty (Optional[float]): The number of shares to trade. Fractional qty for stocks only with market orders.
        notional (Optional[float]): The base currency value of the shares to trade. For stocks, only works with MarketOrders.
            **Does not work with qty**.
        side (OrderSide): Whether the order will buy or sell the asset.
        type (OrderType): The execution logic type of the order (market, limit, etc).
        time_in_force (TimeInForce): The expiration logic of the order.
        extended_hours (Optional[float]): Whether the order can be executed during regular market hours.
        client_order_id (Optional[float]): A string to identify which client submitted the order.
        order_class (Optional[OrderClass]): The class of the order. Simple orders have no other legs.
        take_profit (Optional[TakeProfitRequest]): For orders with multiple legs, an order to exit a profitable trade.
        stop_loss (Optional[StopLossRequest]): For orders with multiple legs, an order to exit a losing trade.
        stop_price (float): The price at which the stop order is converted to a market order or a stop limit
            order is converted to a limit order.
        limit_price (float): The worst fill price for a limit or stop limit order.
        commission (Optional[float]): The dollar value commission you want to charge the end user
    """

    commission: Optional[float] = None


class TrailingStopOrderRequest(BaseTrailingStopOrderRequest):
    """
    See base alpaca.trading.requests.TrailingStopOrderRequest model for more information.

    Attributes:
        symbol (str): The symbol identifier for the asset being traded
        qty (Optional[float]): The number of shares to trade. Fractional qty for stocks only with market orders.
        notional (Optional[float]): The base currency value of the shares to trade. For stocks, only works with MarketOrders.
            **Does not work with qty**.
        side (OrderSide): Whether the order will buy or sell the asset.
        type (OrderType): The execution logic type of the order (market, limit, etc).
        time_in_force (TimeInForce): The expiration logic of the order.
        extended_hours (Optional[float]): Whether the order can be executed during regular market hours.
        client_order_id (Optional[float]): A string to identify which client submitted the order.
        order_class (Optional[OrderClass]): The class of the order. Simple orders have no other legs.
        take_profit (Optional[TakeProfitRequest]): For orders with multiple legs, an order to exit a profitable trade.
        stop_loss (Optional[StopLossRequest]): For orders with multiple legs, an order to exit a losing trade.
        trail_price (Optional[float]): The absolute price difference by which the trailing stop will trail.
        trail_percent (Optional[float]): The percent price difference by which the trailing stop will trail.
        commission (Optional[float]): The dollar value commission you want to charge the end user.
    """

    commission: Optional[float] = None


# ############################## Journals ################################# #


class CreateJournalRequest(NonEmptyRequest):
    """
    Data for request to initiate a single journal.

    Attributes:
        to_account (UUID): The account ID that received the journal.
        from_account (UUID): The account ID that initiates the journal.
        entry_type (JournalEntryType): Whether the journal is a cash or security journal.
        symbol (Optional[str]): For security journals, the symbol identifier of the security being journaled.
        qty (Optional[float]): For security journals, the quantity of the security being journaled.
        amount (Optional[float]): For cash journals, the total cash amount journaled in USD.
        description (Optional[str]): Journal description. It can include fixtures for sandbox API.
        transmitter_name (Optional[str]): For cash journals, travel rule related name info.
        transmitter_account_number (Optional[str]): For cash journals, travel rule account number info.
        transmitter_address (Optional[str]): For cash journals, travel rule related address info.
        transmitter_financial_institution (Optional[str]): For cash journals, travel rule related institution info.
        transmitter_timestamp (Optional[str]): For cash journals, travel rule related timestamp info.
    """

    from_account: UUID
    entry_type: JournalEntryType
    to_account: UUID
    amount: Optional[float] = None
    symbol: Optional[str] = None
    qty: Optional[float] = None
    description: Optional[str] = None
    transmitter_name: Optional[str] = None
    transmitter_account_number: Optional[str] = None
    transmitter_address: Optional[str] = None
    transmitter_financial_institution: Optional[str] = None
    transmitter_timestamp: Optional[str] = None
    currency: Optional[SupportedCurrencies] = None  # None = USD

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        entry_type = values.get("entry_type")
        symbol = values.get("symbol")
        qty = values.get("qty")
        amount = values.get("amount")

        # amount is for cash journals, symbol and qty are for security journals
        # they are mutually exclusive
        if entry_type is not None and entry_type == JournalEntryType.CASH:
            if symbol or qty:
                raise ValueError("Symbol and qty are reserved for security journals.")

            if not amount:
                raise ValueError("Cash journals must contain an amount to transfer.")

        if entry_type is not None and entry_type == JournalEntryType.SECURITY:
            if amount:
                raise ValueError("Amount is reserved for cash journals.")

            if not symbol or not qty:
                raise ValueError(
                    "Security journals must contain a symbol and corresponding qty to transfer."
                )

        return values


class BatchJournalRequestEntry(NonEmptyRequest):
    """
    Entry in batch journal request.

    Attributes:
        to_account (UUID): Account to fund in batch journal request.
        amount (Union[str, float]): The cash amount in USD to fund by.
        description (Optional[str]): Journal description.
        transmitter_name (Optional[str]): For cash journals, travel rule related name info.
        transmitter_account_number (Optional[str]): For cash journals, travel rule account number info.
        transmitter_address (Optional[str]): For cash journals, travel rule related address info.
        transmitter_financial_institution (Optional[str]): For cash journals, travel rule related institution info.
        transmitter_timestamp (Optional[str]): For cash journals, travel rule related timestamp info.
    """

    to_account: UUID
    amount: Union[str, float]
    description: Optional[str] = None
    transmitter_name: Optional[str] = None
    transmitter_account_number: Optional[str] = None
    transmitter_address: Optional[str] = None
    transmitter_financial_institution: Optional[str] = None
    transmitter_timestamp: Optional[str] = None


class ReverseBatchJournalRequestEntry(NonEmptyRequest):
    """
    Entry in reverse batch journal request.

    Attributes:
        from_account (UUID): Account from fund in batch journal request.
        amount (Union[str, float]): The cash amount in USD to fund by.
        description (Optional[str]): Journal description.
        transmitter_name (Optional[str]): For cash journals, travel rule related name info.
        transmitter_account_number (Optional[str]): For cash journals, travel rule account number info.
        transmitter_address (Optional[str]): For cash journals, travel rule related address info.
        transmitter_financial_institution (Optional[str]): For cash journals, travel rule related institution info.
        transmitter_timestamp (Optional[str]): For cash journals, travel rule related timestamp info.
    """

    from_account: UUID
    amount: Union[str, float]
    description: Optional[str] = None
    transmitter_name: Optional[str] = None
    transmitter_account_number: Optional[str] = None
    transmitter_address: Optional[str] = None
    transmitter_financial_institution: Optional[str] = None
    transmitter_timestamp: Optional[str] = None


class CreateBatchJournalRequest(NonEmptyRequest):
    """
    This model represents the fields you can specify when creating
    a request of many Journals out of one account to many others at once.

    Currently, batch journals are only enabled on cash journals.

    Attributes:
        entry_type (JournalEntryType): The type of journal transfer.
        from_account (UUID): The originator of funds. Most likely is your Sweep Firm Account
        entries (List[BatchJournalRequestEntry]): List of journals to execute.
    """

    entry_type: JournalEntryType
    from_account: UUID
    entries: List[BatchJournalRequestEntry]


class CreateReverseBatchJournalRequest(NonEmptyRequest):
    """
    This model represents the fields you can specify when creating
    a request of many Journals into one account from many other accounts at once.

    Currently, reverse batch journals are only enabled on cash journals.

    Attributes:
        entry_type (JournalEntryType): The type of journal transfer.
        to_account (UUID): The destination of funds. Most likely is your Sweep Firm Account
        entries (List[BatchJournalRequestEntry]): List of journals to execute.
    """

    entry_type: JournalEntryType
    to_account: UUID
    entries: List[ReverseBatchJournalRequestEntry]


class GetJournalsRequest(NonEmptyRequest):
    """
    This model represents the fields you can specify when querying from the list of all journals.

    Attributes:
        after (Optional[date]): Journal creation dates after this date.
        before (Optional[date]): Journal creation dates before this date.
        status (Optional[JournalStatus]): Only journals with this status.
        entry_type (Optional[JournalEntryType]): Only journals with this entry type.
        to_account (Optional[UUID]): Only journals to this account.
        from_account (Optional[UUID]): Only journals from this account.
    """

    after: Optional[date] = None
    before: Optional[date] = None
    status: Optional[JournalStatus] = None
    entry_type: Optional[JournalEntryType] = None
    to_account: Optional[UUID] = None
    from_account: Optional[UUID] = None


class GetEventsRequest(NonEmptyRequest):
    id: Optional[str] = None
    since: Optional[Union[date, str]] = None
    until: Optional[Union[date, str]] = None
    since_id: Optional[int] = None
    until_id: Optional[int] = None


# ############################## Rebalancing ################################# #


class Weight(BaseModel):
    """
    Weight model.

    https://docs.alpaca.markets/reference/post-v1-rebalancing-portfolios
    """

    type: WeightType
    symbol: Optional[str] = None
    percent: float

    @field_validator("percent")
    def percent_must_be_positive(cls, value: float) -> float:
        """Validate and round the percent field to 2 decimal places."""
        if value <= 0:
            raise ValueError("You must provide an amount > 0.")
        return round(value, 2)

    @model_validator(mode="before")
    def validator(cls, values: dict) -> dict:
        """Verify that the symbol is provided when the weights type is asset."""
        if (
            values["type"] == WeightType.ASSET.value
            and values.get("symbol", None) is None
        ):
            raise ValueError
        return values


class RebalancingConditions(BaseModel):
    """
    Rebalancing conditions model.

    https://docs.alpaca.markets/reference/post-v1-rebalancing-portfolios
    """

    type: RebalancingConditionsType
    sub_type: Union[DriftBandSubType, CalendarSubType]
    percent: Optional[float] = None
    day: Optional[str] = None


class CreatePortfolioRequest(NonEmptyRequest):
    """
    Portfolio request model.

    https://docs.alpaca.markets/reference/post-v1-rebalancing-portfolios
    """

    name: str
    description: str
    weights: List[Weight]
    cooldown_days: int
    rebalance_conditions: Optional[List[RebalancingConditions]] = None


class UpdatePortfolioRequest(NonEmptyRequest):
    """
    Portfolio request update model.

    https://docs.alpaca.markets/reference/patch-v1-rebalancing-portfolios-portfolio_id-1
    """

    name: Optional[str] = None
    description: Optional[str] = None
    weights: Optional[List[Weight]] = None
    cooldown_days: Optional[int] = None
    rebalance_conditions: Optional[List[RebalancingConditions]] = None


class GetPortfoliosRequest(NonEmptyRequest):
    """
    Get portfolios request query parameters.

    https://docs.alpaca.markets/reference/get-v1-rebalancing-portfolios
    """

    name: Optional[str] = None
    description: Optional[str] = None
    symbol: Optional[str] = None
    portfolio_id: Optional[UUID] = None
    status: Optional[PortfolioStatus] = None


class CreateSubscriptionRequest(NonEmptyRequest):
    """
    Subscription request model.

    https://docs.alpaca.markets/reference/post-v1-rebalancing-subscriptions-1
    """

    account_id: UUID
    portfolio_id: UUID


class GetSubscriptionsRequest(NonEmptyRequest):
    """
    Get subscriptions request query parameters.

    https://docs.alpaca.markets/reference/get-v1-rebalancing-subscriptions-1
    """

    account_id: Optional[UUID] = None
    portfolio_id: Optional[UUID] = None
    limit: Optional[int] = None
    page_token: Optional[str] = None


class CreateRunRequest(NonEmptyRequest):
    """
    Manually creates a rebalancing run.

    https://docs.alpaca.markets/reference/post-v1-rebalancing-runs
    """

    account_id: UUID
    type: RunType
    weights: List[Weight]


class GetRunsRequest(NonEmptyRequest):
    """
    Get runs request query parameters.

    https://docs.alpaca.markets/reference/get-v1-rebalancing-runs
    """

    account_id: Optional[UUID] = None
    type: Optional[RunType] = None
    limit: Optional[int] = None


class CreateOptionExerciseRequest(NonEmptyRequest):
    commission: Optional[float] = None
````

## File: alpaca/common/__init__.py
````python
from alpaca.common.models import *
from alpaca.common.enums import *
from alpaca.common.constants import *
from alpaca.common.exceptions import *
from alpaca.common.types import *
from alpaca.common.utils import *
````

## File: alpaca/common/constants.py
````python
from typing import TypeVar

DATA_V2_MAX_LIMIT = 10000  # max items per api call

ACCOUNT_ACTIVITIES_DEFAULT_PAGE_SIZE = 100

BROKER_DOCUMENT_UPLOAD_LIMIT = 10

PageItem = TypeVar("PageItem")  # Generic type for an item from a paginated request.

DEFAULT_RETRY_ATTEMPTS = 3
DEFAULT_RETRY_WAIT_SECONDS = 3
DEFAULT_RETRY_EXCEPTION_CODES = [429, 504]
````

## File: alpaca/common/enums.py
````python
from enum import Enum


class BaseURL(str, Enum):
    """Base urls for API endpoints"""

    BROKER_SANDBOX = "https://broker-api.sandbox.alpaca.markets"
    BROKER_PRODUCTION = "https://broker-api.alpaca.markets"
    TRADING_PAPER = "https://paper-api.alpaca.markets"
    TRADING_LIVE = "https://api.alpaca.markets"
    DATA = "https://data.alpaca.markets"
    DATA_SANDBOX = "https://data.sandbox.alpaca.markets"
    MARKET_DATA_STREAM = "wss://stream.data.alpaca.markets"
    OPTION_DATA_STREAM = "wss://stream.data.alpaca.markets"  # Deprecated: use MARKET_DATA_STREAM instead!
    TRADING_STREAM_PAPER = "wss://paper-api.alpaca.markets/stream"
    TRADING_STREAM_LIVE = "wss://api.alpaca.markets/stream"


class PaginationType(str, Enum):
    """
    An enum for choosing what type of pagination of results you'd like for BrokerClient functions that support
    pagination.

    Attributes:
        NONE: Requests that we perform no pagination of results and just return the single response the API gave us.
        FULL: Requests that we perform all the pagination and return just a single List/dict/etc containing all the
          results. This is the default for most functions.
        ITERATOR: Requests that we return an Iterator that yields one "page" of results at a time
    """

    NONE = "none"
    FULL = "full"
    ITERATOR = "iterator"


class Sort(str, Enum):
    ASC = "asc"
    DESC = "desc"


class SupportedCurrencies(str, Enum):
    """
    The various currencies that can be supported for LCT.

    see https://alpaca.markets/support/local-currency-trading-faq
    """

    USD = "USD"
    GBP = "GBP"
    CHF = "CHF"
    EUR = "EUR"
    CAD = "CAD"
    JPY = "JPY"
    TRY = "TRY"
    AUD = "AUD"
    CZK = "CZK"
    SEK = "SEK"
    DKK = "DKK"
    SGD = "SGD"
    HKD = "HKD"
    HUF = "HUF"
    NZD = "NZD"
    NOK = "NOK"
    PLN = "PLN"
````

## File: alpaca/common/exceptions.py
````python
import json


class APIError(Exception):
    """
    Represent API related error.
    error.status_code will have http status code.
    """

    def __init__(self, error, http_error=None):
        super().__init__(error)
        self._error = error
        self._http_error = http_error

    @property
    def code(self):
        error = json.loads(self._error)
        return error["code"]

    @property
    def message(self):
        error = json.loads(self._error)
        return error["message"]

    @property
    def status_code(self):
        http_error = self._http_error
        if http_error is not None and hasattr(http_error, "response"):
            return http_error.response.status_code

    @property
    def request(self):
        if self._http_error is not None:
            return self._http_error.request

    @property
    def response(self):
        if self._http_error is not None:
            return self._http_error.response


class RetryException(Exception):
    """
    Thrown by RESTClient's internally to represent a request that should be retried.
    """

    pass
````

## File: alpaca/common/models.py
````python
from uuid import UUID
from pydantic import BaseModel
import pprint


class ValidateBaseModel(BaseModel, validate_assignment=True):
    """
    This model simply sets up BaseModel with the validate_assignment flag to True, so we don't have to keep specifying
    it or forget to specify it in our models where we want assignment validation
    """

    def __repr__(self):
        return pprint.pformat(self.model_dump(), indent=4)


class ModelWithID(ValidateBaseModel):
    """
    This is the base model for response models with IDs that are UUIDs.
    """

    id: UUID
````

## File: alpaca/common/requests.py
````python
from datetime import date, datetime, timezone
from ipaddress import IPv4Address, IPv6Address
from typing import Any
from uuid import UUID

from alpaca.common.models import ValidateBaseModel as BaseModel


class NonEmptyRequest(BaseModel):
    """
    Mixin for models that represent requests where we don't want to send nulls for optional fields.
    """

    def to_request_fields(self) -> dict:
        """
        the equivalent of self::dict but removes empty values and handles converting non json serializable types.

        Ie say we only set trusted_contact.given_name instead of generating a dict like:
          {contact: {city: None, country: None...}, etc}
        we generate just:
          {trusted_contact:{given_name: "new value"}}

        NOTE: This function recurses to handle nested models, so do not use on a self-referential model

        Returns:
            dict: a dict containing any set fields
        """

        def map_values(val: Any) -> Any:
            """
            Some types have issues being json encoded, we convert them here to be encodable

            also handles nested models and lists
            """

            if isinstance(val, UUID):
                return str(val)

            if isinstance(val, NonEmptyRequest):
                return val.to_request_fields()

            if isinstance(val, dict):
                return {k: map_values(v) for k, v in val.items()}

            if isinstance(val, list):
                return [map_values(v) for v in val]

            # RFC 3339
            if isinstance(val, datetime):
                # if the datetime is naive, assume it's UTC
                # https://docs.python.org/3/library/datetime.html#determining-if-an-object-is-aware-or-naive
                if val.tzinfo is None or val.tzinfo.utcoffset(val) is None:
                    val = val.replace(tzinfo=timezone.utc)
                return val.isoformat()

            if isinstance(val, date):
                return val.isoformat()

            if isinstance(val, IPv4Address):
                return str(val)

            if isinstance(val, IPv6Address):
                return str(val)

            return val

        d = self.model_dump(exclude_none=True)
        if "symbol_or_symbols" in d:
            s = d["symbol_or_symbols"]
            if isinstance(s, list):
                s = ",".join(s)
            d["symbols"] = s
            del d["symbol_or_symbols"]

        # pydantic almost has what we need by passing exclude_none to dict() but it returns:
        #  {trusted_contact: {}, contact: {}, identity: None, etc}
        # so we do a simple list comprehension to filter out None and {}
        return {
            key: map_values(val)
            for key, val in d.items()
            if val is not None and val != {} and len(str(val)) > 0
        }
````

## File: alpaca/common/rest.py
````python
from collections import defaultdict
from collections.abc import Callable
import time
import base64
from abc import ABC
from typing import Any, Dict, List, Optional, Type, Union, Tuple, Iterator

from pydantic import BaseModel
from requests import Session
from requests.exceptions import HTTPError
from itertools import chain

from alpaca.common.constants import (
    DEFAULT_RETRY_ATTEMPTS,
    DEFAULT_RETRY_WAIT_SECONDS,
    DEFAULT_RETRY_EXCEPTION_CODES,
)

from alpaca import __version__
from alpaca.common.exceptions import APIError, RetryException
from alpaca.common.types import RawData, HTTPResult, Credentials
from .constants import PageItem
from .enums import PaginationType, BaseURL


class RESTClient(ABC):
    """Abstract base class for REST clients"""

    def __init__(
        self,
        base_url: Union[BaseURL, str],
        api_key: Optional[str] = None,
        secret_key: Optional[str] = None,
        oauth_token: Optional[str] = None,
        use_basic_auth: bool = False,
        api_version: str = "v2",
        sandbox: bool = False,
        raw_data: bool = False,
        retry_attempts: Optional[int] = None,
        retry_wait_seconds: Optional[int] = None,
        retry_exception_codes: Optional[List[int]] = None,
    ) -> None:
        """Abstract base class for REST clients. Handles submitting HTTP requests to
        Alpaca API endpoints.

        Args:
            base_url (Union[BaseURL, str]): The base url to target requests to. Should be an instance of BaseURL, but
              allows for raw str if you need to override
            api_key (Optional[str]): The api key string for authentication.
            secret_key (Optional[str]): The corresponding secret key string for the api key.
            oauth_token (Optional[str]): The oauth token if authenticating via OAuth.
            use_basic_auth (bool): Whether API requests should use basic authorization headers.
            api_version (Optional[str]): The API version for the endpoints.
            sandbox (bool): False if the live API should be used.
            raw_data (bool): Whether API responses should be wrapped in data models or returned raw.
            retry_attempts (Optional[int]): The number of times to retry a request that returns a RetryException.
            retry_wait_seconds (Optional[int]): The number of seconds to wait between requests before retrying.
            retry_exception_codes (Optional[List[int]]): The API exception codes to retry a request on.
        """

        self._api_key, self._secret_key, self._oauth_token = self._validate_credentials(
            api_key=api_key, secret_key=secret_key, oauth_token=oauth_token
        )
        self._api_version: str = api_version
        self._base_url: Union[BaseURL, str] = base_url
        self._sandbox: bool = sandbox
        self._use_basic_auth: bool = use_basic_auth
        self._use_raw_data: bool = raw_data
        self._session: Session = Session()

        # setting up request retry configurations
        self._retry: int = DEFAULT_RETRY_ATTEMPTS
        self._retry_wait: int = DEFAULT_RETRY_WAIT_SECONDS
        self._retry_codes: List[int] = DEFAULT_RETRY_EXCEPTION_CODES

        if retry_attempts and retry_attempts > 0:
            self._retry = retry_attempts

        if retry_wait_seconds and retry_wait_seconds > 0:
            self._retry_wait = retry_wait_seconds

        if retry_exception_codes:
            self._retry_codes = retry_exception_codes

    def _request(
        self,
        method: str,
        path: str,
        data: Optional[Union[dict, str]] = None,
        base_url: Optional[Union[BaseURL, str]] = None,
        api_version: Optional[str] = None,
    ) -> HTTPResult:
        """Prepares and submits HTTP requests to given API endpoint and returns response.
        Handles retrying if 429 (Rate Limit) error arises.

        Args:
            method (str): The API endpoint HTTP method
            path (str): The API endpoint path
            data (Optional[Union[dict, str]]): Either the payload in json format, query params urlencoded, or a dict
             of values to be converted to appropriate format based on `method`. Defaults to None.
            base_url (Optional[Union[BaseURL, str]]): The base URL of the API. Defaults to None.
            api_version (Optional[str]): The API version. Defaults to None.

        Returns:
            HTTPResult: The response from the API
        """
        base_url = base_url or self._base_url
        version = api_version if api_version else self._api_version
        url: str = base_url + "/" + version + path

        headers = self._get_default_headers()

        opts = {
            "headers": headers,
            # Since we allow users to set endpoint URL via env var,
            # human error to put non-SSL endpoint could exploit
            # uncanny issues in non-GET request redirecting http->https.
            # It's better to fail early if the URL isn't right.
            "allow_redirects": False,
        }

        if method.upper() in ["GET", "DELETE"]:
            opts["params"] = data
        else:
            opts["json"] = data

        retry = self._retry

        while retry >= 0:
            try:
                return self._one_request(method, url, opts, retry)
            except RetryException:
                time.sleep(self._retry_wait)
                retry -= 1
                continue

    def _get_default_headers(self) -> dict:
        """
        Returns a dict with some default headers set; ie AUTH headers and such that should be useful on all requests
        Extracted for cases when using the default request functions are insufficient

        Returns:
            dict: The resulting dict of headers
        """
        headers = self._get_auth_headers()

        headers["User-Agent"] = "APCA-PY/" + __version__

        return headers

    def _get_auth_headers(self) -> dict:
        """
        Get the auth headers for a request. Meant to be overridden in clients that don't use this format for requests,
        ie: BrokerClient

        Returns:
            dict: A dict containing the expected auth headers
        """

        headers = {}

        if self._oauth_token:
            headers["Authorization"] = "Bearer " + self._oauth_token
        elif self._use_basic_auth:
            api_key_secret = "{key}:{secret}".format(
                key=self._api_key, secret=self._secret_key
            ).encode("utf-8")
            encoded_api_key_secret = base64.b64encode(api_key_secret).decode("utf-8")
            headers["Authorization"] = "Basic " + encoded_api_key_secret
        else:
            headers["APCA-API-KEY-ID"] = self._api_key
            headers["APCA-API-SECRET-KEY"] = self._secret_key

        return headers

    def _one_request(self, method: str, url: str, opts: dict, retry: int) -> dict:
        """Perform one request, possibly raising RetryException in the case
        the response is 429. Otherwise, if error text contain "code" string,
        then it decodes to json object and returns APIError.
        Returns the body json in the 200 status.

        Args:
            method (str): The HTTP method - GET, POST, etc
            url (str): The API endpoint URL
            opts (dict): Contains optional parameters including headers and parameters
            retry (int): The number of times to retry in case of RetryException

        Raises:
            RetryException: Raised if request produces 429 error and retry limit has not been reached
            APIError: Raised if API returns an error

        Returns:
            dict: The response data
        """
        response = self._session.request(method, url, **opts)

        try:
            response.raise_for_status()
        except HTTPError as http_error:
            # retry if we hit Rate Limit
            if response.status_code in self._retry_codes and retry > 0:
                raise RetryException()

            # raise API error for all other errors
            error = response.text

            raise APIError(error, http_error)

        if response.text != "":
            return response.json()

    def get(
        self, path: str, data: Optional[Union[dict, str]] = None, **kwargs
    ) -> HTTPResult:
        """Performs a single GET request

        Args:
            path (str): The API endpoint path
            data (Union[dict, str], optional): Query parameters to send, either
            as a str urlencoded, or a dict of values to be converted. Defaults to None.

        Returns:
            dict: The response
        """
        return self._request("GET", path, data, **kwargs)

    def post(
        self, path: str, data: Optional[Union[dict, List[dict]]] = None
    ) -> HTTPResult:
        """Performs a single POST request

        Args:
            path (str): The API endpoint path
            data (Optional[Union[dict, List[dict]]): The json payload as a dict of values to be converted.
             Defaults to None.

        Returns:
            dict: The response
        """
        return self._request("POST", path, data)

    def put(self, path: str, data: Optional[dict] = None) -> dict:
        """Performs a single PUT request

        Args:
            path (str): The API endpoint path
            data (Optional[dict]): The json payload as a dict of values to be converted.
             Defaults to None.

        Returns:
            dict: The response
        """
        return self._request("PUT", path, data)

    def patch(self, path: str, data: Optional[dict] = None) -> dict:
        """Performs a single PATCH request

        Args:
            path (str): The API endpoint path
            data (Optional[dict]): The json payload as a dict of values to be converted.
             Defaults to None.

        Returns:
            dict: The response
        """
        return self._request("PATCH", path, data)

    def delete(self, path, data: Optional[Union[dict, str]] = None) -> dict:
        """Performs a single DELETE request

        Args:
            path (str): The API endpoint path
            data (Union[dict, str], optional): The payload if any. Defaults to None.

        Returns:
            dict: The response
        """
        return self._request("DELETE", path, data)

    # TODO: Refactor to be able to handle both parsing to types and parsing to collections of types (parse_as_obj)
    def response_wrapper(
        self, model: Type[BaseModel], raw_data: RawData, **kwargs
    ) -> Union[BaseModel, RawData]:
        """To allow the user to get raw response from the api, we wrap all
        functions with this method, checking if the user has set raw_data
        bool. if they didn't, we wrap the response with a BaseModel object.

        Args:
            model (Type[BaseModel]): Class that response will be wrapped in
            raw_data (RawData): The raw data from API in dictionary
            kwargs : Any constructor parameters necessary for the base model

        Returns:
            Union[BaseModel, RawData]: either raw or parsed data
        """
        if self._use_raw_data:
            return raw_data
        else:
            return model(raw_data=raw_data, **kwargs)

    @staticmethod
    def _validate_pagination(
        max_items_limit: Optional[int], handle_pagination: Optional[PaginationType]
    ) -> PaginationType:
        """
        Private method for validating the max_items_limit and handle_pagination arguments, returning the resolved
        PaginationType.
        """
        if handle_pagination is None:
            handle_pagination = PaginationType.FULL

        if handle_pagination != PaginationType.FULL and max_items_limit is not None:
            raise ValueError(
                "max_items_limit can only be specified for PaginationType.FULL"
            )
        return handle_pagination

    @staticmethod
    def _return_paginated_result(
        iterator: Iterator[PageItem], handle_pagination: PaginationType
    ) -> Union[List[PageItem], Iterator[List[PageItem]]]:
        """
        Private method for converting an iterator that yields results to the proper pagination type result.
        """
        if handle_pagination == PaginationType.NONE:
            # user wants no pagination, so just do a single page
            return next(iterator)
        elif handle_pagination == PaginationType.FULL:
            # the iterator returns "pages", so we use chain to flatten them all into 1 list
            return list(chain.from_iterable(iterator))
        elif handle_pagination == PaginationType.ITERATOR:
            return iterator
        else:
            raise ValueError(f"Invalid pagination type: {handle_pagination}.")

    @staticmethod
    def _validate_credentials(
        api_key: Optional[str] = None,
        secret_key: Optional[str] = None,
        oauth_token: Optional[str] = None,
    ) -> Credentials:
        """Gathers API credentials from parameters and environment variables, and validates them.
        Args:
            api_key (Optional[str]): The API key for authentication. Defaults to None.
            secret_key (Optional[str]): The secret key for authentication. Defaults to None.
            oauth_token (Optional[str]): The oauth token if authenticating via OAuth. Defaults to None.
        Raises:
             ValueError: If the combination of keys and tokens provided are not valid.
        Returns:
            Credentials: The set of validated authentication keys
        """

        if not oauth_token and not api_key:
            raise ValueError("You must supply a method of authentication")

        if oauth_token and (api_key or secret_key):
            raise ValueError(
                "Either an oauth_token or an api_key may be supplied, but not both"
            )

        if not oauth_token and not (api_key and secret_key):
            raise ValueError(
                "A corresponding secret_key must be supplied with the api_key"
            )

        return api_key, secret_key, oauth_token

    def _get_marketdata(
        self,
        path: str,
        params: Dict[str, Any],
        page_limit: int = 10_000,
        no_sub_key: bool = False,
    ) -> Dict[str, List[Any]]:
        d = defaultdict(list)
        limit = params.get("limit")
        total_items = 0
        page_token = params.get("page_token")

        while True:
            actual_limit = None

            # adjusts the limit parameter value if it is over the page_limit
            if limit:
                # actual_limit is the adjusted total number of items to query per request
                actual_limit = min(int(limit) - total_items, page_limit)
                if actual_limit < 1:
                    break

            params["limit"] = actual_limit
            params["page_token"] = page_token

            response = self.get(path=path, data=params)

            for k, v in _get_marketdata_entries(response, no_sub_key).items():
                if isinstance(v, list):
                    d[k].extend(v)
                else:
                    d[k] = v

            # if we've sent a request with a limit, increment count
            if actual_limit:
                total_items = sum([len(items) for items in d.values()])

            page_token = response.get("next_page_token", None)
            if page_token is None:
                break
        return dict(d)


def _get_marketdata_entries(response: HTTPResult, no_sub_key: bool) -> RawData:
    if no_sub_key:
        return response

    data_keys = {
        "bar",
        "bars",
        "corporate_actions",
        "news",
        "orderbook",
        "orderbooks",
        "quote",
        "quotes",
        "snapshot",
        "snapshots",
        "trade",
        "trades",
    }
    selected_keys = data_keys.intersection(response)
    # Neither of these should ever happen!
    if selected_keys is None or len(selected_keys) < 1:
        raise ValueError("The data in response does not match any known keys.")
    if len(selected_keys) > 1:
        raise ValueError("The data in response matches multiple known keys.")
    selected_key = selected_keys.pop()
    if selected_key == "news":
        return {"news": response[selected_key]}
    return response[selected_key]
````

## File: alpaca/common/types.py
````python
from typing import Any, Dict, List, Optional, Tuple, Union

RawData = Dict[str, Any]

# TODO: Refine this type
HTTPResult = Union[dict, List[dict], Any]
Credentials = Tuple[Optional[str], Optional[str], Optional[str]]
````

## File: alpaca/common/utils.py
````python
from typing import Union, Optional
from uuid import UUID
from datetime import datetime


def validate_uuid_id_param(
    id: Union[UUID, str],
    var_name: Optional[str] = None,
) -> UUID:
    """
    A small helper function to eliminate duplicate checks of various id parameters to ensure they are
    valid UUIDs. Upcasts str instances that are valid UUIDs into UUID instances.

    Args:
        id (Union[UUID, str]): The parameter to be validated
        var_name (Optional[str]): the name of the parameter you'd like to generate in the error message. Defaults to
          using `account_id` due to it being the most commonly needed case

    Returns:
        UUID: The valid UUID instance
    """

    if var_name is None:
        var_name = "account_id"

    # should raise ValueError
    if type(id) == str:
        id = UUID(id)
    elif type(id) != UUID:
        raise ValueError(f"{var_name} must be a UUID or a UUID str")

    return id


def validate_symbol_or_asset_id(
    symbol_or_asset_id: Union[UUID, str]
) -> Union[UUID, str]:
    """
    A helper function to eliminate duplicate checks of symbols or asset ids.

    If the argument given is a string, assumed to be a symbol name. If a UUID object, assumed to be an asset id.
    ValueError if neither type.

    Args:
        symbol_or_asset_id: String representing a symbol name or a UUID representing an asset id.

    Returns:
        String if symbol, UUID if asset id.
    """
    if isinstance(symbol_or_asset_id, (UUID, str)):
        return symbol_or_asset_id
    raise ValueError(
        "symbol_or_asset_id must be a UUID of an asset id or a string of a symbol."
    )


def validate_symbol_or_contract_id(
    symbol_or_contract_id: Union[UUID, str]
) -> Union[UUID, str]:
    """
    A helper function to eliminate duplicate checks of symbols or contract id.

    If the argument given is a string, assumed to be a symbol name. If a UUID object, assumed to be a contract id.
    ValueError if neither type.

    Args:
        symbol_or_contract_id: String representing a symbol name or a UUID representing a contract id.

    Returns:
        String if symbol, UUID if contract id.
    """
    if isinstance(symbol_or_contract_id, (UUID, str)):
        return symbol_or_contract_id
    raise ValueError(
        "symbol_or_contract_id must be a UUID of a contract id or a string of a symbol."
    )


def tz_aware(dt: datetime) -> bool:
    """
    Returns if a given datetime is timezone aware

    Args:
        dt: the datetime to bo checked

    Returns: timezone awareness

    """
    return dt.tzinfo is not None and dt.tzinfo.utcoffset(dt) is not None
````

## File: alpaca/data/historical/__init__.py
````python
from alpaca.data.historical.crypto import CryptoHistoricalDataClient
from alpaca.data.historical.news import NewsClient
from alpaca.data.historical.option import OptionHistoricalDataClient
from alpaca.data.historical.screener import ScreenerClient
from alpaca.data.historical.stock import StockHistoricalDataClient

__all__ = [
    "CryptoHistoricalDataClient",
    "StockHistoricalDataClient",
    "NewsClient",
    "OptionHistoricalDataClient",
    "ScreenerClient",
]
````

## File: alpaca/data/historical/corporate_actions.py
````python
from typing import Optional, Union

from alpaca.common.enums import BaseURL
from alpaca.common.rest import RESTClient
from alpaca.common.types import RawData
from alpaca.data.models.corporate_actions import CorporateActionsSet
from alpaca.data.requests import CorporateActionsRequest


class CorporateActionsClient(RESTClient):
    """
    The REST client for interacting with Alpaca Corporate Actions API endpoints.
    """

    def __init__(
        self,
        api_key: Optional[str] = None,
        secret_key: Optional[str] = None,
        oauth_token: Optional[str] = None,
        use_basic_auth: bool = False,
        raw_data: bool = False,
        url_override: Optional[str] = None,
    ) -> None:
        """
        Instantiates a Corporate Actions Client.

        Args:
            api_key (Optional[str], optional): Alpaca API key. Defaults to None.
            secret_key (Optional[str], optional): Alpaca API secret key. Defaults to None.
            oauth_token (Optional[str]): The oauth token if authenticating via OAuth. Defaults to None.
            use_basic_auth (bool, optional): If true, API requests will use basic authorization headers.
            raw_data (bool, optional): If true, API responses will not be wrapped and raw responses will be returned from
              methods. Defaults to False. This has not been implemented yet.
            url_override (Optional[str], optional): If specified allows you to override the base url the client points
              to for proxy/testing.
        """
        super().__init__(
            api_key=api_key,
            secret_key=secret_key,
            oauth_token=oauth_token,
            use_basic_auth=use_basic_auth,
            api_version="v1",
            base_url=url_override if url_override is not None else BaseURL.DATA,
            sandbox=False,
            raw_data=raw_data,
        )

    def get_corporate_actions(
        self, request_params: CorporateActionsRequest
    ) -> Union[RawData, CorporateActionsSet]:
        """Returns corporate actions data

        Args:
            request_params (CorporateActionsRequest): The request params to filter the corporate actions data
        """
        params = request_params.to_request_fields()

        if request_params.symbols:
            params["symbols"] = ",".join(request_params.symbols)
        if request_params.types:
            params["types"] = ",".join(request_params.types)

        response = self._get_marketdata(
            path="/corporate-actions",
            params=params,
            page_limit=1000,
        )
        if self._use_raw_data:
            return response

        return CorporateActionsSet(response)
````

## File: alpaca/data/historical/crypto.py
````python
from typing import Dict, Optional, Union

from alpaca.common.enums import BaseURL
from alpaca.common.rest import RESTClient
from alpaca.common.types import Credentials, RawData
from alpaca.data import Bar, Snapshot
from alpaca.data.enums import CryptoFeed
from alpaca.data.historical.utils import (
    parse_obj_as_symbol_dict,
)
from alpaca.data.models import BarSet, Orderbook, Quote, QuoteSet, Trade, TradeSet
from alpaca.data.requests import (
    CryptoBarsRequest,
    CryptoLatestBarRequest,
    CryptoLatestOrderbookRequest,
    CryptoLatestQuoteRequest,
    CryptoLatestTradeRequest,
    CryptoQuoteRequest,
    CryptoSnapshotRequest,
    CryptoTradesRequest,
)


class CryptoHistoricalDataClient(RESTClient):
    """
    A REST client for retrieving crypto market data.

    This client does not need any authentication to use.
    You can instantiate it with or without API keys.

    However, authenticating increases your data rate limit.

    Learn more about crypto historical data here:
    https://alpaca.markets/docs/api-references/market-data-api/crypto-pricing-data/historical/
    """

    def __init__(
        self,
        api_key: Optional[str] = None,
        secret_key: Optional[str] = None,
        oauth_token: Optional[str] = None,
        raw_data: bool = False,
        url_override: Optional[str] = None,
        use_basic_auth: bool = False,
        sandbox: bool = False,
    ) -> None:
        """
        Instantiates a Historical Data Client for Crypto Data.

        Args:
            api_key (Optional[str], optional): Alpaca API key. Defaults to None.
            secret_key (Optional[str], optional): Alpaca API secret key. Defaults to None.
            oauth_token (Optional[str]): The oauth token if authenticating via OAuth. Defaults to None.
            raw_data (bool, optional): If true, API responses will not be wrapped and raw responses will be returned from
              methods. Defaults to False. This has not been implemented yet.
            url_override (Optional[str], optional): If specified allows you to override the base url the client points
              to for proxy/testing.
            use_basic_auth (bool, optional): If true, API requests will use basic authorization headers. Set to true if using
              broker api sandbox credentials
            sandbox (bool): True if using sandbox mode. Defaults to False.
        """

        base_url = (
            url_override
            if url_override is not None
            else BaseURL.DATA_SANDBOX if sandbox else BaseURL.DATA
        )

        super().__init__(
            api_key=api_key,
            secret_key=secret_key,
            oauth_token=oauth_token,
            api_version="v1beta3",
            base_url=base_url,
            sandbox=sandbox,
            raw_data=raw_data,
            use_basic_auth=use_basic_auth,
        )

    def get_crypto_bars(
        self, request_params: CryptoBarsRequest, feed: CryptoFeed = CryptoFeed.US
    ) -> Union[BarSet, RawData]:
        """Gets bar/candle data for a cryptocurrency or list of cryptocurrencies.

        Args:
            request_params (CryptoBarsRequest): The parameters for the request.
            feed (CryptoFeed): The data feed for crypto bars.

        Returns:
            Union[BarSet, RawData]: The crypto bar data either in raw or wrapped form
        """

        # paginated get request for crypto market data api
        raw_bars = self._get_marketdata(
            path=f"/crypto/{feed.value}/bars",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_bars

        return BarSet(raw_bars)

    def get_crypto_quotes(
        self, request_params: CryptoQuoteRequest, feed: CryptoFeed = CryptoFeed.US
    ) -> Union[QuoteSet, RawData]:
        """Returns the quote data for a cryptocurrency or list of cryptocurrencies.

        Args:
            request_params (CryptoQuoteRequest): The parameters for the request.
            feed (CryptoFeed): The data feed for crypto quotes.

        Returns:
            Union[QuoteSet, RawData]: The crypto quote data either in raw or wrapped form
        """

        # paginated get request for market data api
        raw_quotes = self._get_marketdata(
            path=f"/crypto/{feed.value}/quotes",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_quotes

        return QuoteSet(raw_quotes)

    def get_crypto_trades(
        self, request_params: CryptoTradesRequest, feed: CryptoFeed = CryptoFeed.US
    ) -> Union[TradeSet, RawData]:
        """Returns the price and sales history over a given time period for a cryptocurrency
        or list of cryptocurrencies.

        Args:
            request_params (CryptoTradesRequest): The parameters for the request.
            feed (CryptoFeed): The data feed for crypto trades.

        Returns:
            Union[TradeSet, RawData]: The trade data either in raw or wrapped form
        """

        # paginated get request for market data api
        raw_trades = self._get_marketdata(
            path=f"/crypto/{feed.value}/trades",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_trades

        return TradeSet(raw_trades)

    def get_crypto_latest_trade(
        self, request_params: CryptoLatestTradeRequest, feed: CryptoFeed = CryptoFeed.US
    ) -> Union[Dict[str, Trade], RawData]:
        """Returns the latest trade for a coin.

        Args:
            request_params (CryptoLatestTradeRequest): The parameters for the request.
            feed (CryptoFeed): The data feed for the latest crypto trade.

        Returns:
            Union[Dict[str, Trade], RawData]: The latest trade in raw or wrapped format
        """

        raw_trades = self._get_marketdata(
            path=f"/crypto/{feed.value}/latest/trades",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_trades

        return parse_obj_as_symbol_dict(Trade, raw_trades)

    def get_crypto_latest_quote(
        self, request_params: CryptoLatestQuoteRequest, feed: CryptoFeed = CryptoFeed.US
    ) -> Union[Dict[str, Quote], RawData]:
        """Returns the latest quote for a coin.

        Args:
            request_params (CryptoLatestQuoteRequest): The parameters for the request.
            feed (CryptoFeed): The data feed for the latest crypto quote.

        Returns:
            Union[Dict[str, Quote], RawData]: The latest quote in raw or wrapped format
        """

        raw_quotes = self._get_marketdata(
            path=f"/crypto/{feed.value}/latest/quotes",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_quotes

        return parse_obj_as_symbol_dict(Quote, raw_quotes)

    def get_crypto_latest_bar(
        self, request_params: CryptoLatestBarRequest, feed: CryptoFeed = CryptoFeed.US
    ) -> Union[Dict[str, Bar], RawData]:
        """Returns the latest minute bar for a coin.

        Args:
            request_params (CryptoLatestBarRequest): The parameters for the request.
            feed (CryptoFeed): The data feed for the latest crypto bar.

        Returns:
            Union[Dict[str, Bar], RawData]: The latest bar in raw or wrapped format
        """

        raw_bars = self._get_marketdata(
            path=f"/crypto/{feed.value}/latest/bars",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_bars

        return parse_obj_as_symbol_dict(Bar, raw_bars)

    def get_crypto_latest_orderbook(
        self,
        request_params: CryptoLatestOrderbookRequest,
        feed: CryptoFeed = CryptoFeed.US,
    ) -> Union[Dict[str, Orderbook], RawData]:
        """
        Returns the latest orderbook state for the queried crypto symbols.

        Args:
            request_params (CryptoOrderbookRequest): The parameters for the orderbook request.
            feed (CryptoFeed): The data feed for the latest crypto orderbook.

        Returns:
            Union[Dict[str, Orderbook], RawData]: The orderbook data either in raw or wrapped form.
        """

        raw_orderbooks = self._get_marketdata(
            path=f"/crypto/{feed.value}/latest/orderbooks",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_orderbooks

        return parse_obj_as_symbol_dict(Orderbook, raw_orderbooks)

    def get_crypto_snapshot(
        self, request_params: CryptoSnapshotRequest, feed: CryptoFeed = CryptoFeed.US
    ) -> Union[Snapshot, RawData]:
        """Returns snapshots of queried crypto symbols. Snapshots contain latest trade, latest quote, latest minute bar,
        latest daily bar and previous daily bar data for the queried symbols.

        Args:
            request_params (CryptoSnapshotRequest): The parameters for the snapshot request.
            feed (CryptoFeed): The data feed for crypto snapshots.

        Returns:
            Union[SnapshotSet, RawData]: The snapshot data either in raw or wrapped form
        """

        raw_snapshots = self._get_marketdata(
            path=f"/crypto/{feed.value}/snapshots",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_snapshots

        return parse_obj_as_symbol_dict(Snapshot, raw_snapshots)

    # We override the _validate_credentials static method for crypto,
    # because crypto does not actually require authentication.
    @staticmethod
    def _validate_credentials(
        api_key: Optional[str] = None,
        secret_key: Optional[str] = None,
        oauth_token: Optional[str] = None,
    ) -> Credentials:
        """Gathers API credentials from parameters and environment variables, and validates them.
        Args:
            api_key (Optional[str]): The API key for authentication. Defaults to None.
            secret_key (Optional[str]): The secret key for authentication. Defaults to None.
            oauth_token (Optional[str]): The oauth token if authenticating via OAuth. Defaults to None.
        Raises:
             ValueError: If the combination of keys and tokens provided are not valid.
        Returns:
            Credentials: The set of validated authentication keys
        """

        if oauth_token and (api_key or secret_key):
            raise ValueError(
                "Either an oauth_token or an api_key may be supplied, but not both"
            )

        return api_key, secret_key, oauth_token
````

## File: alpaca/data/historical/news.py
````python
from typing import Optional, Union

from alpaca.common.enums import BaseURL
from alpaca.common.rest import RESTClient
from alpaca.common.types import RawData
from alpaca.data.models.news import NewsSet
from alpaca.data.requests import NewsRequest


class NewsClient(RESTClient):
    """
    The REST client for interacting with Alpaca News API endpoints.

    """

    def __init__(
        self,
        api_key: Optional[str] = None,
        secret_key: Optional[str] = None,
        oauth_token: Optional[str] = None,
        use_basic_auth: bool = False,
        raw_data: bool = False,
        url_override: Optional[str] = None,
    ) -> None:
        """
        Instantiates a Historical Data Client.

        Args:
            api_key (Optional[str], optional): Alpaca API key. Defaults to None.
            secret_key (Optional[str], optional): Alpaca API secret key. Defaults to None.
            oauth_token (Optional[str]): The oauth token if authenticating via OAuth. Defaults to None.
            use_basic_auth (bool, optional): If true, API requests will use basic authorization headers.
            raw_data (bool, optional): If true, API responses will not be wrapped and raw responses will be returned from
              methods. Defaults to False. This has not been implemented yet.
            url_override (Optional[str], optional): If specified allows you to override the base url the client points
              to for proxy/testing.
        """
        super().__init__(
            api_key=api_key,
            secret_key=secret_key,
            oauth_token=oauth_token,
            use_basic_auth=use_basic_auth,
            api_version="v1beta1",
            base_url=url_override if url_override is not None else BaseURL.DATA,
            sandbox=False,
            raw_data=raw_data,
        )

    def get_news(self, request_params: NewsRequest) -> Union[RawData, NewsSet]:
        """Returns news data

        Args:
            request_params (NewsRequest): The request params to filter the news data"""
        raw_news = self._get_marketdata(
            path=f"/news",
            params=request_params.to_request_fields(),
        )
        if self._use_raw_data:
            return raw_news

        return NewsSet(raw_news)
````

## File: alpaca/data/historical/option.py
````python
from enum import Enum
from typing import Dict, Optional, Union

from alpaca.common.enums import BaseURL
from alpaca.common.rest import RESTClient
from alpaca.common.types import RawData
from alpaca.data.historical.utils import (
    parse_obj_as_symbol_dict,
)
from alpaca.data.models.bars import BarSet
from alpaca.data.models.quotes import Quote
from alpaca.data.models.snapshots import OptionsSnapshot
from alpaca.data.models.trades import Trade, TradeSet
from alpaca.data.requests import (
    OptionBarsRequest,
    OptionChainRequest,
    OptionLatestQuoteRequest,
    OptionLatestTradeRequest,
    OptionSnapshotRequest,
    OptionTradesRequest,
)


class OptionHistoricalDataClient(RESTClient):
    """
    The REST client for interacting with Alpaca Market Data API option data endpoints.

    Learn more on https://docs.alpaca.markets/docs/about-market-data-api
    """

    def __init__(
        self,
        api_key: Optional[str] = None,
        secret_key: Optional[str] = None,
        oauth_token: Optional[str] = None,
        use_basic_auth: bool = False,
        raw_data: bool = False,
        url_override: Optional[str] = None,
        sandbox: bool = False,
    ) -> None:
        """
        Instantiates a Historical Data Client.

        Args:
            api_key (Optional[str], optional): Alpaca API key. Defaults to None.
            secret_key (Optional[str], optional): Alpaca API secret key. Defaults to None.
            oauth_token (Optional[str]): The oauth token if authenticating via OAuth. Defaults to None.
            use_basic_auth (bool, optional): If true, API requests will use basic authorization headers. Set to true if using
              broker api sandbox credentials
            raw_data (bool, optional): If true, API responses will not be wrapped and raw responses will be returned from
              methods. Defaults to False. This has not been implemented yet.
            url_override (Optional[str], optional): If specified allows you to override the base url the client points
              to for proxy/testing.
            sandbox (bool): True if using sandbox mode. Defaults to False.
        """

        base_url = (
            url_override
            if url_override is not None
            else BaseURL.DATA_SANDBOX if sandbox else BaseURL.DATA
        )

        super().__init__(
            api_key=api_key,
            secret_key=secret_key,
            oauth_token=oauth_token,
            use_basic_auth=use_basic_auth,
            api_version="v1beta1",
            base_url=base_url,
            sandbox=sandbox,
            raw_data=raw_data,
        )

    def get_option_bars(
        self, request_params: OptionBarsRequest
    ) -> Union[BarSet, RawData]:
        """Returns bar data for an option contract or list of option contracts over a given
        time period and timeframe.

        Args:
            request_params (OptionBarsRequest): The request object for retrieving option bar data.

        Returns:
            Union[BarSet, RawData]: The bar data either in raw or wrapped form
        """

        # paginated get request for market data api
        raw_bars = self._get_marketdata(
            path=f"/options/bars",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_bars

        return BarSet(raw_bars)

    def get_option_exchange_codes(self) -> RawData:
        """Returns the mapping between the option exchange codes and the corresponding exchanges names.

        Args:
            None

        Returns:
            RawData: The mapping between the option exchange codes and the corresponding exchanges names.
        """
        path = "/options/meta/exchanges"
        raw_exchange_code = self.get(
            path=path,
            api_version=self._api_version,
        )

        return raw_exchange_code

    def get_option_latest_quote(
        self, request_params: OptionLatestQuoteRequest
    ) -> Union[Dict[str, Quote], RawData]:
        """Retrieves the latest quote for an option symbol or list of option symbols.

        Args:
            request_params (OptionLatestQuoteRequest): The request object for retrieving the latest quote data.

        Returns:
            Union[Dict[str, Quote], RawData]: The latest quote in raw or wrapped format
        """
        raw_latest_quotes = self._get_marketdata(
            path=f"/options/quotes/latest",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_latest_quotes

        return parse_obj_as_symbol_dict(Quote, raw_latest_quotes)

    def get_option_latest_trade(
        self, request_params: OptionLatestTradeRequest
    ) -> Union[Dict[str, Trade], RawData]:
        """Retrieves the latest trade for an option symbol or list of option symbols.

        Args:
            request_params (OptionLatestQuoteRequest): The request object for retrieving the latest quote data.

        Returns:
            Union[Dict[str, Quote], RawData]: The latest quote in raw or wrapped format
        """
        raw_latest_trades = self._get_marketdata(
            path=f"/options/trades/latest",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_latest_trades

        return parse_obj_as_symbol_dict(Trade, raw_latest_trades)

    def get_option_trades(
        self, request_params: OptionTradesRequest
    ) -> Union[TradeSet, RawData]:
        """The historical option trades API provides trade data for a list of contract symbols between the specified dates up to 7 days ago.

        Args:
            request_params (OptionTradesRequest): The request object for retrieving option trade data.

        Returns:
            Union[TradeSet, RawData]: The trade data either in raw or wrapped form
        """
        raw_trades = self._get_marketdata(
            path=f"/options/trades",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_trades

        return TradeSet(raw_trades)

    def get_option_snapshot(
        self, request_params: OptionSnapshotRequest
    ) -> Union[Dict[str, OptionsSnapshot], RawData]:
        """Returns snapshots of queried symbols. OptionsSnapshot contain latest trade,
        latest quote, implied volatility, and greeks for the queried symbols.

        Args:
            request_params (OptionSnapshotRequest): The request object for retrieving snapshot data.

        Returns:
            Union[Dict[str, OptionsSnapshot], RawData]: The snapshot data either in raw or wrapped form
        """
        raw_snapshots = self._get_marketdata(
            path=f"/options/snapshots",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_snapshots

        return parse_obj_as_symbol_dict(OptionsSnapshot, raw_snapshots)

    def get_option_chain(
        self, request_params: OptionChainRequest
    ) -> Union[Dict[str, OptionsSnapshot], RawData]:
        """The option chain endpoint for underlying symbol provides the latest trade, latest quote,
        implied volatility, and greeks for each contract symbol of the underlying symbol.

        Args:
            request_params (OptionChainRequest): The request object for retrieving snapshot data.

        Returns:
            Union[Dict[str, OptionsSnapshot], RawData]: The snapshot data either in raw or wrapped form
        """

        params = request_params.to_request_fields()
        del params["underlying_symbol"]

        raw_snapshots = self._get_marketdata(
            path=f"/options/snapshots/{request_params.underlying_symbol}",
            params=params,
        )

        if self._use_raw_data:
            return raw_snapshots

        return parse_obj_as_symbol_dict(OptionsSnapshot, raw_snapshots)
````

## File: alpaca/data/historical/screener.py
````python
from typing import Optional, Union

from alpaca.common.enums import BaseURL
from alpaca.common.rest import RESTClient
from alpaca.common.types import RawData
from alpaca.data.models.screener import MostActives, Movers
from alpaca.data.requests import MarketMoversRequest, MostActivesRequest


class ScreenerClient(RESTClient):
    """
    The REST client for interacting with Alpaca Screener API endpoints.

    Learn more on https://docs.alpaca.markets/reference/mostactives
    """

    def __init__(
        self,
        api_key: Optional[str] = None,
        secret_key: Optional[str] = None,
        oauth_token: Optional[str] = None,
        use_basic_auth: bool = False,
        raw_data: bool = False,
        url_override: Optional[str] = None,
    ) -> None:
        """
        Instantiates a Historical Data Client.

        Args:
            api_key (Optional[str], optional): Alpaca API key. Defaults to None.
            secret_key (Optional[str], optional): Alpaca API secret key. Defaults to None.
            oauth_token (Optional[str]): The oauth token if authenticating via OAuth. Defaults to None.
            use_basic_auth (bool, optional): If true, API requests will use basic authorization headers.
            raw_data (bool, optional): If true, API responses will not be wrapped and raw responses will be returned from
              methods. Defaults to False. This has not been implemented yet.
            url_override (Optional[str], optional): If specified allows you to override the base url the client points
              to for proxy/testing.
        """
        super().__init__(
            api_key=api_key,
            secret_key=secret_key,
            oauth_token=oauth_token,
            use_basic_auth=use_basic_auth,
            api_version="v1beta1",
            base_url=url_override if url_override is not None else BaseURL.DATA,
            sandbox=False,
            raw_data=raw_data,
        )

    def get_most_actives(
        self, request_params: MostActivesRequest
    ) -> Union[RawData, MostActives]:
        """Returns most active stocks."""
        response = self.get(
            path="/screener/stocks/most-actives",
            data=request_params.to_request_fields(),
        )
        if self._use_raw_data:
            return response
        return MostActives(**response)

    def get_market_movers(
        self, request_params: MarketMoversRequest
    ) -> Union[RawData, Movers]:
        """Return market movers."""
        response = self.get(
            path=f"/screener/{request_params.market_type.lower()}/movers",
            data=request_params.model_dump(exclude={"market_type"}),
        )
        if self._use_raw_data:
            return response
        return Movers(**response)
````

## File: alpaca/data/historical/stock.py
````python
from collections import defaultdict
from enum import Enum
from typing import Dict, List, Optional, Union

from alpaca.common.constants import DATA_V2_MAX_LIMIT
from alpaca.common.enums import BaseURL
from alpaca.common.rest import RESTClient
from alpaca.common.types import RawData
from alpaca.data import Bar, Quote, Snapshot, Trade
from alpaca.data.historical.utils import (
    parse_obj_as_symbol_dict,
)
from alpaca.data.models import BarSet, QuoteSet, TradeSet
from alpaca.data.requests import (
    StockBarsRequest,
    StockLatestBarRequest,
    StockLatestQuoteRequest,
    StockLatestTradeRequest,
    StockQuotesRequest,
    StockSnapshotRequest,
    StockTradesRequest,
)


class StockHistoricalDataClient(RESTClient):
    """
    The REST client for interacting with Alpaca Market Data API stock data endpoints.

    Learn more on https://alpaca.markets/docs/market-data/
    """

    def __init__(
        self,
        api_key: Optional[str] = None,
        secret_key: Optional[str] = None,
        oauth_token: Optional[str] = None,
        use_basic_auth: bool = False,
        raw_data: bool = False,
        url_override: Optional[str] = None,
        sandbox: bool = False,
    ) -> None:
        """
        Instantiates a Historical Data Client.

        Args:
            api_key (Optional[str], optional): Alpaca API key. Defaults to None.
            secret_key (Optional[str], optional): Alpaca API secret key. Defaults to None.
            oauth_token (Optional[str]): The oauth token if authenticating via OAuth. Defaults to None.
            use_basic_auth (bool, optional): If true, API requests will use basic authorization headers. Set to true if using
              broker api sandbox credentials
            raw_data (bool, optional): If true, API responses will not be wrapped and raw responses will be returned from
              methods. Defaults to False. This has not been implemented yet.
            url_override (Optional[str], optional): If specified allows you to override the base url the client points
              to for proxy/testing.
            sandbox (bool): True if using sandbox mode. Defaults to False.
        """

        base_url = (
            url_override
            if url_override is not None
            else BaseURL.DATA_SANDBOX if sandbox else BaseURL.DATA
        )

        super().__init__(
            api_key=api_key,
            secret_key=secret_key,
            oauth_token=oauth_token,
            use_basic_auth=use_basic_auth,
            api_version="v2",
            base_url=base_url,
            sandbox=sandbox,
            raw_data=raw_data,
        )

    def get_stock_bars(
        self, request_params: StockBarsRequest
    ) -> Union[BarSet, RawData]:
        """Returns bar data for an equity or list of equities over a given
        time period and timeframe.

        Args:
            request_params (GetStockBarsRequest): The request object for retrieving stock bar data.

        Returns:
            Union[BarSet, RawData]: The bar data either in raw or wrapped form
        """
        raw_bars = self._get_marketdata(
            path="/stocks/bars",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_bars

        return BarSet(raw_bars)

    def get_stock_quotes(
        self, request_params: StockQuotesRequest
    ) -> Union[QuoteSet, RawData]:
        """Returns level 1 quote data over a given time period for a security or list of securities.

        Args:
            request_params (GetStockQuotesRequest): The request object for retrieving stock quote data.

        Returns:
            Union[QuoteSet, RawData]: The quote data either in raw or wrapped form
        """
        raw_quotes = self._get_marketdata(
            path="/stocks/quotes",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_quotes

        return QuoteSet(raw_quotes)

    def get_stock_trades(
        self, request_params: StockTradesRequest
    ) -> Union[TradeSet, RawData]:
        """Returns the price and sales history over a given time period for a security or list of securities.

        Args:
            request_params (GetStockTradesRequest): The request object for retrieving stock trade data.

        Returns:
            Union[TradeSet, RawData]: The trade data either in raw or wrapped form
        """
        raw_trades = self._get_marketdata(
            path="/stocks/trades",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_trades

        return TradeSet(raw_trades)

    def get_stock_latest_trade(
        self, request_params: StockLatestTradeRequest
    ) -> Union[Dict[str, Trade], RawData]:
        """Retrieves the latest trade for an equity symbol or list of equities.

        Args:
            request_params (StockLatestTradeRequest): The request object for retrieving the latest trade data.

        Returns:
            Union[Dict[str, Trade], RawData]: The latest trade in raw or wrapped format
        """
        raw_latest_trades = self._get_marketdata(
            path="/stocks/trades/latest",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_latest_trades

        return parse_obj_as_symbol_dict(Trade, raw_latest_trades)

    def get_stock_latest_quote(
        self, request_params: StockLatestQuoteRequest
    ) -> Union[Dict[str, Quote], RawData]:
        """Retrieves the latest quote for an equity symbol or list of equity symbols.

        Args:
            request_params (StockLatestQuoteRequest): The request object for retrieving the latest quote data.

        Returns:
            Union[Dict[str, Quote], RawData]: The latest quote in raw or wrapped format
        """
        raw_latest_quotes = self._get_marketdata(
            path="/stocks/quotes/latest",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_latest_quotes

        return parse_obj_as_symbol_dict(Quote, raw_latest_quotes)

    def get_stock_latest_bar(
        self, request_params: StockLatestBarRequest
    ) -> Union[Dict[str, Bar], RawData]:
        """Retrieves the latest minute bar for an equity symbol or list of equity symbols.

        Args:
            request_params (StockLatestBarRequest): The request object for retrieving the latest bar data.

        Returns:
            Union[Dict[str, Bar], RawData]: The latest minute bar in raw or wrapped format
        """
        raw_latest_bars = self._get_marketdata(
            path="/stocks/bars/latest",
            params=request_params.to_request_fields(),
        )

        if self._use_raw_data:
            return raw_latest_bars

        return parse_obj_as_symbol_dict(Bar, raw_latest_bars)

    def get_stock_snapshot(
        self, request_params: StockSnapshotRequest
    ) -> Union[Dict[str, Snapshot], RawData]:
        """Returns snapshots of queried symbols. Snapshots contain latest trade, latest quote, latest minute bar,
        latest daily bar and previous daily bar data for the queried symbols.

        Args:
            request_params (StockSnapshotRequest): The request object for retrieving snapshot data.

        Returns:
            Union[SnapshotSet, RawData]: The snapshot data either in raw or wrapped form
        """
        raw_snapshots = self._get_marketdata(
            path="/stocks/snapshots",
            params=request_params.to_request_fields(),
            no_sub_key=True,
        )

        if self._use_raw_data:
            return raw_snapshots

        return parse_obj_as_symbol_dict(Snapshot, raw_snapshots)
````

## File: alpaca/data/historical/utils.py
````python
from collections import defaultdict
from typing import Dict, Type

from alpaca.common import HTTPResult, RawData

"""
These functions were created and put in this file to handle all of the edge cases
for parsing data that exist in the market data API.

v2/stocks and v1beta2/crypto
"""


def parse_obj_as_symbol_dict(model: Type, raw_data: RawData) -> Dict[str, Type]:
    """
    Parses raw_data into a dictionary where the keys are the string valued symbols and the values are the
    parsed data into the model.

    Args:
        model (Type): The model we want to parse the data into
        raw_data (RawData): The raw data from the API

    Returns:
        Dict[str, Type]: The symbol keyed dictionary of parsed data
    """
    if raw_data is None:
        return {}
    return {
        k: model(symbol=k, raw_data=v) for k, v in raw_data.items() if v is not None
    }
````

## File: alpaca/data/live/__init__.py
````python
from alpaca.data.live.crypto import CryptoDataStream
from alpaca.data.live.news import NewsDataStream
from alpaca.data.live.option import OptionDataStream
from alpaca.data.live.stock import StockDataStream

__all__ = [
    "CryptoDataStream",
    "NewsDataStream",
    "OptionDataStream",
    "StockDataStream",
]
````

## File: alpaca/data/live/crypto.py
````python
from typing import Awaitable, Callable, Dict, Optional, Union

from alpaca.common.enums import BaseURL
from alpaca.data.enums import CryptoFeed
from alpaca.data.live.websocket import DataStream
from alpaca.data.models.bars import Bar
from alpaca.data.models.orderbooks import Orderbook
from alpaca.data.models.quotes import Quote
from alpaca.data.models.trades import Trade


class CryptoDataStream(DataStream):
    """
    A WebSocket client for streaming live crypto data.
    """

    def __init__(
        self,
        api_key: str,
        secret_key: str,
        raw_data: bool = False,
        feed: CryptoFeed = CryptoFeed.US,
        url_override: Optional[str] = None,
        websocket_params: Optional[Dict] = None,
    ) -> None:
        """
        Instantiates a WebSocket client for accessing live cryptocurrency data.

        Args:
            api_key (str): Alpaca API key.
            secret_key (str): Alpaca API secret key.
            raw_data (bool, optional): Whether to return wrapped data or raw API data. Defaults to False.
            feed (CryptoFeed, optional): Which crypto feed to use. Defaults to US.
            websocket_params (Optional[Dict], optional): Any parameters for configuring websocket connection. Defaults to None.
            url_override (Optional[str]): If specified allows you to override the base url the client
              points to for proxy/testing. Defaults to None.
        """
        super().__init__(
            endpoint=(
                url_override
                if url_override is not None
                else BaseURL.MARKET_DATA_STREAM.value + "/v1beta3/crypto/" + feed
            ),
            api_key=api_key,
            secret_key=secret_key,
            raw_data=raw_data,
            websocket_params=websocket_params,
        )

    def subscribe_trades(
        self, handler: Callable[[Union[Trade, Dict]], Awaitable[None]], *symbols: str
    ) -> None:
        """Subscribe to trades.

        Args:
            handler (Callable[[Union[Trade, Dict]], Awaitable[None]): The coroutine callback
                function to handle the incoming data.
            *symbols: List of ticker symbols to subscribe to. "*" for everything.
        """
        self._subscribe(handler, symbols, self._handlers["trades"])

    def subscribe_quotes(
        self, handler: Callable[[Union[Quote, Dict]], Awaitable[None]], *symbols: str
    ) -> None:
        """Subscribe to quotes

        Args:
            handler (Callable[[Union[Quote, Dict]], Awaitable[None]]): The coroutine callback
                function to handle the incoming data.
            *symbols: List of ticker symbols to subscribe to. "*" for everything.
        """
        self._subscribe(handler, symbols, self._handlers["quotes"])

    def subscribe_bars(
        self, handler: Callable[[Union[Bar, Dict]], Awaitable[None]], *symbols: str
    ) -> None:
        """Subscribe to minute bars

        Args:
            handler (Callable[[Union[Quote, Dict]], Awaitable[None]]): The coroutine callback
                function to handle the incoming data.
            *symbols: List of ticker symbols to subscribe to. "*" for everything.
        """
        self._subscribe(handler, symbols, self._handlers["bars"])

    def subscribe_updated_bars(
        self, handler: Callable[[Union[Bar, Dict]], Awaitable[None]], *symbols: str
    ) -> None:
        """Subscribe to updated minute bars

        Args:
            handler (Callable[[Union[Bar, Dict]], Awaitable[None]]): The coroutine callback
                function to handle the incoming data.
            *symbols: List of ticker symbols to subscribe to. "*" for everything.
        """
        self._subscribe(handler, symbols, self._handlers["updatedBars"])

    def subscribe_daily_bars(
        self, handler: Callable[[Union[Bar, Dict]], Awaitable[None]], *symbols: str
    ) -> None:
        """Subscribe to daily bars

        Args:
            handler (Callable[[Union[Bar, Dict]], Awaitable[None]]): The coroutine callback
                function to handle the incoming data.
            *symbols: List of ticker symbols to subscribe to. "*" for everything.
        """
        self._subscribe(handler, symbols, self._handlers["dailyBars"])

    def subscribe_orderbooks(
        self, handler: Callable[[Union[Orderbook, Dict]], Awaitable[None]], *symbols
    ) -> None:
        """Subscribe to orderbooks

        Args:
            handler (Callable[[Union[Bar, Dict]], Awaitable[None]]): The coroutine callback
                function to handle the incoming data.
            *symbols: List of ticker symbols to subscribe to. "*" for everything.
        """
        self._subscribe(handler, symbols, self._handlers["orderbooks"])

    def unsubscribe_trades(self, *symbols: str) -> None:
        """Unsubscribe from trades

        Args:
            *symbols (str): List of ticker symbols to unsubscribe from. "*" for everything.
        """
        self._unsubscribe("trades", symbols)

    def unsubscribe_quotes(self, *symbols: str) -> None:
        """Unsubscribe from quotes

        Args:
            *symbols (str): List of ticker symbols to unsubscribe from. "*" for everything.
        """
        self._unsubscribe("quotes", symbols)

    def unsubscribe_bars(self, *symbols: str) -> None:
        """Unsubscribe from minute bars

        Args:
            *symbols (str): List of ticker symbols to unsubscribe from. "*" for everything.
        """
        self._unsubscribe("bars", symbols)

    def unsubscribe_updated_bars(self, *symbols: str) -> None:
        """Unsubscribe from updated bars

        Args:
            *symbols (str): List of ticker symbols to unsubscribe from. "*" for everything.
        """
        self._unsubscribe("updatedBars", symbols)

    def unsubscribe_daily_bars(self, *symbols: str) -> None:
        """Unsubscribe from daily bars

        Args:
            *symbols (str): List of ticker symbols to unsubscribe from. "*" for everything.
        """
        self._unsubscribe("dailyBars", symbols)

    def unsubscribe_orderbooks(self, *symbols: str) -> None:
        """Unsubscribe from orderbooks

        Args:
            *symbols (str): List of ticker symbols to unsubscribe from. "*" for everything.
        """
        self._unsubscribe("orderbooks", symbols)
````

## File: alpaca/data/live/news.py
````python
from typing import Awaitable, Callable, Dict, Optional, Union

from alpaca.common.enums import BaseURL
from alpaca.data.live.websocket import DataStream
from alpaca.data.models.news import News


class NewsDataStream(DataStream):
    """
    A WebSocket client for streaming news.
    """

    def __init__(
        self,
        api_key: str,
        secret_key: str,
        raw_data: bool = False,
        websocket_params: Optional[Dict] = None,
        url_override: Optional[str] = None,
    ) -> None:
        """
        Instantiates a WebSocket client for accessing live news.
        Args:
            api_key (str): Alpaca API key.
            secret_key (str): Alpaca API secret key.
            raw_data (bool): Whether to return wrapped data or raw API data. Defaults to False.
            websocket_params (Optional[Dict], optional): Any parameters for configuring websocket
                connection. Defaults to None.
            url_override (Optional[str]): If specified allows you to override the base url the client
                points to for proxy/testing. Defaults to None.
        """
        super().__init__(
            endpoint=(
                url_override
                if url_override is not None
                else BaseURL.MARKET_DATA_STREAM.value + "/v1beta1/news"
            ),
            api_key=api_key,
            secret_key=secret_key,
            raw_data=raw_data,
            websocket_params=websocket_params,
        )

    def subscribe_news(
        self, handler: Callable[[Union[News, Dict]], Awaitable[None]], *symbols: str
    ) -> None:
        """Subscribe to news

        Args:
            handler (Callable[[Union[News, Dict]], Awaitable[None]]): The coroutine callback
                function to handle the incoming data.
            *symbols: List of ticker symbols to subscribe to. "*" for everything.
        """
        self._subscribe(handler, symbols, self._handlers["news"])

    def unsubscribe_news(self, *symbols: str) -> None:
        """Unsubscribe from news

        Args:
            *symbols (str): List of ticker symbols to unsubscribe from. "*" for everything.
        """
        self._unsubscribe("news", symbols)
````

## File: alpaca/data/live/option.py
````python
from typing import Awaitable, Callable, Dict, Optional, Union

from alpaca.common.enums import BaseURL
from alpaca.data.enums import OptionsFeed
from alpaca.data.live.websocket import DataStream
from alpaca.data.models.quotes import Quote
from alpaca.data.models.trades import Trade


class OptionDataStream(DataStream):
    """
    A WebSocket client for streaming live option data.
    """

    def __init__(
        self,
        api_key: str,
        secret_key: str,
        raw_data: bool = False,
        feed: OptionsFeed = OptionsFeed.INDICATIVE,
        websocket_params: Optional[Dict] = None,
        url_override: Optional[str] = None,
    ) -> None:
        """
        Instantiates a WebSocket client for accessing live option data.

        Args:
            api_key (str): Alpaca API key.
            secret_key (str): Alpaca API secret key.
            raw_data (bool): Whether to return wrapped data or raw API data. Defaults to False.
            feed (OptionsFeed): The source feed of the data. `opra` or `indicative`.
                Defaults to `indicative`. `opra` requires a subscription.
            websocket_params (Optional[Dict], optional): Any parameters for configuring websocket
                connection. Defaults to None.
            url_override (Optional[str]): If specified allows you to override the base url the client
                points to for proxy/testing. Defaults to None.
        """
        super().__init__(
            endpoint=(
                url_override
                if url_override is not None
                else BaseURL.MARKET_DATA_STREAM.value + "/v1beta1/" + feed.value
            ),
            api_key=api_key,
            secret_key=secret_key,
            raw_data=raw_data,
            websocket_params=websocket_params,
        )

    def subscribe_trades(
        self, handler: Callable[[Union[Trade, Dict]], Awaitable[None]], *symbols: str
    ) -> None:
        """Subscribe to trades.

        Args:
            handler (Callable[[Union[Trade, Dict]], Awaitable[None]]): The coroutine callback
                function to handle the incoming data.
            *symbols: List of ticker symbols to subscribe to. "*" for everything.
        """
        self._subscribe(handler, symbols, self._handlers["trades"])

    def subscribe_quotes(
        self, handler: Callable[[Union[Quote, Dict]], Awaitable[None]], *symbols: str
    ) -> None:
        """Subscribe to quotes

        Args:
            handler (Callable[[Union[Quote, Dict]], Awaitable[None]]): The coroutine callback
                function to handle the incoming data.
            *symbols: List of ticker symbols to subscribe to. "*" for everything.
        """
        self._subscribe(handler, symbols, self._handlers["quotes"])

    def unsubscribe_trades(self, *symbols: str) -> None:
        """Unsubscribe from trades

        Args:
            *symbols (str): List of ticker symbols to unsubscribe from. "*" for everything.
        """
        self._unsubscribe("trades", symbols)

    def unsubscribe_quotes(self, *symbols: str) -> None:
        """Unsubscribe from quotes

        Args:
            *symbols (str): List of ticker symbols to unsubscribe from. "*" for everything.
        """
        self._unsubscribe("quotes", symbols)
````

## File: alpaca/data/live/stock.py
````python
import asyncio
from typing import Awaitable, Callable, Dict, Optional, Union

from alpaca.common.enums import BaseURL
from alpaca.data.enums import DataFeed
from alpaca.data.live.websocket import DataStream
from alpaca.data.models.bars import Bar
from alpaca.data.models.quotes import Quote
from alpaca.data.models.trades import Trade, TradeCancel, TradeCorrection, TradingStatus


class StockDataStream(DataStream):
    """
    A WebSocket client for streaming live stock data.
    """

    def __init__(
        self,
        api_key: str,
        secret_key: str,
        raw_data: bool = False,
        feed: DataFeed = DataFeed.IEX,
        websocket_params: Optional[Dict] = None,
        url_override: Optional[str] = None,
    ) -> None:
        """
        Instantiates a WebSocket client for accessing live stock data.

        Args:
            api_key (str): Alpaca API key.
            secret_key (str): Alpaca API secret key.
            raw_data (bool, optional): Whether to return wrapped data or raw API data. Defaults to False.
            feed (DataFeed, optional): Which market data feed to use; IEX or SIP.
                Defaults to IEX. SIP requires a subscription.
            websocket_params (Optional[Dict], optional): Any parameters for configuring websocket connection. Defaults to None.
            url_override (Optional[str]): If specified allows you to override the base url the client
                points to for proxy/testing. Defaults to None.

        Raises:
            ValueError: Only IEX or SIP market data feeds are supported
        """
        if feed not in (DataFeed.IEX, DataFeed.SIP):
            raise ValueError("only IEX and SIP feeds ar supported")

        super().__init__(
            endpoint=(
                url_override
                if url_override is not None
                else BaseURL.MARKET_DATA_STREAM.value + "/v2/" + feed.value
            ),
            api_key=api_key,
            secret_key=secret_key,
            raw_data=raw_data,
            websocket_params=websocket_params,
        )

    def subscribe_trades(
        self, handler: Callable[[Union[Trade, Dict]], Awaitable[None]], *symbols: str
    ) -> None:
        """Subscribe to trades.

        Args:
            handler (Callable[[Union[Trade, Dict]], Awaitable[None]]): The coroutine callback
                function to handle the incoming data.
            *symbols: List of ticker symbols to subscribe to. "*" for everything.
        """
        self._subscribe(handler, symbols, self._handlers["trades"])

    def subscribe_quotes(
        self, handler: Callable[[Union[Quote, Dict]], Awaitable[None]], *symbols: str
    ) -> None:
        """Subscribe to quotes

        Args:
            handler (Callable[[Union[Trade, Dict]], Awaitable[None]]): The coroutine callback
                function to handle the incoming data.
            *symbols: List of ticker symbols to subscribe to. "*" for everything.
        """
        self._subscribe(handler, symbols, self._handlers["quotes"])

    def subscribe_bars(
        self, handler: Callable[[Union[Bar, Dict]], Awaitable[None]], *symbols: str
    ) -> None:
        """Subscribe to minute bars

        Args:
            handler (Callable[[Union[Trade, Dict]], Awaitable[None]]): The coroutine callback
                function to handle the incoming data.
            *symbols: List of ticker symbols to subscribe to. "*" for everything.
        """
        self._subscribe(handler, symbols, self._handlers["bars"])

    def subscribe_updated_bars(
        self, handler: Callable[[Union[Bar, Dict]], Awaitable[None]], *symbols: str
    ) -> None:
        """Subscribe to updated minute bars

        Args:
            handler (Callable[[Union[Bar, Dict]], Awaitable[None]]): The coroutine callback
                function to handle the incoming data.
            *symbols: List of ticker symbols to subscribe to. "*" for everything.
        """
        self._subscribe(handler, symbols, self._handlers["updatedBars"])

    def subscribe_daily_bars(
        self, handler: Callable[[Union[Bar, Dict]], Awaitable[None]], *symbols: str
    ) -> None:
        """Subscribe to daily bars

        Args:
            handler (Callable[[Union[Bar, Dict]], Awaitable[None]]): The coroutine callback
                function to handle the incoming data.
            *symbols: List of ticker symbols to subscribe to. "*" for everything.
        """
        self._subscribe(handler, symbols, self._handlers["dailyBars"])

    def subscribe_trading_statuses(
        self, handler: Callable[[Union[TradingStatus, Dict]], Awaitable[None]], *symbols
    ) -> None:
        """Subscribe to trading statuses (halts, resumes)

        Args:
            handler (Callable[[Union[TradingStatus, Dict]], Awaitable[None]]): The coroutine callback
                function to handle the incoming data.
            *symbols: List of ticker symbols to subscribe to. "*" for everything.
        """
        self._subscribe(handler, symbols, self._handlers["statuses"])

    def register_trade_corrections(
        self, handler: Callable[[Union[TradeCorrection, Dict]], Awaitable[None]]
    ) -> None:
        """Register a trade correction handler. You can only subscribe to trade corrections by
        subscribing to the underlying trades.

        Args:
            handler (Callable[[Union[TradeCorrection, Dict]]): The coroutine callback
                function to handle the incoming data.
        """
        self._handlers["corrections"] = {"*": handler}

    def register_trade_cancels(
        self, handler: Callable[[Union[TradeCancel, Dict]], Awaitable[None]]
    ) -> None:
        """Register a trade cancel handler. You can only subscribe to trade cancels by
        subscribing to the underlying trades.

        Args:
            handler (Callable[[Union[TradeCancel, Dict]], Awaitable[None]]): The coroutine callback
                function to handle the incoming data.
        """
        self._handlers["cancelErrors"] = {"*": handler}

    def unsubscribe_trades(self, *symbols: str) -> None:
        """Unsubscribe from trades

        Args:
            *symbols (str): List of ticker symbols to unsubscribe from. "*" for everything.
        """
        self._unsubscribe("trades", symbols)

    def unsubscribe_quotes(self, *symbols: str) -> None:
        """Unsubscribe from quotes

        Args:
            *symbols (str): List of ticker symbols to unsubscribe from. "*" for everything.
        """
        self._unsubscribe("quotes", symbols)

    def unsubscribe_bars(self, *symbols: str) -> None:
        """Unsubscribe from minute bars

        Args:
            *symbols (str): List of ticker symbols to unsubscribe from. "*" for everything.
        """
        self._unsubscribe("bars", symbols)

    def unsubscribe_updated_bars(self, *symbols: str) -> None:
        """Unsubscribe from updated bars

        Args:
            *symbols (str): List of ticker symbols to unsubscribe from. "*" for everything.
        """
        self._unsubscribe("updatedBars", symbols)

    def unsubscribe_daily_bars(self, *symbols: str) -> None:
        """Unsubscribe from daily bars

        Args:
            *symbols (str): List of ticker symbols to unsubscribe from. "*" for everything.
        """
        self._unsubscribe("dailyBars", symbols)

    def unsubscribe_trading_statuses(self, *symbols: str) -> None:
        """Unsubscribe from trading statuses

        Args:
            *symbols (str): List of ticker symbols to unsubscribe from. "*" for everything.
        """
        self._unsubscribe("statuses", symbols)
````

## File: alpaca/data/live/websocket.py
````python
import asyncio
import logging
import queue
from collections import defaultdict
from typing import Callable, Dict, List, Optional, Tuple, Union

import msgpack
import websockets
from pydantic import BaseModel
from websockets.legacy import client as websockets_legacy

from alpaca import __version__
from alpaca.common.types import RawData
from alpaca.data.models import (
    Bar,
    News,
    Orderbook,
    Quote,
    Trade,
    TradeCancel,
    TradeCorrection,
    TradingStatus,
)

log = logging.getLogger(__name__)


class DataStream:
    """
    A base class for extracting out common functionality for data websockets
    """

    def __init__(
        self,
        endpoint: str,
        api_key: str,
        secret_key: str,
        raw_data: bool = False,
        websocket_params: Optional[Dict] = None,
    ) -> None:
        """Creates a new DataStream instance.

        Args:
            endpoint (str): The websocket endpoint to connect to
            api_key (str): Alpaca API key.
            secret_key (str): Alpaca API secret key.
            raw_data (bool, optional): Whether to return raw API data or parsed data. Defaults to False.
            websocket_params (Optional[Dict], optional): Any websocket connection configuration parameters. Defaults to None.
        """
        self._endpoint = endpoint
        self._api_key = api_key
        self._secret_key = secret_key
        self._ws = None
        self._running = False
        self._loop = None
        self._raw_data = raw_data
        self._stop_stream_queue = queue.Queue()
        self._handlers = {
            "trades": {},
            "quotes": {},
            "orderbooks": {},
            "bars": {},
            "updatedBars": {},
            "dailyBars": {},
            "statuses": {},
            "lulds": {},
            "news": {},
            "corrections": {},
            "cancelErrors": {},
        }
        self._name = "data"
        self._should_run = True
        self._max_frame_size = 32768

        self._websocket_params = {
            "ping_interval": 10,
            "ping_timeout": 180,
            "max_queue": 1024,
        }

        if websocket_params:
            self._websocket_params = websocket_params

    async def _connect(self) -> None:
        """Attempts to connect to the websocket endpoint.
        If the connection attempt fails a value error is thrown.

        Raises:
            ValueError: Raised if there is an unsuccessful connection
        """

        extra_headers = {
            "Content-Type": "application/msgpack",
            "User-Agent": "APCA-PY/" + __version__,
        }

        log.info(f"connecting to {self._endpoint}")
        self._ws = await websockets_legacy.connect(
            self._endpoint,
            extra_headers=extra_headers,
            **self._websocket_params,
        )
        r = await self._ws.recv()
        msg = msgpack.unpackb(r)
        if msg[0]["T"] != "success" or msg[0]["msg"] != "connected":
            raise ValueError("connected message not received")

    async def _auth(self) -> None:
        """Authenticates with API keys after a successful connection is established.

        Raises:
            ValueError: Raised if authentication is unsuccessful
        """
        await self._ws.send(
            msgpack.packb(
                {
                    "action": "auth",
                    "key": self._api_key,
                    "secret": self._secret_key,
                }
            )
        )
        r = await self._ws.recv()
        msg = msgpack.unpackb(r)
        if msg[0]["T"] == "error":
            raise ValueError(msg[0].get("msg", "auth failed"))
        if msg[0]["T"] != "success" or msg[0]["msg"] != "authenticated":
            raise ValueError("failed to authenticate")

    async def _start_ws(self) -> None:
        """Starts up the websocket connection. Attempts to connect to wss endpoint
        and then authenticates with API keys.
        """
        await self._connect()
        await self._auth()
        log.info(f"connected to {self._endpoint}")

    async def close(self) -> None:
        """Closes the websocket connection."""
        if self._ws:
            await self._ws.close()
            self._ws = None
            self._running = False

    async def stop_ws(self) -> None:
        """Signals websocket connection should close by adding a closing message to the stop_stream_queue"""
        self._should_run = False
        if self._stop_stream_queue.empty():
            self._stop_stream_queue.put_nowait({"should_stop": True})
        await asyncio.sleep(0)

    async def _consume(self) -> None:
        """Distributes data from websocket connection to appropriate callbacks"""
        while True:
            if not self._stop_stream_queue.empty():
                self._stop_stream_queue.get(timeout=1)
                await self.close()
                break
            else:
                try:
                    r = await asyncio.wait_for(self._ws.recv(), 5)
                    msgs = msgpack.unpackb(r)
                    for msg in msgs:
                        await self._dispatch(msg)
                except asyncio.TimeoutError:
                    # ws.recv is hanging when no data is received. by using
                    # wait_for we break when no data is received, allowing us
                    # to break the loop when needed
                    pass

    def _cast(self, msg: Dict) -> Union[BaseModel, RawData]:
        """Parses data from websocket message if raw_data is False, otherwise
        returns the raw websocket message.

        Args:
            msg (Dict): The message containing market data

        Returns:
            Union[BaseModel, RawData]: The raw or parsed message
        """
        if self._raw_data:
            return msg
        msg_type = msg.get("T")
        if "t" in msg:
            msg["t"] = msg["t"].to_datetime()
        if msg_type == "n":
            msg["created_at"] = msg["created_at"].to_datetime()
            msg["updated_at"] = msg["updated_at"].to_datetime()
            return News(msg)
        if "S" not in msg:
            return msg
        if msg_type == "t":
            return Trade(msg["S"], msg)
        if msg_type == "q":
            return Quote(msg["S"], msg)
        if msg_type == "o":
            return Orderbook(msg["S"], msg)
        if msg_type in ("b", "u", "d"):
            return Bar(msg["S"], msg)
        if msg_type == "s":
            return TradingStatus(msg["S"], msg)
        if msg_type == "c":
            return TradeCorrection(msg["S"], msg)
        if msg_type == "x":
            return TradeCancel(msg["S"], msg)
        return msg

    async def _dispatch(self, msg: Dict) -> None:
        """Distributes the message from websocket connection to the appropriate handler.

        Args:
            msg (Dict): The message from the websocket connection
        """
        msg_type = msg.get("T")
        if msg_type == "subscription":
            sub = [f"{k}: {msg.get(k, [])}" for k in self._handlers if msg.get(k)]
            log.info(f'subscribed to {", ".join(sub)}')
            return

        if msg_type == "error":
            log.error(f'error: {msg.get("msg")} ({msg.get("code")})')
            return

        if msg_type == "n":
            symbols = msg.get("symbols", "*")
            star_handler_called = False
            handlers_to_call = []
            news = self._cast(msg)
            for symbol in set(symbols):
                if symbol in self._handlers["news"]:
                    handler = self._handlers["news"].get(symbol)
                elif not star_handler_called:
                    handler = self._handlers["news"].get("*")
                    star_handler_called = True
                else:
                    handler = None
                if handler:
                    handlers_to_call.append(handler(news))
            if handlers_to_call:
                await asyncio.gather(*handlers_to_call)
            return

        channel_types = {
            "t": "trades",
            "q": "quotes",
            "o": "orderbooks",
            "b": "bars",
            "u": "updatedBars",
            "d": "dailyBars",
            "s": "statuses",
            "l": "lulds",
            "n": "news",
            "c": "corrections",
            "x": "cancelErrors",
        }
        channel = channel_types.get(msg_type)
        if not channel:
            return
        symbol = msg.get("S")
        handler = self._handlers[channel].get(symbol, self._handlers[channel].get("*"))
        if handler:
            await handler(self._cast(msg))

    def _subscribe(
        self, handler: Callable, symbols: Tuple[str], handlers: Dict
    ) -> None:
        """Subscribes a coroutine callback function to receive data for a tuple of symbols

        Args:
            handler (Callable): The coroutine callback function to receive data
            symbols (Tuple[str]): The tuple containing the symbols to be subscribed to
            handlers (Dict): The dictionary of coroutine callback functions keyed by symbol
        """
        self._ensure_coroutine(handler)
        for symbol in symbols:
            handlers[symbol] = handler
        if self._running:
            asyncio.run_coroutine_threadsafe(
                self._send_subscribe_msg(), self._loop
            ).result()

    async def _send_subscribe_msg(self) -> None:
        msg = defaultdict(list)
        for k, v in self._handlers.items():
            if k not in ("cancelErrors", "corrections") and v:
                for s in v.keys():
                    msg[k].append(s)
        msg["action"] = "subscribe"
        bs = msgpack.packb(msg)
        frames = (
            bs[i : i + self._max_frame_size]
            for i in range(0, len(bs), self._max_frame_size)
        )
        await self._ws.send(frames)

    def _unsubscribe(self, channel: str, symbols: List[str]) -> None:
        if self._running:
            asyncio.run_coroutine_threadsafe(
                self._send_unsubscribe_msg(channel, symbols), self._loop
            ).result()
        for symbol in symbols:
            del self._handlers[channel][symbol]

    async def _send_unsubscribe_msg(self, channel: str, symbols: List[str]) -> None:
        if symbols:
            await self._ws.send(
                msgpack.packb(
                    {
                        "action": "unsubscribe",
                        channel: symbols,
                    }
                )
            )

    async def _run_forever(self) -> None:
        """Starts event loop for receiving data from websocket connection and handles
        distributing messages
        """
        self._loop = asyncio.get_running_loop()
        # do not start the websocket connection until we subscribe to something
        while not any(
            v
            for k, v in self._handlers.items()
            if k not in ("cancelErrors", "corrections")
        ):
            if not self._stop_stream_queue.empty():
                # the ws was signaled to stop before starting the loop so
                # we break
                self._stop_stream_queue.get(timeout=1)
                return
            await asyncio.sleep(0)
        log.info(f"started {self._name} stream")
        self._should_run = True
        self._running = False
        while True:
            try:
                if not self._should_run:
                    # when signaling to stop, this is how we break run_forever
                    log.info("{} stream stopped".format(self._name))
                    return
                if not self._running:
                    log.info("starting {} websocket connection".format(self._name))
                    await self._start_ws()
                    await self._send_subscribe_msg()
                    self._running = True
                await self._consume()
            except websockets.WebSocketException as wse:
                await self.close()
                self._running = False
                log.warning("data websocket error, restarting connection: " + str(wse))
            except ValueError as ve:
                if "insufficient subscription" in str(ve):
                    await self.close()
                    self._running = False
                    log.exception(f"error during websocket communication: {str(ve)}")
                    return
                log.exception(f"error during websocket communication: {str(ve)}")
            except Exception as e:
                log.exception(f"error during websocket communication: {str(e)}")
            finally:
                await asyncio.sleep(0)

    def run(self) -> None:
        """Starts up the websocket connection's event loop"""
        try:
            asyncio.run(self._run_forever())
        except KeyboardInterrupt:
            print("keyboard interrupt, bye")
            pass
        finally:
            self.stop()

    def stop(self) -> None:
        """Stops the websocket connection."""
        if self._loop.is_running():
            asyncio.run_coroutine_threadsafe(self.stop_ws(), self._loop).result(
                timeout=5
            )

    def _ensure_coroutine(self, handler: Callable) -> None:
        """Checks if a method is an asyncio coroutine method

        Args:
            handler (Callable): A method to be checked for coroutineness

        Raises:
            ValueError: Raised if the input method is not a coroutine
        """
        if not asyncio.iscoroutinefunction(handler):
            raise ValueError("handler must be a coroutine function")
````

## File: alpaca/data/models/__init__.py
````python
from alpaca.data.models.bars import *
from alpaca.data.models.orderbooks import *
from alpaca.data.models.news import *
from alpaca.data.models.quotes import *
from alpaca.data.models.trades import *
from alpaca.data.models.snapshots import *
from alpaca.data.models.orderbooks import *
````

## File: alpaca/data/models/bars.py
````python
from datetime import datetime
from typing import Dict, List, Optional

from alpaca.common.models import ValidateBaseModel as BaseModel
from alpaca.common.types import RawData
from alpaca.data.mappings import BAR_MAPPING
from alpaca.data.models.base import BaseDataSet, TimeSeriesMixin


class Bar(BaseModel):
    """Represents one bar/candlestick of aggregated trade data over a specified interval.

    Attributes:
        symbol (str): The ticker identifier for the security whose data forms the bar.
        timestamp (datetime): The opening timestamp of the bar.
        open (float): The opening price of the interval.
        high (float): The high price during the interval.
        low (float): The low price during the interval.
        close (float): The closing price of the interval.
        volume (float): The volume traded over the interval.
        trade_count (Optional[float]): The number of trades that occurred.
        vwap (Optional[float]): The volume weighted average price.
        exchange (Optional[float]): The exchange the bar was formed on.
    """

    symbol: str
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float
    trade_count: Optional[float]
    vwap: Optional[float]

    def __init__(self, symbol: str, raw_data: RawData) -> None:
        """Instantiates a bar

        Args:
            raw_data (RawData): Raw unparsed bar data from API, contains ohlc and other fields.
        """
        mapped_bar = {}

        if raw_data is not None:
            mapped_bar = {
                BAR_MAPPING[key]: val
                for key, val in raw_data.items()
                if key in BAR_MAPPING
            }

        super().__init__(symbol=symbol, **mapped_bar)


class BarSet(BaseDataSet, TimeSeriesMixin):
    """A collection of Bars.

    Attributes:
        data (Dict[str, List[Bar]]): The collection of Bars keyed by symbol.
    """

    data: Dict[str, List[Bar]] = {}

    def __init__(
        self,
        raw_data: RawData,
    ) -> None:
        """A collection of Bars.

        Args:
            raw_data (RawData): The collection of raw bar data from API keyed by Symbol.
        """

        parsed_bars = {}

        raw_bars = raw_data

        if raw_bars is not None:
            for symbol, bars in raw_bars.items():
                parsed_bars[symbol] = [
                    Bar(symbol, bar) for bar in bars if bar is not None
                ]

        super().__init__(data=parsed_bars)
````

## File: alpaca/data/models/base.py
````python
import itertools
from typing import Any, Dict, List

import numpy as np
import pandas as pd
from pandas import DataFrame

from alpaca.common.models import ValidateBaseModel as BaseModel


class TimeSeriesMixin:
    @property
    def df(self) -> DataFrame:
        """Returns a pandas dataframe containing the bar data.
        Requires mapping to be defined in child class.

        Returns:
            DataFrame: data in a pandas dataframe
        """
        # combine all lists of data into one list
        data_list = list(itertools.chain.from_iterable(self.dict().values()))

        df = pd.DataFrame(data_list)
        columns = df.columns

        # set multi-level index
        if "news" in self.dict():
            # level=0 - id
            df = df.set_index(["id"])
        elif "corporate_action_type" in columns:
            # level=0 - corporate_action_type
            df = df.set_index(["corporate_action_type"])
        elif set(["symbol", "timestamp"]).issubset(columns):
            # level=0 - symbol
            # level=1 - timestamp
            df = df.set_index(["symbol", "timestamp"])

        # drop null columns
        df.dropna(axis=1, how="all", inplace=True)

        return df


class BaseDataSet(BaseModel):
    """
    Base class to process data models for trades, bars quotes, and news.
    """

    data: Dict[str, List[BaseModel]] = {}

    def __getitem__(self, symbol: str) -> Any:
        """Gives dictionary-like access to multi-symbol data

        Args:
            symbol (str): The ticker identifier for the desired data

        Raises:
            KeyError: Symbol does not exist for data

        Returns:
            List[Bar]: The data for the given symbol
        """
        if symbol not in self.data:
            raise KeyError(f"No key {symbol} was found.")

        return self.data[symbol]

    def dict(self, **kwargs) -> dict:
        """
        Gives dictionary representation of data.

        Returns:
            dict: The data in dictionary form.
        """
        # converts each data (Bar, Quote, etc) in the symbol specific lists to its dictionary format
        return {
            symbol: list(map(lambda d: d.model_dump(), data_list))
            for symbol, data_list in self.data.items()
        }
````

## File: alpaca/data/models/corporate_actions.py
````python
from datetime import date
from typing import Dict, List, Optional, Union

from alpaca.common.models import ValidateBaseModel as BaseModel
from alpaca.common.types import RawData
from alpaca.data.models.base import BaseDataSet, TimeSeriesMixin


class ForwardSplit(BaseModel):
    corporate_action_type: str
    symbol: str
    new_rate: float
    old_rate: float
    process_date: date
    ex_date: date
    record_date: Optional[date] = None
    payable_date: Optional[date] = None
    due_bill_redemption_date: Optional[date] = None


class ReverseSplit(BaseModel):
    corporate_action_type: str
    symbol: str
    new_rate: float
    old_rate: float
    process_date: date
    ex_date: date
    record_date: Optional[date] = None
    payable_date: Optional[date] = None


class UnitSplit(BaseModel):
    corporate_action_type: str
    old_symbol: str
    old_rate: float
    new_symbol: str
    new_rate: float
    alternate_symbol: str
    alternate_rate: float
    process_date: date
    effective_date: date
    payable_date: Optional[date] = None


class StockDividend(BaseModel):
    corporate_action_type: str
    symbol: str
    rate: float
    process_date: date
    ex_date: date
    record_date: Optional[date] = None
    payable_date: Optional[date] = None


class CashDividend(BaseModel):
    corporate_action_type: str
    symbol: str
    rate: float
    special: bool
    foreign: bool
    process_date: date
    ex_date: date
    record_date: Optional[date] = None
    payable_date: Optional[date] = None
    due_bill_on_date: Optional[date] = None
    due_bill_off_date: Optional[date] = None


class SpinOff(BaseModel):
    corporate_action_type: str
    source_symbol: str
    source_rate: float
    new_symbol: str
    new_rate: float
    process_date: date
    ex_date: date
    payable_date: Optional[date] = None
    record_date: Optional[date] = None
    payable_date: Optional[date] = None
    due_bill_redemption_date: Optional[date] = None


class CashMerger(BaseModel):
    corporate_action_type: str
    acquirer_symbol: Optional[str] = None
    acquiree_symbol: str
    rate: float
    process_date: date
    effective_date: date
    payable_date: Optional[date] = None


class StockMerger(BaseModel):
    corporate_action_type: str
    acquirer_symbol: str
    acquirer_rate: float
    acquiree_symbol: str
    acquiree_rate: float
    process_date: date
    effective_date: date
    payable_date: Optional[date] = None


class StockAndCashMerger(BaseModel):
    corporate_action_type: str
    acquirer_symbol: str
    acquirer_rate: float
    acquiree_symbol: str
    acquiree_rate: float
    cash_rate: float
    process_date: date
    effective_date: date
    payable_date: Optional[date] = None


class Redemption(BaseModel):
    corporate_action_type: str
    symbol: str
    rate: float
    process_date: date
    payable_date: Optional[date] = None


class NameChange(BaseModel):
    corporate_action_type: str
    old_symbol: str
    new_symbol: str
    process_date: date


class WorthlessRemoval(BaseModel):
    corporate_action_type: str
    symbol: str
    process_date: date


class RightsDistribution(BaseModel):
    corporate_action_type: str
    source_symbol: str
    new_symbol: str
    rate: float
    process_date: date
    ex_date: date
    payable_date: date = None
    record_date: Optional[date] = None
    expiration_date: Optional[date] = None


CorporateAction = Union[
    ForwardSplit,
    ReverseSplit,
    UnitSplit,
    StockDividend,
    CashDividend,
    SpinOff,
    CashMerger,
    StockMerger,
    StockAndCashMerger,
    Redemption,
    NameChange,
    WorthlessRemoval,
    RightsDistribution,
]


class CorporateActionsSet(BaseDataSet, TimeSeriesMixin):
    """
    A collection of Corporate actions.
    ref. https://docs.alpaca.markets/reference/corporateactions-1

    Attributes:
        data (Dict[str, List[CorporateAction]]): The collection of corporate actions.
    """

    data: Dict[
        str,
        List[CorporateAction],
    ] = {}

    def __init__(self, raw_data: RawData) -> None:
        """
        Instantiates a CorporateActionsSet - a collection of CorporateAction.

        Args:
            raw_data (RawData): The raw corporate_actions data received from API
        """
        parsed_corporate_actions: Dict[
            str,
            List[CorporateAction],
        ] = {}

        if raw_data is None:
            return super().__init__()

        for corporate_action_type, corporate_actions in raw_data.items():
            if corporate_action_type == "forward_splits":
                parsed_corporate_actions[corporate_action_type] = [
                    ForwardSplit(
                        corporate_action_type=corporate_action_type, **corporate_action
                    )
                    for corporate_action in corporate_actions
                ]
            elif corporate_action_type == "reverse_splits":
                parsed_corporate_actions[corporate_action_type] = [
                    ReverseSplit(
                        corporate_action_type=corporate_action_type, **corporate_action
                    )
                    for corporate_action in corporate_actions
                ]
            elif corporate_action_type == "unit_splits":
                parsed_corporate_actions[corporate_action_type] = [
                    UnitSplit(
                        corporate_action_type=corporate_action_type, **corporate_action
                    )
                    for corporate_action in corporate_actions
                ]
            elif corporate_action_type == "stock_dividends":
                parsed_corporate_actions[corporate_action_type] = [
                    StockDividend(
                        corporate_action_type=corporate_action_type, **corporate_action
                    )
                    for corporate_action in corporate_actions
                ]
            elif corporate_action_type == "cash_dividends":
                parsed_corporate_actions[corporate_action_type] = [
                    CashDividend(
                        corporate_action_type=corporate_action_type, **corporate_action
                    )
                    for corporate_action in corporate_actions
                ]
            elif corporate_action_type == "spin_offs":
                parsed_corporate_actions[corporate_action_type] = [
                    SpinOff(
                        corporate_action_type=corporate_action_type, **corporate_action
                    )
                    for corporate_action in corporate_actions
                ]
            elif corporate_action_type == "cash_mergers":
                parsed_corporate_actions[corporate_action_type] = [
                    CashMerger(
                        corporate_action_type=corporate_action_type, **corporate_action
                    )
                    for corporate_action in corporate_actions
                ]
            elif corporate_action_type == "stock_mergers":
                parsed_corporate_actions[corporate_action_type] = [
                    StockMerger(
                        corporate_action_type=corporate_action_type, **corporate_action
                    )
                    for corporate_action in corporate_actions
                ]
            elif corporate_action_type == "stock_and_cash_mergers":
                parsed_corporate_actions[corporate_action_type] = [
                    StockAndCashMerger(
                        corporate_action_type=corporate_action_type, **corporate_action
                    )
                    for corporate_action in corporate_actions
                ]
            elif corporate_action_type == "redemptions":
                parsed_corporate_actions[corporate_action_type] = [
                    Redemption(
                        corporate_action_type=corporate_action_type, **corporate_action
                    )
                    for corporate_action in corporate_actions
                ]
            elif corporate_action_type == "name_changes":
                parsed_corporate_actions[corporate_action_type] = [
                    NameChange(
                        corporate_action_type=corporate_action_type, **corporate_action
                    )
                    for corporate_action in corporate_actions
                ]
            elif corporate_action_type == "worthless_removals":
                parsed_corporate_actions[corporate_action_type] = [
                    WorthlessRemoval(
                        corporate_action_type=corporate_action_type, **corporate_action
                    )
                    for corporate_action in corporate_actions
                ]
            elif corporate_action_type == "rights_distributions":
                parsed_corporate_actions[corporate_action_type] = [
                    RightsDistribution(
                        corporate_action_type=corporate_action_type, **corporate_action
                    )
                    for corporate_action in corporate_actions
                ]

        super().__init__(data=parsed_corporate_actions)
````

## File: alpaca/data/models/news.py
````python
from datetime import datetime
from typing import List, Optional

from alpaca.common.models import ValidateBaseModel as BaseModel
from alpaca.common.types import RawData
from alpaca.data import NewsImageSize
from alpaca.data.models.base import BaseDataSet, TimeSeriesMixin


class NewsImage(BaseModel):
    """
    images (URLs) related to given article

    Attributes:
        size (NewsImageSize): Possible values for size are thumb, small and large.
        url (str): url to image from news article.
    """

    size: NewsImageSize
    url: str


class News(BaseModel):
    """
    News article object

    Attributes:
        id (str): News article ID
        headline (str): Headline or title of the article
        source (str): Source where the news originated from (e.g. Benzinga)
        url (Optional[str]): URL of article (if applicable)
        summary (str): Summary text for the article (may be first sentence of content)
        created_at (datetime): Date article was created (RFC 3339)
        updated_at (datetime): Date article was updated (RFC 3339)
        symbols (List[str]): List of related or mentioned symbols
        content (str): Content of the news article (might contain HTML)
        author (str): Original author of news article
        images (List[NewsImage]): List of images (URLs) related to given article (may be empty)
    """

    id: int
    headline: str
    source: str
    url: Optional[str]
    summary: str
    created_at: datetime
    updated_at: datetime
    symbols: List[str]
    author: str
    content: str
    images: Optional[List[NewsImage]] = None  # only in historical

    def __init__(self, raw_data: RawData) -> None:
        """Instantiates a news article

        Args:
            raw_data (RawData): Raw unparsed news data from API.
        """

        super().__init__(**raw_data)


class NewsSet(BaseDataSet, TimeSeriesMixin):
    """
    A collection of News articles.

    Attributes:
        data (Dict[str, List[News]]): The collection of News articles.
        next_page_token (Optional[str]): The token to get the next page of data.
    """

    next_page_token: Optional[str]

    def __init__(self, raw_data: RawData) -> None:
        """A collection of News articles.

        Args:
            raw_data (RawData): The collection of raw news data from API.
        """
        parsed_news = {}
        articles = []

        for article in raw_data.get("news", []):
            news = News(raw_data=article)
            articles.append(news)

        parsed_news["news"] = articles
        next_page_token = raw_data.get("next_page_token")

        super().__init__(data=parsed_news, next_page_token=next_page_token)
````

## File: alpaca/data/models/orderbooks.py
````python
from datetime import datetime
from typing import List

from pydantic import Field, TypeAdapter

from alpaca.common.models import ValidateBaseModel as BaseModel
from alpaca.common.types import RawData
from alpaca.data.mappings import ORDERBOOK_MAPPING


class OrderbookQuote(BaseModel):
    """A single bid or ask quote in the orderbook"""

    # using field aliases for easy parsing
    price: float = Field(alias="p")
    size: float = Field(alias="s")


class Orderbook(BaseModel):
    """Level 2 ask/bid pair orderbook data.

    Attributes:
        symbol (str): The ticker identifier for the security whose data forms the orderbook.
        timestamp (datetime): The time of submission of the orderbook.
        bids (List[OrderbookQuote]): The list of bid quotes for the orderbook
        asks (List[OrderbookQuote]): The list of ask quotes for the orderbook
        reset (bool): if true, the orderbook message contains the whole server side orderbook.
        This indicates to the client that they should reset their orderbook.
        Typically sent as the first message after subscription.
    """

    symbol: str
    timestamp: datetime
    bids: List[OrderbookQuote]
    asks: List[OrderbookQuote]
    reset: bool = False

    def __init__(self, symbol: str, raw_data: RawData) -> None:
        """Instantiates an Orderbook.

        Args:
            symbol (str): The security identifier for the orderbook
            raw_data (RawData): The orderbook data as received by API
        """

        mapped_book = {
            ORDERBOOK_MAPPING.get(key): val
            for key, val in raw_data.items()
            if key in ORDERBOOK_MAPPING
        }

        mapped_book["bids"] = TypeAdapter(List[OrderbookQuote]).validate_python(
            mapped_book["bids"]
        )
        mapped_book["asks"] = TypeAdapter(List[OrderbookQuote]).validate_python(
            mapped_book["asks"]
        )

        super().__init__(symbol=symbol, **mapped_book)
````

## File: alpaca/data/models/quotes.py
````python
from datetime import datetime
from typing import Dict, List, Optional, Union

from alpaca.common.models import ValidateBaseModel as BaseModel
from alpaca.common.types import RawData
from alpaca.data.enums import Exchange
from alpaca.data.mappings import QUOTE_MAPPING
from alpaca.data.models.base import BaseDataSet, TimeSeriesMixin


class Quote(BaseModel):
    """Level 1 ask/bid pair quote data. Contains information about size and origin exchange.

    Attributes:
        symbol (str): The ticker identifier for the security whose data forms the quote.
        timestamp (datetime): The time of submission of the quote.
        bid_price (float): The bidding price of the quote.
        bid_size (float): The size of the quote bid.
        bid_exchange (Optional[Union[str, Exchange]]): The exchange the quote bid originates. Defaults to None.
        ask_price (float): The asking price of the quote.
        ask_size (float): The size of the quote ask.
        ask_exchange (Optional[Union[str, Exchange]]): The exchange the quote ask originates. Defaults to None.
        conditions (Optional[Union[List[str], str]]): The quote conditions. Defaults to None.
        tape (Optional[str]): The quote tape. Defaults to None.
    """

    symbol: str
    timestamp: datetime
    bid_price: float
    bid_size: float
    bid_exchange: Optional[Union[str, Exchange]] = None
    ask_price: float
    ask_size: float
    ask_exchange: Optional[Union[str, Exchange]] = None
    conditions: Optional[Union[List[str], str]] = None
    tape: Optional[str] = None

    def __init__(self, symbol: str, raw_data: RawData) -> None:
        """Instantiates a Quote

        Args:
            symbol (str): The security identifier for the quote
            raw_data (RawData): The quote data as received by API
        """

        mapped_quote = {
            QUOTE_MAPPING.get(key): val
            for key, val in raw_data.items()
            if key in QUOTE_MAPPING
        }

        super().__init__(symbol=symbol, **mapped_quote)


class QuoteSet(BaseDataSet, TimeSeriesMixin):
    """A collection of Quotes.

    Attributes:
        data (Dict[str, List[Quote]]): The collection of Quotes keyed by symbol.
    """

    data: Dict[str, List[Quote]] = {}

    def __init__(self, raw_data: RawData) -> None:
        """Instantiates a QuoteSet.

        Args:
            raw_data (RawData): The raw quote data received from API keyed by symbol
        """
        parsed_quotes = {}

        if raw_data is not None:
            for symbol, quotes in raw_data.items():
                parsed_quotes[symbol] = [
                    Quote(symbol, quote) for quote in quotes if quote is not None
                ]

        super().__init__(data=parsed_quotes)
````

## File: alpaca/data/models/screener.py
````python
from datetime import datetime
from typing import List

from alpaca.common.models import ValidateBaseModel as BaseModel
from alpaca.data.enums import MarketType


class ActiveStock(BaseModel):
    """
    Represent one asset that was a most active on the most actives endpoint.

    Attributes:
        symbol (str): Symbol of market moving asset.
        volume (float): Cumulative volume for the current trading day.
        trade_count (float): Cumulative trade count for the current trading day.
    """

    symbol: str
    volume: float
    trade_count: float


class MostActives(BaseModel):
    """
    Represent the response model for the MostActives endpoint.
    Attributes:
        most_actives (List[ActiveStock]): list of top N most active symbols.
        last_updated (datetime):
            Time when the MostActives were last computed.
            Formatted as a RFC 3339 formatted datetime with nanosecond precision.
    """

    most_actives: List[ActiveStock]
    last_updated: datetime


class Mover(BaseModel):
    """
    Represent one asset that was a top mover on the top market movers endpoint.
    Attributes:
        symbol (str): Symbol of market moving asset.
        percent_change (float): Percentage difference change for the day.
        change (float): Difference in change for the day.
        price (float): Current price of market moving asset.
    """

    symbol: str
    percent_change: float
    change: float
    price: float


class Movers(BaseModel):
    """
    Represent the response model for the top market movers endpoint.
    Attributes:
        gainers (List[Mover]): list of top N gainers.
        losers (List[Mover]): list of top N losers.
        market_type (MarketType): Market type (stocks or crypto).
        last_updated (datetime):
            Time when the movers were last computed.
            Formatted as a RFC 3339 formatted datetime with nanosecond precision.
    """

    gainers: List[Mover]
    losers: List[Mover]
    market_type: MarketType
    last_updated: datetime
````

## File: alpaca/data/models/snapshots.py
````python
from typing import Dict, Optional

from alpaca.common.models import ValidateBaseModel as BaseModel
from alpaca.common.types import RawData
from alpaca.data.mappings import SNAPSHOT_MAPPING
from alpaca.data.models import Bar, Quote, Trade


class Snapshot(BaseModel):
    """A Snapshot contains the latest trade, latest quote, minute bar daily bar
    and previous daily bar data for a given ticker symbol.

    Attributes:
        symbol (str): The identifier for the snapshot security.
        latest_trade (Optional[Trade]): The latest transaction on the price and sales tape
        latest_quote (Optional[Quote]): Level 1 ask/bid pair quote data.
        minute_bar (Optional[Bar]): The latest minute OHLC bar data
        daily_bar (Optional[Bar]): The latest daily OHLC bar data
        previous_daily_bar (Optional[Bar]): The 2nd to latest (2 trading days ago) daily OHLC bar data
    """

    symbol: str
    latest_trade: Optional[Trade] = None
    latest_quote: Optional[Quote] = None
    minute_bar: Optional[Bar] = None
    daily_bar: Optional[Bar] = None
    previous_daily_bar: Optional[Bar] = None

    def __init__(self, symbol: str, raw_data: Dict[str, RawData]) -> None:
        """Instantiates a Snapshot.

        Args:
            symbol (str): The identifier for the snapshot security.
            raw_data (Dict[str, RawData]): The raw API snapshot data keyed by symbol
        """
        mapped_snapshot = {
            SNAPSHOT_MAPPING.get(key): val
            for key, val in raw_data.items()
            if key in SNAPSHOT_MAPPING
        }

        # Parse each data type
        if mapped_snapshot.get("latest_trade", None) is not None:
            mapped_snapshot["latest_trade"] = Trade(
                symbol, mapped_snapshot["latest_trade"]
            )
        if mapped_snapshot.get("latest_quote", None) is not None:
            mapped_snapshot["latest_quote"] = Quote(
                symbol, mapped_snapshot["latest_quote"]
            )
        if mapped_snapshot.get("minute_bar", None) is not None:
            mapped_snapshot["minute_bar"] = Bar(symbol, mapped_snapshot["minute_bar"])
        if mapped_snapshot.get("daily_bar", None) is not None:
            mapped_snapshot["daily_bar"] = Bar(symbol, mapped_snapshot["daily_bar"])
        if mapped_snapshot.get("previous_daily_bar", None) is not None:
            mapped_snapshot["previous_daily_bar"] = Bar(
                symbol, mapped_snapshot["previous_daily_bar"]
            )

        super().__init__(symbol=symbol, **mapped_snapshot)


class OptionsGreeks(BaseModel):
    """Options Greeks are a set of risk measures that are used in the options market to evaluate the risk and reward of an option.

    Attributes:
        delta (float): The rate of change of an option's price relative to a change in the price of the underlying asset.
        gamma (float): The rate of change in an option's delta relative to a change in the price of the underlying asset.
        rho (float): The rate of change in an option's price relative to a change in the risk-free rate of interest.
        theta (float): The rate of change in an option's price relative to a change in time.
        vega (float): The rate of change in an option's price relative to a change in the volatility of the underlying asset.
    """

    delta: float
    gamma: float
    rho: float
    theta: float
    vega: float

    def __init__(self, raw_data: RawData) -> None:
        """Instantiates an OptionGreeks object.

        Args:
            raw_data (RawData): The raw API option greeks data
        """
        super().__init__(**raw_data)


class OptionsSnapshot(BaseModel):
    """An options snapshot contains the latest trade, latest quote, greeks
    and implied volatility data for a given symbol.

    Attributes:
        symbol (str): The identifier for the snapshot security.
        latest_trade (Optional[Trade]): The latest transaction on the price and sales tape
        latest_quote (Optional[Quote]): Level 1 ask/bid pair quote data.
        implied_volatility (Optional[float]): The implied volatility of the option
        greeks (Optional[OptionGreeks]): The option greeks data
    """

    symbol: str
    latest_trade: Optional[Trade] = None
    latest_quote: Optional[Quote] = None
    implied_volatility: Optional[float] = None
    greeks: Optional[OptionsGreeks] = None

    def __init__(self, symbol: str, raw_data: Dict[str, RawData]) -> None:
        """Instantiates a Snapshot.

        Args:
            symbol (str): The identifier for the snapshot security.
            raw_data (Dict[str, RawData]): The raw API snapshot data keyed by symbol
        """
        mapped_snapshot = {
            SNAPSHOT_MAPPING.get(key): val
            for key, val in raw_data.items()
            if key in SNAPSHOT_MAPPING
        }

        # Parse each data type
        if mapped_snapshot.get("latest_trade", None) is not None:
            mapped_snapshot["latest_trade"] = Trade(
                symbol, mapped_snapshot["latest_trade"]
            )
        if mapped_snapshot.get("latest_quote", None) is not None:
            mapped_snapshot["latest_quote"] = Quote(
                symbol, mapped_snapshot["latest_quote"]
            )
        if mapped_snapshot.get("greeks", None) is not None:
            mapped_snapshot["greeks"] = OptionsGreeks(mapped_snapshot["greeks"])

        super().__init__(symbol=symbol, **mapped_snapshot)
````

## File: alpaca/data/models/trades.py
````python
from datetime import datetime
from typing import Dict, List, Optional, Union

from alpaca.common.models import ValidateBaseModel as BaseModel
from alpaca.common.types import RawData
from alpaca.data.enums import Exchange
from alpaca.data.mappings import (
    TRADE_CANCEL_MAPPING,
    TRADE_CORRECTION_MAPPING,
    TRADE_MAPPING,
    TRADING_STATUS_MAPPING,
)
from alpaca.data.models.base import BaseDataSet, TimeSeriesMixin


class Trade(BaseModel):
    """A transaction from the price and sales history of a security.

    Attributes:
        symbol (str): The ticker identifier for the security whose data forms the trade.
        timestamp (datetime): The time of submission of the trade.
        exchange (Optional[Exchange]): The exchange the trade occurred.
        price (float): The price that the transaction occurred at.
        size (float): The quantity traded
        id (Optional[int]): The trade ID
        conditions (Optional[Union[List[str], str]]): The trade conditions. Defaults to None.
        tape (Optional[str]): The trade tape. Defaults to None.
    """

    symbol: str
    timestamp: datetime
    exchange: Optional[Union[Exchange, str]] = None
    price: float
    size: float
    id: Optional[int] = None
    conditions: Optional[Union[List[str], str]] = None
    tape: Optional[str] = None

    def __init__(self, symbol: str, raw_data: RawData) -> None:
        """Instantiates a Trade object

        Args:
            symbol (str): The security identifier for the trade that occurred.
            raw_data (RawData): The trade data as received by API.
        """

        mapped_trade = {
            TRADE_MAPPING.get(key): val
            for key, val in raw_data.items()
            if key in TRADE_MAPPING
        }

        super().__init__(symbol=symbol, **mapped_trade)


class TradeSet(BaseDataSet, TimeSeriesMixin):
    """A collection of Trade objects.

    Attributes:
        data (Dict[str, List[Trade]]]): The collection of Trades keyed by symbol.
    """

    data: Dict[str, List[Trade]] = {}

    def __init__(self, raw_data: RawData) -> None:
        """Instantiates a TradeSet - a collection of Trades.

        Args:
            raw_data (RawData): The raw trade data received from API keyed by symbol
        """
        parsed_trades = {}

        if raw_data is not None:
            for symbol, trades in raw_data.items():
                parsed_trades[symbol] = [
                    Trade(symbol, trade) for trade in trades if trade is not None
                ]

        super().__init__(data=parsed_trades)


class TradingStatus(BaseModel):
    """Trading status update of a security, for example if a symbol gets halted.

    Attributes:
        symbol (str): The ticker identifier.
        timestamp (datetime): The time of trading status.
        status_code (str): The tape-dependent code of the status.
        status_message (str): The status message.
        reason_code (str): The tape-dependent code of the halt reason.
        reason_message (str): The reason message.
        tape (Optional[str]): The tape (A, B or C).
    """

    symbol: str
    timestamp: datetime
    status_code: str
    status_message: str
    reason_code: str
    reason_message: str
    tape: str

    def __init__(self, symbol: str, raw_data: RawData) -> None:
        """Instantiates a Trading status object

        Args:
            symbol (str): The security identifier
            raw_data (RawData): The raw data as received by API.
        """

        mapped = {
            TRADING_STATUS_MAPPING.get(key): val
            for key, val in raw_data.items()
            if key in TRADING_STATUS_MAPPING
        }

        super().__init__(symbol=symbol, **mapped)


class TradeCancel(BaseModel):
    """Cancel of a previous trade.

    Attributes:
        symbol (str): The ticker identifier.
        timestamp (datetime): The timestamp.
        exchange (Exchange): The exchange.
        price (float): The price of the canceled trade.
        size (float): The size of the canceled trade.
        id (Optional[int]): The original ID of the canceled trade.
        action (Optional[str]): The cancel action ("C" for cancel, "E" for error)
        tape (str): The trade tape. Defaults to None.
    """

    symbol: str
    timestamp: datetime
    exchange: Exchange
    price: float
    size: float
    id: Optional[int] = None
    action: Optional[str] = None
    tape: str

    def __init__(self, symbol: str, raw_data: RawData) -> None:
        """Instantiates a trade cancel object

        Args:
            symbol (str): The security identifier
            raw_data (RawData): The raw data as received by API.
        """

        mapped = {
            TRADE_CANCEL_MAPPING.get(key): val
            for key, val in raw_data.items()
            if key in TRADE_CANCEL_MAPPING
        }

        super().__init__(symbol=symbol, **mapped)


class TradeCorrection(BaseModel):
    """Correction of a previous trade.

    Attributes:
        symbol (str): The ticker identifier.
        timestamp (datetime): The timestamp.
        exchange (Exchange): The exchange.
        original_id (Optional[int]): The original ID of the corrected trade.
        original_price (float): The original price of the corrected trade.
        original_size (float): The original size of the corrected trade.
        original_conditions (List[str]): The original conditions of the corrected trade.
        corrected_id (Optional[int]): The corrected ID of the corrected trade.
        corrected_price (float): The corrected price of the corrected trade.
        corrected_size (float): The corrected size of the corrected trade.
        corrected_conditions (List[str]): The corrected conditions of the corrected trade.
        tape (str): The trade tape. Defaults to None.
    """

    symbol: str
    timestamp: datetime
    exchange: Exchange
    original_id: Optional[int] = None
    original_price: float
    original_size: float
    original_conditions: List[str]
    corrected_id: Optional[int] = None
    corrected_price: float
    corrected_size: float
    corrected_conditions: List[str]
    tape: str

    def __init__(self, symbol: str, raw_data: RawData) -> None:
        """Instantiates a trade correction object

        Args:
            symbol (str): The security identifier
            raw_data (RawData): The raw data as received by API.
        """
        mapped = {
            TRADE_CORRECTION_MAPPING.get(key): val
            for key, val in raw_data.items()
            if key in TRADE_CORRECTION_MAPPING
        }

        super().__init__(symbol=symbol, **mapped)
````

## File: alpaca/data/__init__.py
````python
from alpaca.data.enums import *
from alpaca.data.models import *
from alpaca.data.timeframe import *
from alpaca.data.requests import *
from alpaca.data.historical import *
````

## File: alpaca/data/enums.py
````python
from enum import Enum


class Exchange(str, Enum):
    """The exchanges that provide data feeds to Alpaca.

    Attributes:
        Z (str): Cboe BZ
        I (str): International Securities Exchange
        M (str): Chicago Stock Exchange
        U (str): Members Exchange
        L (str): Long Term Stock Exchange
        W (str): CBOE
        X (str): NASDAQ OMX PSX
        B (str): NASDAQ OMX BX
        D (str): FINRA ADF
        J (str): Cboe EDGA
        P (str): NYSE Arca
        Q (str): NASDAQ OMX
        S (str): NASDAQ Small Cap
        V (str): IEX
        A (str): NYSE American (AMEX)
        E (str): Market Independent
        N (str): New York Stock Exchange
        T (str): NASDAQ Int
        Y (str): Cboe BYX
        C (str): National Stock Exchange
        H (str): MIAX
        K (str): Cboe EDGX
    """

    Z = "Z"
    I = "I"
    M = "M"
    U = "U"
    L = "L"
    W = "W"
    X = "X"
    B = "B"
    D = "D"
    J = "J"
    P = "P"
    Q = "Q"
    S = "S"
    V = "V"
    A = "A"
    E = "E"
    N = "N"
    T = "T"
    Y = "Y"
    C = "C"
    H = "H"
    K = "K"


class DataFeed(str, Enum):
    """Equity market data feeds. OTC and SIP are available with premium data subscriptions.

    Attributes:
        IEX (str): Investor's exchange data feed
        SIP (str): Securities Information Processor feed
        OTC (str): Over the counter feed
    """

    IEX = "iex"
    SIP = "sip"
    OTC = "otc"


class Adjustment(str, Enum):
    """Data normalization based on types of corporate actions.

    Attributes:
        RAW (str): Unadjusted data
        SPLIT (str): Stock-split adjusted data
        DIVIDEND (str): Dividend adjusted data
        ALL (str): Data adjusted for all corporate actions
    """

    RAW = "raw"
    SPLIT = "split"
    DIVIDEND = "dividend"
    ALL = "all"


class CryptoFeed(str, Enum):
    """
    Crypto location

    Attributes:
        US (str): United States crypto feed
    """

    US = "us"


class OptionsFeed(str, Enum):
    """
    The source feed of the data.
    `opra` requires subscription

    Attributes:
        OPRA (str): Options Price Reporting Authority
        INDICATIVE (str): Indicative data
    """

    OPRA = "opra"
    INDICATIVE = "indicative"


class MostActivesBy(str, Enum):
    """
    Most actives possible filters.

    Attributes:
        volume (str):
            Retrieve most actives by trading volume.
        trades (str):
            Retrieve most actives by number of trades.
    """

    VOLUME = "volume"
    TRADES = "trades"


class MarketType(str, Enum):
    """
    Most actives possible filters.

    Attributes:
        stocks (str)
        crypto (str)
    """

    STOCKS = "stocks"
    CRYPTO = "crypto"


class NewsImageSize(str, Enum):
    THUMB = "thumb"
    SMALL = "small"
    LARGE = "large"


class CorporateActionsType(str, Enum):
    """
    The type of corporate action.
    ref. https://docs.alpaca.markets/reference/corporateactions-1

    Attributes:
        REVERSE_SPLIT (str): Reverse split
        FORWARD_SPLIT (str): Forward split
        UNIT_SPLIT (str): Unit split
        CASH_DIVIDEND (str): Cash dividend
        STOCK_DIVIDEND (str): Stock dividend
        SPIN_OFF (str): Spin off
        CASH_MERGER (str): Cash merger
        STOCK_MERGER (str): Stock merger
        STOCK_AND_CASH_MERGER (str): Stock and cash merger
        REDEMPTION (str): Redemption
        NAME_CHANGE (str): Name change
        WORTHLESS_REMOVAL (str): Worthless removal
        RIGHTS_DISTRIBUTION (str): Rights distribution
    """

    REVERSE_SPLIT = "reverse_split"
    FORWARD_SPLIT = "forward_split"
    UNIT_SPLIT = "unit_split"
    CASH_DIVIDEND = "cash_dividend"
    STOCK_DIVIDEND = "stock_dividend"
    SPIN_OFF = "spin_off"
    CASH_MERGER = "cash_merger"
    STOCK_MERGER = "stock_merger"
    STOCK_AND_CASH_MERGER = "stock_and_cash_merger"
    REDEMPTION = "redemption"
    NAME_CHANGE = "name_change"
    WORTHLESS_REMOVAL = "worthless_removal"
    RIGHTS_DISTRIBUTION = "rights_distribution"
````

## File: alpaca/data/mappings.py
````python
from typing import Dict

BAR_MAPPING: Dict[str, str] = {
    "t": "timestamp",
    "o": "open",
    "h": "high",
    "l": "low",
    "c": "close",
    "v": "volume",
    "n": "trade_count",
    "vw": "vwap",
}

QUOTE_MAPPING: Dict[str, str] = {
    "t": "timestamp",
    "ax": "ask_exchange",
    "ap": "ask_price",
    "as": "ask_size",
    "bx": "bid_exchange",
    "bp": "bid_price",
    "bs": "bid_size",
    "c": "conditions",
    "z": "tape",
}

TRADE_MAPPING: Dict[str, str] = {
    "t": "timestamp",
    "p": "price",
    "s": "size",
    "x": "exchange",
    "i": "id",
    "c": "conditions",
    "z": "tape",
}

SNAPSHOT_MAPPING: Dict[str, str] = {
    "latestTrade": "latest_trade",
    "latestQuote": "latest_quote",
    "minuteBar": "minute_bar",
    "dailyBar": "daily_bar",
    "prevDailyBar": "previous_daily_bar",
    "impliedVolatility": "implied_volatility",
    "greeks": "greeks",
}

ORDERBOOK_MAPPING: Dict[str, str] = {
    "t": "timestamp",
    "b": "bids",
    "a": "asks",
    "r": "reset",
}

TRADING_STATUS_MAPPING: Dict[str, str] = {
    "t": "timestamp",
    "sc": "status_code",
    "sm": "status_message",
    "rc": "reason_code",
    "rm": "reason_message",
    "z": "tape",
}

TRADE_CANCEL_MAPPING: Dict[str, str] = {
    "t": "timestamp",
    "p": "price",
    "s": "size",
    "x": "exchange",
    "i": "id",
    "a": "action",
    "z": "tape",
}

TRADE_CORRECTION_MAPPING: Dict[str, str] = {
    "t": "timestamp",
    "x": "exchange",
    "oi": "original_id",
    "op": "original_price",
    "os": "original_size",
    "oc": "original_conditions",
    "ci": "corrected_id",
    "cp": "corrected_price",
    "cs": "corrected_size",
    "cc": "corrected_conditions",
    "z": "tape",
}
````

## File: alpaca/data/requests.py
````python
from datetime import date, datetime
from typing import Any, List, Optional, Union

import pytz
from pydantic import ConfigDict

from alpaca.common.enums import Sort, SupportedCurrencies
from alpaca.common.requests import NonEmptyRequest
from alpaca.data.enums import (
    Adjustment,
    CorporateActionsType,
    DataFeed,
    MarketType,
    MostActivesBy,
    OptionsFeed,
)
from alpaca.data.timeframe import TimeFrame
from alpaca.trading.enums import ContractType


class BaseTimeseriesDataRequest(NonEmptyRequest):
    """
    A base class for requests for time series data between a start and an end. This shouldn't be
    instantiated directly. Instead, you should use one of the data type specific classes.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
        start (Optional[datetime]): The beginning of the time interval for desired data. Timezone naive inputs assumed to be in UTC.
        end (Optional[datetime]): The end of the time interval for desired data. Timezone naive inputs assumed to be in UTC.
        limit (Optional[int]): Upper limit of number of data points to return. Defaults to None.
        currency (Optional[SupportedCurrencies]): The currency the data should be returned in. Default to USD.
        sort: (Optional[Sort]): The chronological order of response based on the timestamp. Defaults to ASC.
    """

    symbol_or_symbols: Union[str, List[str]]
    start: Optional[datetime] = None
    end: Optional[datetime] = None
    limit: Optional[int] = None
    currency: Optional[SupportedCurrencies] = None  # None = USD
    sort: Optional[Sort] = None  # None = asc

    def __init__(self, **data: Any) -> None:
        # convert timezone aware datetime to timezone naive UTC datetime
        if (
            "start" in data
            and data["start"] is not None
            and isinstance(data["start"], datetime)
            and data["start"].tzinfo is not None
        ):
            data["start"] = data["start"].astimezone(pytz.utc).replace(tzinfo=None)

        if (
            "end" in data
            and data["end"] is not None
            and isinstance(data["end"], datetime)
            and data["end"].tzinfo is not None
        ):
            data["end"] = data["end"].astimezone(pytz.utc).replace(tzinfo=None)

        super().__init__(**data)


# ############################## Bars ################################# #


class BaseBarsRequest(BaseTimeseriesDataRequest):
    """
    A base request object for retrieving bar data for securities. You most likely should not use this directly and instead
    use the asset class specific request objects.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
        start (Optional[datetime]): The beginning of the time interval for desired data. Timezone naive inputs assumed to be in UTC.
        end (Optional[datetime]): The end of the time interval for desired data. Defaults to now. Timezone naive inputs assumed to be in UTC.
        limit (Optional[int]): Upper limit of number of data points to return. Defaults to None.
        timeframe (TimeFrame): The period over which the bars should be aggregated. (i.e. 5 Min bars, 1 Day bars)
        sort (Optional[Sort]): The chronological order of response based on the timestamp. Defaults to ASC.
    """

    timeframe: TimeFrame

    # Allows TimeFrame as a non-pydantic BaseModel field
    model_config = ConfigDict(arbitrary_types_allowed=True)


class StockBarsRequest(BaseBarsRequest):
    """
    The request model for retrieving bar data for equities.

    See BaseBarsRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
        timeframe (TimeFrame): The period over which the bars should be aggregated. (i.e. 5 Min bars, 1 Day bars)
        start (Optional[datetime]): The beginning of the time interval for desired data. Timezone naive inputs assumed to be in UTC.
        end (Optional[datetime]): The end of the time interval for desired data. Defaults to now. Timezone naive inputs assumed to be in UTC.
        limit (Optional[int]): Upper limit of number of data points to return. Defaults to None.
        adjustment (Optional[Adjustment]): The type of corporate action data normalization.
        feed (Optional[DataFeed]): The stock data feed to retrieve from.
        sort (Optional[Sort]): The chronological order of response based on the timestamp. Defaults to ASC.
        asof (Optional[str]): The asof date of the queried stock symbol(s) in YYYY-MM-DD format.
        currency (Optional[SupportedCurrencies]): The currency of all prices in ISO 4217 format. Default is USD.
    """

    adjustment: Optional[Adjustment] = None
    feed: Optional[DataFeed] = None
    asof: Optional[str] = None


class CryptoBarsRequest(BaseBarsRequest):
    """
    The request model for retrieving bar data for cryptocurrencies.

    See BaseBarsRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
        timeframe (TimeFrame): The period over which the bars should be aggregated. (i.e. 5 Min bars, 1 Day bars)
        start (Optional[datetime]): The beginning of the time interval for desired data. Timezone naive inputs assumed to be in UTC.
        end (Optional[datetime]): The end of the time interval for desired data. Defaults to now. Timezone naive inputs assumed to be in UTC.
        limit (Optional[int]): Upper limit of number of data points to return. Defaults to None.
        sort (Optional[Sort]): The chronological order of response based on the timestamp. Defaults to ASC.
    """

    pass


class OptionBarsRequest(BaseBarsRequest):
    """
    The request model for retrieving bar data for option contracts.

    See BaseBarsRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
        timeframe (TimeFrame): The length of time (also known as time interval) for which each Bar represents (i.e. 5 Min bars, 1 Day bars).
        start (Optional[datetime]): The beginning of the time period for desired data. Timezone naive inputs assumed to be in UTC.
        end (Optional[datetime]): The end of the time period for desired data. Defaults to now. Timezone naive inputs assumed to be in UTC.
        limit (Optional[int]): Upper limit of number of data points to return. Defaults to None.
        sort (Optional[Sort]): The chronological order of response based on the timestamp. Defaults to ASC.
    """


# ############################## Quotes ################################# #


class StockQuotesRequest(BaseTimeseriesDataRequest):
    """
    This request class is used to submit a request for stock quote data.

    See BaseTimeseriesDataRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
        start (Optional[datetime]): The beginning of the time interval for desired data. Timezone naive inputs assumed to be in UTC.
        end (Optional[datetime]): The end of the time interval for desired data. Defaults to now. Timezone naive inputs assumed to be in UTC.
        limit (Optional[int]): Upper limit of number of data points to return. Defaults to None.
        feed (Optional[DataFeed]): The stock data feed to retrieve from.
        sort (Optional[Sort]): The chronological order of response based on the timestamp. Defaults to ASC.
        asof (Optional[str]): The asof date of the queried stock symbol(s) in YYYY-MM-DD format.
        currency (Optional[SupportedCurrencies]): The currency of all prices in ISO 4217 format. Default is USD.
    """

    feed: Optional[DataFeed] = None
    asof: Optional[str] = None


class CryptoQuoteRequest(BaseTimeseriesDataRequest):
    """
    This request class is used to submit a request for crypto quote data.

    See BaseTimeseriesDataRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
        start (Optional[datetime]): The beginning of the time interval for desired data. Timezone naive inputs assumed to be in UTC.
        end (Optional[datetime]): The end of the time interval for desired data. Defaults to now. Timezone naive inputs assumed to be in UTC.
        limit (Optional[int]): Upper limit of number of data points to return. Defaults to None.
        sort (Optional[Sort]): The chronological order of response based on the timestamp. Defaults to ASC.

    """

    pass


# ############################## Trades ################################# #


class StockTradesRequest(BaseTimeseriesDataRequest):
    """
    This request class is used to submit a request for stock trade data.

    See BaseTimeseriesDataRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
        start (Optional[datetime]): The beginning of the time interval for desired data. Timezone naive inputs assumed to be in UTC.
        end (Optional[datetime]): The end of the time interval for desired data. Defaults to now. Timezone naive inputs assumed to be in UTC.
        limit (Optional[int]): Upper limit of number of data points to return. Defaults to None.
        feed (Optional[DataFeed]): The stock data feed to retrieve from.
        sort (Optional[Sort]): The chronological order of response based on the timestamp. Defaults to ASC.
        asof (Optional[str]): The asof date of the queried stock symbol(s) in YYYY-MM-DD format.
        currency (Optional[SupportedCurrencies]): The currency of all prices in ISO 4217 format. Default is USD.
    """

    feed: Optional[DataFeed] = None
    asof: Optional[str] = None


class CryptoTradesRequest(BaseTimeseriesDataRequest):
    """
    This request class is used to submit a request for crypto trade data.

    See BaseTimeseriesDataRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
        start (Optional[datetime]): The beginning of the time interval for desired data. Timezone naive inputs assumed to be in UTC.
        end (Optional[datetime]): The end of the time interval for desired data. Defaults to now. Timezone naive inputs assumed to be in UTC.
        limit (Optional[int]): Upper limit of number of data points to return. Defaults to None.
        sort (Optional[Sort]): The chronological order of response based on the timestamp. Defaults to ASC.
    """

    pass


class OptionTradesRequest(BaseTimeseriesDataRequest):
    """
    This request class is used to submit a request for option trade data.

    See BaseTimeseriesDataRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The option identifier or list of option identifiers.
        start (Optional[datetime]): The beginning of the time interval for desired data. Timezone naive inputs assumed to be in UTC.
        end (Optional[datetime]): The end of the time interval for desired data. Defaults to now. Timezone naive inputs assumed to be in UTC.
        limit (Optional[int]): Upper limit of number of data points to return. Defaults to None.
        sort (Optional[Sort]): The chronological order of response based on the timestamp. Defaults to ASC.
    """

    pass


# ############################## Latest Endpoints ################################# #


class BaseStockLatestDataRequest(NonEmptyRequest):
    """
    A base request object for retrieving the latest data for stocks. You most likely should not use this directly and
    instead use the asset class specific request objects.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
        feed (Optional[DataFeed]): The stock data feed to retrieve from.
        currency (Optional[SupportedCurrencies]): The currency the data should be returned in. Default to USD.
    """

    symbol_or_symbols: Union[str, List[str]]
    feed: Optional[DataFeed] = None
    currency: Optional[SupportedCurrencies] = None  # None = USD


class StockLatestTradeRequest(BaseStockLatestDataRequest):
    """
    This request class is used to submit a request for the latest stock trade data.

    See BaseStockLatestDataRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
        feed (Optional[DataFeed]): The stock data feed to retrieve from.
        currency (Optional[SupportedCurrencies]): The currency the data should be returned in. Default to USD.
    """

    pass


class StockLatestQuoteRequest(BaseStockLatestDataRequest):
    """
    This request class is used to submit a request for the latest stock quote data.

    See BaseStockLatestDataRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
        feed (Optional[DataFeed]): The stock data feed to retrieve from.
        currency (Optional[SupportedCurrencies]): The currency the data should be returned in. Default to USD.
    """

    pass


class StockLatestBarRequest(BaseStockLatestDataRequest):
    """
    This request class is used to submit a request for the latest stock bar data.

    See BaseStockLatestDataRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
        feed (Optional[DataFeed]): The stock data feed to retrieve from.
        currency (Optional[SupportedCurrencies]): The currency the data should be returned in. Default to USD.
    """

    pass


class BaseCryptoLatestDataRequest(NonEmptyRequest):
    """
    A base request object for retrieving the latest data for crypto. You most likely should not use this directly and
    instead use the asset class specific request objects.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
    """

    symbol_or_symbols: Union[str, List[str]]


class CryptoLatestTradeRequest(BaseCryptoLatestDataRequest):
    """
    This request class is used to submit a request for the latest crypto trade data.

    See BaseCryptoLatestDataRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
    """

    pass


class CryptoLatestQuoteRequest(BaseCryptoLatestDataRequest):
    """
    This request class is used to submit a request for the latest crypto quote data.

    See BaseCryptoLatestDataRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
    """

    pass


class CryptoLatestBarRequest(BaseCryptoLatestDataRequest):
    """
    This request class is used to submit a request for the latest crypto bar data.

    See BaseCryptoLatestDataRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
    """

    pass


class BaseOptionLatestDataRequest(NonEmptyRequest):
    """
    A base request object for retrieving the latest data for options. You most likely should not use this directly and
    instead use the asset class specific request objects.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The option identifier or list of option identifiers.
        feed (Optional[OptionsFeed]): The source feed of the data. `opra` or `indicative`. Default: `opra` if the user has the options subscription, `indicative` otherwise.
    """

    symbol_or_symbols: Union[str, List[str]]
    feed: Optional[OptionsFeed] = None


class OptionLatestQuoteRequest(BaseOptionLatestDataRequest):
    """
    This request class is used to submit a request for the latest option quote data.

    See BaseOptionLatestDataRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The option identifier or list of option identifiers.
        feed (Optional[OptionsFeed]): The source feed of the data. `opra` or `indicative`. Default: `opra` if the user has the options subscription, `indicative` otherwise.
    """

    pass


class OptionLatestTradeRequest(BaseOptionLatestDataRequest):
    """
    This request class is used to submit a request for the latest option trade data.

    See BaseOptionLatestDataRequest for more information on available parameters.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The option identifier or list of option identifiers.
        feed (Optional[OptionsFeed]): The source feed of the data. `opra` or `indicative`. Default: `opra` if the user has the options subscription, `indicative` otherwise.
    """

    pass


# ############################## Snapshots ################################# #


class StockSnapshotRequest(NonEmptyRequest):
    """
    This request class is used to submit a request for snapshot data for stocks.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
        feed (Optional[DataFeed]): The stock data feed to retrieve from.
        currency (Optional[SupportedCurrencies]): The currency the data should be returned in. Default to USD.
    """

    symbol_or_symbols: Union[str, List[str]]
    feed: Optional[DataFeed] = None
    currency: Optional[SupportedCurrencies] = None  # None = USD


class CryptoSnapshotRequest(NonEmptyRequest):
    """
    This request class is used to submit a request for snapshot data for crypto.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
    """

    symbol_or_symbols: Union[str, List[str]]


class OptionSnapshotRequest(NonEmptyRequest):
    """
    This request class is used to submit a request for snapshot data for options.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The option identifier or list of option identifiers.
        feed (Optional[OptionsFeed]): The source feed of the data. `opra` or `indicative`. Default: `opra` if the user has the options subscription, `indicative` otherwise.
    """

    symbol_or_symbols: Union[str, List[str]]
    feed: Optional[OptionsFeed] = None


class OptionChainRequest(NonEmptyRequest):
    """
    This request class is used to submit a request for option chain data for options.

    Attributes:
        underlying_symbol (str): The underlying_symbol for option contracts.
        feed (Optional[OptionsFeed]): The source feed of the data. `opra` or `indicative`. Default: `opra` if the user has the options subscription, `indicative` otherwise.
        type (Optional[ContractType]): Filter contracts by the type (call or put).
        strike_price_gte (Optional[float]): Filter contracts with strike price greater than or equal to the specified value.
        strike_price_lte (Optional[float]): Filter contracts with strike price less than or equal to the specified value.
        expiration_date (Optional[Union[date, str]]): Filter contracts by the exact expiration date (format: YYYY-MM-DD).
        expiration_date_gte (Optional[Union[date, str]]): Filter contracts with expiration date greater than or equal to the specified date.
        expiration_date_lte (Optional[Union[date, str]]): Filter contracts with expiration date less than or equal to the specified date.
        root_symbol (Optional[str]): Filter contracts by the root symbol.
        updated_since (Optional[datetime]): Filter to snapshots that were updated since this timestamp.
    """

    underlying_symbol: str
    feed: Optional[OptionsFeed] = None
    type: Optional[ContractType] = None
    strike_price_gte: Optional[float] = None
    strike_price_lte: Optional[float] = None
    expiration_date: Optional[Union[date, str]] = None
    expiration_date_gte: Optional[Union[date, str]] = None
    expiration_date_lte: Optional[Union[date, str]] = None
    root_symbol: Optional[str] = None
    updated_since: Optional[datetime] = None


# ############################## Orderbooks ################################# #


class CryptoLatestOrderbookRequest(NonEmptyRequest):
    """
    This request class is used to submit a request for latest orderbook data for crypto.

    Attributes:
        symbol_or_symbols (Union[str, List[str]]): The ticker identifier or list of ticker identifiers.
    """

    symbol_or_symbols: Union[str, List[str]]


# ############################## Screener #################################### #


class ScreenerRequest(NonEmptyRequest):
    """
    This request class is used to submit a request for screener endpoints.

    Attributes:
        top (int): Number of top most active stocks to fetch per day.
    """

    top: int = 10


class MostActivesRequest(ScreenerRequest):
    """
    This request class is used to submit a request for most actives screener endpoint.

    Attributes:
        by (MostActivesBy): The metric used for ranking the most active stocks.
        top (int): Number of top most active stocks to fetch per day.
    """

    by: MostActivesBy = MostActivesBy.VOLUME.value


class MarketMoversRequest(ScreenerRequest):
    """
    This request class is used to submit a request for most actives screener endpoint.

    Attributes:
        market_type (MarketType): Screen specific market (stocks or crypto).
        top (int): Number of top most active stocks to fetch per day.
    """

    market_type: MarketType = MarketType.STOCKS


# ############################## News #################################### #


class NewsRequest(NonEmptyRequest):
    """
    This request class is used to submit a request for most actives screener endpoint.

    Attributes:
    start (Optional[datetime]): The inclusive start of the interval. Format: RFC-3339 or YYYY-MM-DD.
        If missing, the default value is the beginning of the current day.
    end (Optional[datetime])): The inclusive end of the interval. Format: RFC-3339 or YYYY-MM-DD.
        If missing, the default value is the current time.
    sort (Optional[str]): Sort articles by updated date.
    symbols (Optional[str]): The comma-separated list of symbols to query news for.
    limit (Optional[int]): Limit of news items to be returned for given page.
    include_content (Optional[bool]): Boolean indicator to include content for news articles (if available)
    exclude_contentless (Optional[bool]): Boolean indicator to exclude news articles that do not contain content
    page_token (Optional[str]): Pagination token to continue from. The value to pass here is returned in specific requests when more data is available than the request limit allows. This should not be used, pagination is handled automatically by the SDK.
    """

    start: Optional[datetime] = None
    end: Optional[datetime] = None
    sort: Optional[str] = None
    symbols: Optional[str] = None
    limit: Optional[int] = None
    include_content: Optional[bool] = None
    exclude_contentless: Optional[bool] = None
    page_token: Optional[str] = None


# ############################## CorporateActions #################################### #


class CorporateActionsRequest(NonEmptyRequest):
    """
    This request class is used to submit a request for corporate actions data.
    ref. https://docs.alpaca.markets/reference/corporateactions-1

    Attributes:
        symbols (Optional[List[str]]): The list of ticker identifiers.
        types (Optional[List[CorporateActionsType]]): The types of corporate actions to filter by. (default: all types)
        start (Optional[date]): The inclusive start of the interval. Format: YYYY-MM-DD. (default: current day)
        end (Optional[date])): The inclusive end of the interval. Format: YYYY-MM-DD. (default: current day)
        limit (Optional[int]): Upper limit of number of data points to return. (default: 1000)
        sort (Optional[Sort]): The chronological order of response based on the timestamp. Defaults to ASC.
    """

    symbols: Optional[List[str]] = None
    types: Optional[List[CorporateActionsType]] = None
    start: Optional[date] = None
    end: Optional[date] = None
    limit: Optional[int] = 1000
    sort: Optional[Sort] = Sort.ASC
````

## File: alpaca/data/timeframe.py
````python
from enum import Enum


class classproperty(property):
    """Allows us to create decorator of stacked classmethod and property decorators

    Args:
        property (property): the property decorator class
    """

    def __get__(self, cls, owner):
        return classmethod(self.fget).__get__(None, owner)()


class TimeFrameUnit(str, Enum):
    """Quantity of time used as unit"""

    Minute: str = "Min"
    Hour: str = "Hour"
    Day: str = "Day"
    Week: str = "Week"
    Month: str = "Month"


class TimeFrame:
    """A time interval specified in multiples of defined units (minute, day, etc)

    Attributes:
        amount_value (int): The number of multiples of the TimeFrameUnit interval
        unit_value (TimeFrameUnit): The base unit of time interval that is used to measure the TimeFrame

    Raises:
        ValueError: Raised if the amount_value and unit_value are not consistent with each other
    """

    amount_value: int
    unit_value: TimeFrameUnit

    def __init__(self, amount, unit) -> None:
        self.validate_timeframe(amount, unit)
        self.amount_value = amount
        self.unit_value = unit

    @property
    def amount(self) -> int:
        """Returns the amount_value field

        Returns:
            int: amount_value field
        """
        return self.amount_value

    @property
    def unit(self) -> TimeFrameUnit:
        """Returns the TimeFrameUnit field value of this TimeFrame object

        Returns:
            TimeFrameUnit: unit_value field
        """
        return self.unit_value

    @property
    def value(self) -> str:
        """Returns a string representation of this TimeFrame object for API consumption

        Returns:
            str: string representation of this timeframe
        """
        return f"{self.amount}{self.unit.value}"

    @staticmethod
    def validate_timeframe(amount: int, unit: TimeFrameUnit):
        """Validates the amount value against the TimeFrameUnit value for consistency

        Args:
            amount (int): The number of multiples of unit
            unit (TimeFrameUnit): The base unit of time interval the TimeFrame is measured by

        Raises:
            ValueError: Raised if the values of amount and unit are not consistent with each other
        """
        if amount <= 0:
            raise ValueError("Amount must be a positive integer value.")

        if unit == TimeFrameUnit.Minute and amount > 59:
            raise ValueError(
                "Second or Minute units can only be "
                + "used with amounts between 1-59."
            )

        if unit == TimeFrameUnit.Hour and amount > 23:
            raise ValueError("Hour units can only be used with amounts 1-23")

        if unit in (TimeFrameUnit.Day, TimeFrameUnit.Week) and amount != 1:
            raise ValueError("Day and Week units can only be used with amount 1")

        if unit == TimeFrameUnit.Month and amount not in (1, 2, 3, 6, 12):
            raise ValueError(
                "Month units can only be used with amount 1, 2, 3, 6 and 12"
            )

    def __str__(self):
        return self.value

    @classproperty
    def Minute(cls):
        """Helper method to quickly access a 1 minute timeframe

        Returns:
            TimeFrame: A 1-minute TimeFrame
        """
        return TimeFrame(amount=1, unit=TimeFrameUnit.Minute)

    @classproperty
    def Hour(cls):
        """Helper method to quickly access a 1 hour timeframe

        Returns:
            TimeFrame: A 1-hour TimeFrame
        """
        return TimeFrame(amount=1, unit=TimeFrameUnit.Hour)

    @classproperty
    def Day(cls):
        """Helper method to quickly access a  1 day timeframe

        Returns:
            TimeFrame: A 1-day TimeFrame
        """
        return TimeFrame(amount=1, unit=TimeFrameUnit.Day)

    @classproperty
    def Week(cls):
        """Helper method to quickly access a 1 week timeframe

        Returns:
            TimeFrame: A 1-week TimeFrame
        """
        return TimeFrame(amount=1, unit=TimeFrameUnit.Week)

    @classproperty
    def Month(cls):
        """Helper method to quickly access a 1 month timeframe

        Returns:
            TimeFrame: A 1-month TimeFrame
        """
        return TimeFrame(amount=1, unit=TimeFrameUnit.Month)
````

## File: alpaca/trading/__init__.py
````python
from alpaca.trading.client import *
from alpaca.trading.models import *
from alpaca.trading.enums import *
from alpaca.trading.requests import *
from alpaca.trading.stream import *
````

## File: alpaca/trading/client.py
````python
from uuid import UUID
from pydantic import TypeAdapter
import json

from alpaca.common import RawData
from alpaca.common.utils import (
    validate_symbol_or_contract_id,
    validate_uuid_id_param,
    validate_symbol_or_asset_id,
)
from alpaca.common.rest import RESTClient
from typing import Optional, List, Union
from alpaca.common.enums import BaseURL

from alpaca.trading.requests import (
    GetCalendarRequest,
    ClosePositionRequest,
    GetAssetsRequest,
    GetOptionContractsRequest,
    GetPortfolioHistoryRequest,
    OrderRequest,
    GetOrdersRequest,
    ReplaceOrderRequest,
    GetOrderByIdRequest,
    CancelOrderResponse,
    CreateWatchlistRequest,
    UpdateWatchlistRequest,
    GetCorporateAnnouncementsRequest,
)

from alpaca.trading.models import (
    OptionContract,
    OptionContractsResponse,
    Order,
    PortfolioHistory,
    Position,
    ClosePositionResponse,
    Asset,
    Watchlist,
    Clock,
    Calendar,
    TradeAccount,
    CorporateActionAnnouncement,
    AccountConfiguration,
)


class TradingClient(RESTClient):
    """
    A client to interact with the trading API, in both paper and live mode.
    """

    def __init__(
        self,
        api_key: Optional[str] = None,
        secret_key: Optional[str] = None,
        oauth_token: Optional[str] = None,
        paper: bool = True,
        raw_data: bool = False,
        url_override: Optional[str] = None,
    ) -> None:
        """
        Instantiates a client for trading and managing personal brokerage accounts.

        Args:
            api_key (Optional[str]): The API key for trading. Use paper keys if paper is set to true.
            secret_key (Optional[str]): The secret key for trading. Use paper keys if paper is set to true.
            oauth_token (Optional[str]): The oauth token for trading on behalf of end user.
            paper (bool): True is paper trading should be enabled.
            raw_data (bool): Whether API responses should be wrapped in data models or returned raw.
                This has not been implemented yet.
            url_override (Optional[str]): If specified allows you to override the base url the client points to for proxy/testing.
        """
        super().__init__(
            api_key=api_key,
            secret_key=secret_key,
            oauth_token=oauth_token,
            api_version="v2",
            base_url=(
                url_override
                if url_override
                else BaseURL.TRADING_PAPER if paper else BaseURL.TRADING_LIVE
            ),
            sandbox=paper,
            raw_data=raw_data,
        )

    # ############################## ORDERS ################################# #

    def submit_order(self, order_data: OrderRequest) -> Union[Order, RawData]:
        """Creates an order to buy or sell an asset.

        Args:
            order_data (alpaca.trading.requests.OrderRequest): The request data for creating a new order.

        Returns:
            alpaca.trading.models.Order: The resulting submitted order.
        """
        data = order_data.to_request_fields()
        response = self.post("/orders", data)

        if self._use_raw_data:
            return response

        return Order(**response)

    def get_orders(
        self, filter: Optional[GetOrdersRequest] = None
    ) -> Union[List[Order], RawData]:
        """
        Returns all orders. Orders can be filtered by parameters.

        Args:
            filter (Optional[GetOrdersRequest]): The parameters to filter the orders with.

        Returns:
            List[alpaca.trading.models.Order]: The queried orders.
        """
        # checking to see if we specified at least one param
        params = filter.to_request_fields() if filter is not None else {}

        if "symbols" in params and isinstance(params["symbols"], list):
            params["symbols"] = ",".join(params["symbols"])

        response = self.get("/orders", params)

        if self._use_raw_data:
            return response

        return TypeAdapter(List[Order]).validate_python(response)

    def get_order_by_id(
        self, order_id: Union[UUID, str], filter: Optional[GetOrderByIdRequest] = None
    ) -> Union[Order, RawData]:
        """
        Returns a specific order by its order id.

        Args:
            order_id (Union[UUID, str]): The unique uuid identifier for the order.
            filter (Optional[GetOrderByIdRequest]): The parameters for the query.

        Returns:
            alpaca.trading.models.Order: The order that was queried.
        """
        # checking to see if we specified at least one param
        params = filter.to_request_fields() if filter is not None else {}

        order_id = validate_uuid_id_param(order_id, "order_id")

        response = self.get(f"/orders/{order_id}", params)

        if self._use_raw_data:
            return response

        return Order(**response)

    def get_order_by_client_id(self, client_id: str) -> Union[Order, RawData]:
        """
        Returns a specific order by its client order id.

        Args:
            client_id (str): The client order identifier for the order.

        Returns:
            alpaca.trading.models.Order: The queried order.
        """
        params = {"client_order_id": client_id}

        response = self.get(f"/orders:by_client_order_id", params)

        if self._use_raw_data:
            return response

        return Order(**response)

    def replace_order_by_id(
        self,
        order_id: Union[UUID, str],
        order_data: Optional[ReplaceOrderRequest] = None,
    ) -> Union[Order, RawData]:
        """
        Updates an order with new parameters.

        Args:
            order_id (Union[UUID, str]): The unique uuid identifier for the order being replaced.
            order_data (Optional[ReplaceOrderRequest]): The parameters we wish to update.

        Returns:
            alpaca.trading.models.Order: The updated order.
        """
        # checking to see if we specified at least one param
        params = order_data.to_request_fields() if order_data is not None else {}

        order_id = validate_uuid_id_param(order_id, "order_id")

        response = self.patch(f"/orders/{order_id}", params)

        if self._use_raw_data:
            return response

        return Order(**response)

    def cancel_orders(self) -> Union[List[CancelOrderResponse], RawData]:
        """
        Cancels all orders.

        Returns:
            List[CancelOrderResponse]: The list of HTTP statuses for each order attempted to be cancelled.
        """
        response = self.delete(f"/orders")

        if self._use_raw_data:
            return response

        return TypeAdapter(List[CancelOrderResponse]).validate_python(response)

    def cancel_order_by_id(self, order_id: Union[UUID, str]) -> None:
        """
        Cancels a specific order by its order id.

        Args:
            order_id (Union[UUID, str]): The unique uuid identifier of the order being cancelled.

        Returns:
            CancelOrderResponse: The HTTP response from the cancel request.
        """
        order_id = validate_uuid_id_param(order_id, "order_id")

        # TODO: Should ideally return some information about the order's cancel status. (Issue #78).
        # TODO: Currently no way to retrieve status details for empty responses with base REST implementation
        self.delete(f"/orders/{order_id}")

    # ############################## POSITIONS ################################# #

    def get_all_positions(
        self,
    ) -> Union[List[Position], RawData]:
        """
        Gets all the current open positions.

        Returns:
            List[Position]: List of open positions.
        """
        response = self.get("/positions")

        if self._use_raw_data:
            return response

        return TypeAdapter(List[Position]).validate_python(response)

    def get_open_position(
        self, symbol_or_asset_id: Union[UUID, str]
    ) -> Union[Position, RawData]:
        """
        Gets the open position for an account for a single asset. Throws an APIError if the position does not exist.

        Args:
            symbol_or_asset_id (Union[UUID, str]): The symbol name of asset id of the position to get.

        Returns:
            Position: Open position of the asset.
        """
        symbol_or_asset_id = validate_symbol_or_asset_id(symbol_or_asset_id)
        response = self.get(f"/positions/{symbol_or_asset_id}")

        if self._use_raw_data:
            return response

        return Position(**response)

    def close_all_positions(
        self, cancel_orders: Optional[bool] = None
    ) -> Union[List[ClosePositionResponse], RawData]:
        """
        Liquidates all positions for an account.

        Places an order for each open position to liquidate.

        Args:
            cancel_orders (Optional[bool]): If true is specified, cancel all open orders before liquidating all positions.

        Returns:
            List[ClosePositionResponse]: A list of responses from each closed position containing the status code and
              order id.
        """
        response = self.delete(
            "/positions",
            {"cancel_orders": cancel_orders} if cancel_orders else None,
        )

        if self._use_raw_data:
            return response

        return TypeAdapter(List[ClosePositionResponse]).validate_python(response)

    def close_position(
        self,
        symbol_or_asset_id: Union[UUID, str],
        close_options: Optional[ClosePositionRequest] = None,
    ) -> Union[Order, RawData]:
        """
        Liquidates the position for a single asset.

        Places a single order to close the position for the asset.

        **This method will throw an error if the position does not exist!**

        Args:
            symbol_or_asset_id (Union[UUID, str]): The symbol name of asset id of the position to close.
            close_options: The various close position request parameters.

        Returns:
            alpaca.trading.models.Order: The order that was placed to close the position.
        """
        symbol_or_asset_id = validate_symbol_or_asset_id(symbol_or_asset_id)
        response = self.delete(
            f"/positions/{symbol_or_asset_id}",
            close_options.to_request_fields() if close_options else {},
        )

        if self._use_raw_data:
            return response

        return Order(**response)

    def exercise_options_position(
        self,
        symbol_or_contract_id: Union[UUID, str],
    ) -> None:
        """
        This endpoint enables users to exercise a held option contract, converting it into the underlying asset based on the specified terms.
        All available held shares of this option contract will be exercised.
        By default, Alpaca will automatically exercise in-the-money (ITM) contracts at expiry.
        Exercise requests will be processed immediately once received. Exercise requests submitted outside market hours will be rejected.
        To cancel an exercise request or to submit a Do-not-exercise (DNE) instruction, please contact our support team.

        Args:
            symbol_or_contract_id (Union[UUID, str]): Option contract symbol or ID.

        Returns:
            None
        """
        symbol_or_contract_id = validate_symbol_or_contract_id(symbol_or_contract_id)
        self.post(
            f"/positions/{symbol_or_contract_id}/exercise",
        )

    # ############################## Portfolio ################################# #

    def get_portfolio_history(
        self,
        history_filter: Optional[GetPortfolioHistoryRequest] = None,
    ) -> Union[PortfolioHistory, RawData]:
        """
        Gets the portfolio history statistics for an account.

        Args:
            account_id (Union[UUID, str]): The ID of the Account to get the portfolio history for.
            history_filter: The various portfolio history request parameters.

        Returns:
            PortfolioHistory: The portfolio history statistics for the account.
        """
        response = self.get(
            f"/account/portfolio/history",
            history_filter.to_request_fields() if history_filter else {},
        )

        if self._use_raw_data:
            return response

        return PortfolioHistory(**response)

    # ############################## Assets ################################# #

    def get_all_assets(
        self, filter: Optional[GetAssetsRequest] = None
    ) -> Union[List[Asset], RawData]:
        """
        The assets API serves as the master list of assets available for trade and data consumption from Alpaca.
        Some assets are not tradable with Alpaca. These assets will be marked with the flag tradable=false.

        Args:
            filter (Optional[GetAssetsRequest]): The parameters that can be assets can be queried by.

        Returns:
            List[Asset]: The list of assets.
        """
        # checking to see if we specified at least one param
        params = filter.to_request_fields() if filter is not None else {}

        response = self.get(f"/assets", params)

        if self._use_raw_data:
            return response

        return TypeAdapter(List[Asset]).validate_python(response)

    def get_asset(self, symbol_or_asset_id: Union[UUID, str]) -> Union[Asset, RawData]:
        """
        Returns a specific asset by its symbol or asset id. If the specified asset does not exist
        a 404 error will be thrown.

        Args:
            symbol_or_asset_id (Union[UUID, str]): The symbol or asset id for the specified asset

        Returns:
            Asset: The asset if it exists.
        """

        symbol_or_asset_id = validate_symbol_or_asset_id(symbol_or_asset_id)

        response = self.get(f"/assets/{symbol_or_asset_id}")

        if self._use_raw_data:
            return response

        return Asset(**response)

    # ############################## CLOCK & CALENDAR ################################# #

    def get_clock(self) -> Union[Clock, RawData]:
        """
        Gets the current market timestamp, whether or not the market is currently open, as well as the times
        of the next market open and close.

        Returns:
            Clock: The market Clock data
        """

        response = self.get("/clock")

        if self._use_raw_data:
            return response

        return Clock(**response)

    def get_calendar(
        self,
        filters: Optional[GetCalendarRequest] = None,
    ) -> Union[List[Calendar], RawData]:
        """
        The calendar API serves the full list of market days from 1970 to 2029. It can also be queried by specifying a
        start and/or end time to narrow down the results.

        In addition to the dates, the response also contains the specific open and close times for the market days,
        taking into account early closures.

        Args:
            filters: Any optional filters to limit the returned market days

        Returns:
            List[Calendar]: A list of Calendar objects representing the market days.
        """

        result = self.get("/calendar", filters.to_request_fields() if filters else {})

        if self._use_raw_data:
            return result

        return TypeAdapter(List[Calendar]).validate_python(result)

    # ############################## ACCOUNT ################################# #

    def get_account(self) -> Union[TradeAccount, RawData]:
        """
        Returns account details. Contains information like buying power,
        number of day trades, and account status.

        Returns:
            alpaca.trading.models.TradeAccount: The account details
        """

        response = self.get("/account")

        if self._use_raw_data:
            return response

        return TradeAccount(**response)

    def get_account_configurations(self) -> Union[AccountConfiguration, RawData]:
        """
        Returns account configuration details. Contains information like shorting, margin multiplier
        trader confirmation emails, and Pattern Day Trading (PDT) checks.

        Returns:
            alpaca.broker.models.AccountConfiguration: The account configuration details
        """
        response = self.get("/account/configurations")

        if self._use_raw_data:
            return response

        return AccountConfiguration(**response)

    def set_account_configurations(
        self, account_configurations: AccountConfiguration
    ) -> Union[AccountConfiguration, RawData]:
        """
        Returns account configuration details. Contains information like shorting, margin multiplier
        trader confirmation emails, and Pattern Day Trading (PDT) checks.

        Returns:
            alpaca.broker.models.TradeAccountConfiguration: The account configuration details
        """
        response = self.patch(
            "/account/configurations", data=account_configurations.model_dump()
        )

        if self._use_raw_data:
            return response

        return AccountConfiguration(**response)

    # ############################## WATCHLIST ################################# #

    def get_watchlists(
        self,
    ) -> Union[List[Watchlist], RawData]:
        """
        Returns all watchlists.

        Returns:
            List[Watchlist]: The list of all watchlists.
        """

        result = self.get(f"/watchlists")

        if self._use_raw_data:
            return result

        return TypeAdapter(List[Watchlist]).validate_python(result)

    def get_watchlist_by_id(
        self,
        watchlist_id: Union[UUID, str],
    ) -> Union[Watchlist, RawData]:
        """
        Returns a specific watchlist by its id.

        Args:
            watchlist_id (Union[UUID, str]): The watchlist to retrieve.

        Returns:
            Watchlist: The watchlist.
        """
        watchlist_id = validate_uuid_id_param(watchlist_id, "watchlist_id")

        result = self.get(f"/watchlists/{watchlist_id}")

        if self._use_raw_data:
            return result

        return Watchlist(**result)

    def create_watchlist(
        self,
        watchlist_data: CreateWatchlistRequest,
    ) -> Union[Watchlist, RawData]:
        """
        Creates a new watchlist.

        Args:
            watchlist_data (CreateWatchlistRequest): The watchlist to create.

        Returns:
            Watchlist: The new watchlist.
        """
        result = self.post(
            "/watchlists",
            watchlist_data.to_request_fields(),
        )

        if self._use_raw_data:
            return result

        return Watchlist(**result)

    def update_watchlist_by_id(
        self,
        watchlist_id: Union[UUID, str],
        # Might be worth taking a union of this and Watchlist itself; but then we should make a change like that SDK
        # wide. Probably a good 0.2.x change
        watchlist_data: UpdateWatchlistRequest,
    ) -> Union[Watchlist, RawData]:
        """
        Updates a watchlist with new data.

        Args:
            watchlist_id (Union[UUID, str]): The watchlist to be updated.
            watchlist_data (UpdateWatchlistRequest): The new watchlist data.

        Returns:
            Watchlist: The watchlist with updated data.
        """
        watchlist_id = validate_uuid_id_param(watchlist_id, "watchlist_id")

        result = self.put(
            f"/watchlists/{watchlist_id}",
            watchlist_data.to_request_fields(),
        )

        if self._use_raw_data:
            return result

        return Watchlist(**result)

    def add_asset_to_watchlist_by_id(
        self,
        watchlist_id: Union[UUID, str],
        symbol: str,
    ) -> Union[Watchlist, RawData]:
        """
        Adds an asset by its symbol to a specified watchlist.

        Args:
            watchlist_id (Union[UUID, str]): The watchlist to add the symbol to.
            symbol (str): The symbol for the asset to add.

        Returns:
            Watchlist: The updated watchlist.
        """
        watchlist_id = validate_uuid_id_param(watchlist_id, "watchlist_id")

        params = {"symbol": symbol}

        result = self.post(f"/watchlists/{watchlist_id}", params)

        if self._use_raw_data:
            return result

        return Watchlist(**result)

    def delete_watchlist_by_id(
        self,
        watchlist_id: Union[UUID, str],
    ) -> None:
        """
        Deletes a watchlist. This is permanent.

        Args:
            watchlist_id (Union[UUID, str]): The watchlist to delete.

        Returns:
            None
        """
        watchlist_id = validate_uuid_id_param(watchlist_id, "watchlist_id")

        self.delete(f"/watchlists/{watchlist_id}")

    def remove_asset_from_watchlist_by_id(
        self,
        watchlist_id: Union[UUID, str],
        symbol: str,
    ) -> Union[Watchlist, RawData]:
        """
        Removes an asset from a watchlist.

        Args:
            watchlist_id (Union[UUID, str]): The watchlist to remove the asset from.
            symbol (str): The symbol for the asset to add.

        Returns:
            Watchlist: The updated watchlist.
        """
        watchlist_id = validate_uuid_id_param(watchlist_id, "watchlist_id")

        result = self.delete(f"/watchlists/{watchlist_id}/{symbol}")

        if self._use_raw_data:
            return result

        return Watchlist(**result)

    # ############################## CORPORATE ACTIONS ################################# #

    def get_corporate_announcements(
        self, filter: GetCorporateAnnouncementsRequest
    ) -> Union[List[CorporateActionAnnouncement], RawData]:
        """
        Returns corporate action announcements data given specified search criteria.
        Args:
            filter (GetCorporateAnnouncementsRequest): The parameters to filter the search by.
        Returns:
            List[CorporateActionAnnouncement]: The resulting announcements from the search.
        """
        params = filter.to_request_fields() if filter else {}

        if "ca_types" in params and isinstance(params["ca_types"], list):
            params["ca_types"] = ",".join(params["ca_types"])

        response = self.get("/corporate_actions/announcements", params)

        if self._use_raw_data:
            return response

        return TypeAdapter(List[CorporateActionAnnouncement]).validate_python(response)

    def get_corporate_announcement_by_id(
        self, corporate_announcment_id: Union[UUID, str]
    ) -> Union[CorporateActionAnnouncement, RawData]:
        """
        Returns a specific corporate action announcement.
        Args:
            corporate_announcment_id: The id of the desired corporate action announcement
        Returns:
            CorporateActionAnnouncement: The corporate action queried.
        """
        corporate_announcment_id = validate_uuid_id_param(
            corporate_announcment_id, "corporate_announcment_id"
        )

        response = self.get(
            f"/corporate_actions/announcements/{corporate_announcment_id}"
        )

        if self._use_raw_data:
            return response

        return CorporateActionAnnouncement(**response)

    # ############################## OPTIONS CONTRACTS ################################# #

    def get_option_contracts(
        self, request: GetOptionContractsRequest
    ) -> Union[OptionContractsResponse, RawData]:
        """
        The option contracts API serves as the master list of option contracts available for trade and data consumption from Alpaca.

        Args:
            request (GetOptionContractsRequest): The parameters that option contracts can be queried by.

        Returns:
            OptionContracts (Union[OptionContractsResponse, RawData]): The object includes list of option contracts.
        """
        if request is None:
            raise ValueError("request (GetOptionContractsRequest) is required")

        params = request.to_request_fields()

        if "underlying_symbols" in params and isinstance(
            request.underlying_symbols, list
        ):
            params["underlying_symbols"] = ",".join(request.underlying_symbols)

        response = self.get("/options/contracts", params)

        if self._use_raw_data:
            return response

        return TypeAdapter(OptionContractsResponse).validate_python(response)

    def get_option_contract(
        self, symbol_or_id: Union[UUID, str]
    ) -> Union[OptionContract, RawData]:
        """
        The option contracts API serves as the master list of option contracts available for trade and data consumption from Alpaca.

        Args:
            symbol_or_id (Union[UUID, str]): The symbol or id of the option contract to retrieve.

        Returns:
            OptionContracts (Union[OptionContracts, RawData]): The list of option contracts.
        """
        if symbol_or_id == "":
            raise ValueError("symbol_or_id is required")

        response = self.get(f"/options/contracts/{symbol_or_id}")

        if self._use_raw_data:
            return response

        return TypeAdapter(OptionContract).validate_python(response)
````

## File: alpaca/trading/enums.py
````python
from enum import Enum


class ActivityType(str, Enum):
    """
    Represents what kind of Activity an instance of TradeActivity or NonTradeActivity is.

    Please see https://alpaca.markets/docs/api-references/broker-api/accounts/account-activities/#enumactivitytype
    for descriptions of each of the types
    """

    FILL = "FILL"
    ACATC = "ACATC"
    ACATS = "ACATS"
    CFEE = "CFEE"
    CIL = "CIL"
    CSD = "CSD"
    CSW = "CSW"
    DIV = "DIV"
    DIVCGL = "DIVCGL"
    DIVCGS = "DIVCGS"
    DIVNRA = "DIVNRA"
    DIVROC = "DIVROC"
    DIVTXEX = "DIVTXEX"
    DIVWH = "DIVWH"
    EXTRD = "EXTRD"
    FEE = "FEE"
    FXTRD = "FXTRD"
    INT = "INT"
    INTPNL = "INTPNL"
    JNLC = "JNLC"
    JNLS = "JNLS"
    MA = "MA"
    MEM = "MEM"
    NC = "NC"
    OCT = "OCT"
    OPASN = "OPASN"
    OPCSH = "OPCSH"
    OPEXC = "OPEXC"
    OPEXP = "OPEXP"
    OPTRD = "OPTRD"
    PTC = "PTC"
    REORG = "REORG"
    SPIN = "SPIN"
    SPLIT = "SPLIT"
    SWP = "SWP"
    VOF = "VOF"
    WH = "WH"

    def is_trade_activity(self) -> bool:
        """
        A simple check to see if the ActivityType represents a type that belongs to TradeActivity's.

        Currently, the check is just against FILL. However, this might change in the future so we are adding this helper
        func here to help ease against future changes.

        Returns:
            bool: returns true if this ActivityType represents a TradeActivity
        """

        return self.value == self.FILL

    @staticmethod
    def is_str_trade_activity(value: str) -> bool:
        """
        similar to is_trade_activity but for raw data that hasn't been parsed into an enum yet.
        Useful for deserialization.

        Args:
            value (str): Value to check to see if it would be a valid ActivityType for a TradeActivity

        Returns:
            bool: returns true if `value` would represent a TradeActivity ActivityType
        """

        return value == ActivityType.FILL


class TradeActivityType(str, Enum):
    """
    Represents the type of TradeActivity.

    Please see https://alpaca.markets/docs/api-references/broker-api/accounts/account-activities/#attributes
    """

    PARTIAL_FILL = "partial_fill"
    FILL = "fill"


class NonTradeActivityStatus(str, Enum):
    """
    Represents the status of a NonTradeActivity.

    Please see https://alpaca.markets/docs/api-references/broker-api/accounts/account-activities/#enumaccountactivity
    for more info.
    """

    EXECUTED = "executed"
    CORRECT = "correct"
    CANCELED = "canceled"


class OrderClass(str, Enum):
    """
    Represents what class of order this is.

    The order classes supported by Alpaca vary based on the order's security type.
    The following provides a comprehensive breakdown of the supported order classes for each category:
    - Equity trading: simple (or ""), oco, oto, bracket.
    - Options trading: simple (or ""), mleg (required for multi-leg complex options strategies).
    - Crypto trading: simple (or "").
    """

    SIMPLE = "simple"
    MLEG = "mleg"
    BRACKET = "bracket"
    OCO = "oco"
    OTO = "oto"


class OrderType(str, Enum):
    """
    Represents what type of order this is.

    The order types supported by Alpaca vary based on the order's security type.
    The following provides a comprehensive breakdown of the supported order types for each category:
    - Equity trading: market, limit, stop, stop_limit, trailing_stop.
    - Options trading: market, limit, stop, stop_limit.
    - Crypto trading: market, limit, stop_limit.
    """

    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"
    TRAILING_STOP = "trailing_stop"


class OrderSide(str, Enum):
    """
    Represents what side this order was executed on.
    """

    BUY = "buy"
    SELL = "sell"


class OrderStatus(str, Enum):
    """
    Represents the various states an Order can be in.

    please see https://alpaca.markets/docs/api-references/broker-api/trading/orders/#order-status for more info
    """

    NEW = "new"
    PARTIALLY_FILLED = "partially_filled"
    FILLED = "filled"
    DONE_FOR_DAY = "done_for_day"
    CANCELED = "canceled"
    EXPIRED = "expired"
    REPLACED = "replaced"
    PENDING_CANCEL = "pending_cancel"
    PENDING_REPLACE = "pending_replace"
    PENDING_REVIEW = "pending_review"
    ACCEPTED = "accepted"
    PENDING_NEW = "pending_new"
    ACCEPTED_FOR_BIDDING = "accepted_for_bidding"
    STOPPED = "stopped"
    REJECTED = "rejected"
    SUSPENDED = "suspended"
    CALCULATED = "calculated"
    HELD = "held"


class AssetClass(str, Enum):
    """
    This represents the category to which the asset belongs to.
    It serves to identify the nature of the financial instrument, with options
    including "us_equity" for U.S. equities, "us_option" for U.S. options,
    and "crypto" for cryptocurrencies.
    """

    US_EQUITY = "us_equity"
    US_OPTION = "us_option"
    CRYPTO = "crypto"


class AssetStatus(str, Enum):
    """
    Represents the various states for an Asset's lifecycle
    """

    ACTIVE = "active"
    INACTIVE = "inactive"


class AssetExchange(str, Enum):
    """
    Represents the current exchanges Alpaca supports.
    """

    AMEX = "AMEX"
    ARCA = "ARCA"
    BATS = "BATS"
    NYSE = "NYSE"
    NASDAQ = "NASDAQ"
    NYSEARCA = "NYSEARCA"
    FTXU = "FTXU"
    CBSE = "CBSE"
    GNSS = "GNSS"
    ERSX = "ERSX"
    OTC = "OTC"
    CRYPTO = "CRYPTO"
    EMPTY = ""


class PositionSide(str, Enum):
    """
    Represents what side this position is.
    """

    SHORT = "short"
    LONG = "long"


class TimeInForce(str, Enum):
    """
    Represents the various time in force options for an Order.

    The Time-In-Force values supported by Alpaca vary based on the order's security type. Here is a breakdown of the supported TIFs for each specific security type:
    - Equity trading: day, gtc, opg, cls, ioc, fok.
    - Options trading: day.
    - Crypto trading: gtc, ioc.
    Below are the descriptions of each TIF:
    - day: A day order is eligible for execution only on the day it is live. By default, the order is only valid during Regular Trading Hours (9:30am - 4:00pm ET). If unfilled after the closing auction, it is automatically canceled. If submitted after the close, it is queued and submitted the following trading day. However, if marked as eligible for extended hours, the order can also execute during supported extended hours.
    - gtc: The order is good until canceled. Non-marketable GTC limit orders are subject to price adjustments to offset corporate actions affecting the issue. We do not currently support Do Not Reduce(DNR) orders to opt out of such price adjustments.
    - opg: Use this TIF with a market/limit order type to submit ‚Äúmarket on open‚Äù (MOO) and ‚Äúlimit on open‚Äù (LOO) orders. This order is eligible to execute only in the market opening auction. Any unfilled orders after the open will be cancelled. OPG orders submitted after 9:28am but before 7:00pm ET will be rejected. OPG orders submitted after 7:00pm will be queued and routed to the following day‚Äôs opening auction. On open/on close orders are routed to the primary exchange. Such orders do not necessarily execute exactly at 9:30am / 4:00pm ET but execute per the exchange‚Äôs auction rules.
    - cls: Use this TIF with a market/limit order type to submit ‚Äúmarket on close‚Äù (MOC) and ‚Äúlimit on close‚Äù (LOC) orders. This order is eligible to execute only in the market closing auction. Any unfilled orders after the close will be cancelled. CLS orders submitted after 3:50pm but before 7:00pm ET will be rejected. CLS orders submitted after 7:00pm will be queued and routed to the following day‚Äôs closing auction. Only available with API v2.
    - ioc: An Immediate Or Cancel (IOC) order requires all or part of the order to be executed immediately. Any unfilled portion of the order is canceled. Only available with API v2. Most market makers who receive IOC orders will attempt to fill the order on a principal basis only, and cancel any unfilled balance. On occasion, this can result in the entire order being cancelled if the market maker does not have any existing inventory of the security in question.
    - fok: A Fill or Kill (FOK) order is only executed if the entire order quantity can be filled, otherwise the order is canceled. Only available with API v2.
    """

    DAY = "day"
    GTC = "gtc"
    OPG = "opg"
    CLS = "cls"
    IOC = "ioc"
    FOK = "fok"


class CorporateActionType(str, Enum):
    """
    The general types of corporate action events.

    Learn more here: https://alpaca.markets/docs/api-references/trading-api/corporate-actions-announcements/
    """

    DIVIDEND = "dividend"
    MERGER = "merger"
    SPINOFF = "spinoff"
    SPLIT = "split"


class CorporateActionSubType(str, Enum):
    """
    The specific types of corporate actions. Each subtype is related to CorporateActionType.

    Learn more here: https://alpaca.markets/docs/api-references/trading-api/corporate-actions-announcements/
    """

    CASH = "cash"
    STOCK = "stock"
    MERGER_UPDATE = "merger_update"
    MERGER_COMPLETION = "merger_completion"
    SPINOFF = "spinoff"
    STOCK_SPLIT = "stock_split"
    UNIT_SPLIT = "unit_split"
    REVERSE_SPLIT = "reverse_split"
    RECAPITALIZATION = "recapitalization"


class AccountStatus(str, Enum):
    """
    The various statuses each brokerage account can take during its lifetime

    see https://alpaca.markets/docs/broker/api-references/accounts/accounts/#account-status
    """

    ACCOUNT_CLOSED = "ACCOUNT_CLOSED"
    ACCOUNT_UPDATED = "ACCOUNT_UPDATED"
    ACTION_REQUIRED = "ACTION_REQUIRED"
    ACTIVE = "ACTIVE"
    AML_REVIEW = "AML_REVIEW"
    APPROVAL_PENDING = "APPROVAL_PENDING"
    APPROVED = "APPROVED"
    DISABLED = "DISABLED"
    DISABLE_PENDING = "DISABLE_PENDING"
    EDITED = "EDITED"
    INACTIVE = "INACTIVE"
    KYC_SUBMITTED = "KYC_SUBMITTED"
    LIMITED = "LIMITED"
    ONBOARDING = "ONBOARDING"
    PAPER_ONLY = "PAPER_ONLY"
    REAPPROVAL_PENDING = "REAPPROVAL_PENDING"
    REJECTED = "REJECTED"
    RESUBMITTED = "RESUBMITTED"
    SIGNED_UP = "SIGNED_UP"
    SUBMISSION_FAILED = "SUBMISSION_FAILED"
    SUBMITTED = "SUBMITTED"


class CorporateActionDateType(str, Enum):
    DECLARATION_DATE = "declaration_date"
    EX_DATE = "ex_date"
    RECORD_DATE = "record_date"
    PAYABLE_DATE = "payable_date"


class TradeEvent(str, Enum):
    FILL = "fill"
    CANCELED = "canceled"
    PENDING_NEW = "pending_new"
    NEW = "new"
    PARTIAL_FILL = "partial_fill"


class QueryOrderStatus(str, Enum):
    OPEN = "open"
    CLOSED = "closed"
    ALL = "all"


class DTBPCheck(str, Enum):
    """
    Specifies when to run a DTBP check for an account.

    NOTE: These values are currently the same as PDTCheck however they are not guaranteed to be in sync the future

    please see https://alpaca.markets/docs/api-references/broker-api/trading/trading-configurations/#attributes
    for more info.
    """

    BOTH = "both"
    ENTRY = "entry"
    EXIT = "exit"


class PDTCheck(str, Enum):
    """
    Specifies when to run a PDT check for an account.

    NOTE: These values are currently the same as DTBPCheck however they are not guaranteed to be in sync the future

    please see https://alpaca.markets/docs/api-references/broker-api/trading/trading-configurations/#attributes
    for more info.
    """

    BOTH = "both"
    ENTRY = "entry"
    EXIT = "exit"


class TradeConfirmationEmail(str, Enum):
    """
    Used for controlling when an Account will receive a trade confirmation email.

    please see https://docs.alpaca.markets/reference/getaccountconfig
    for more info.
    """

    ALL = "all"
    NONE = "none"


class ContractType(str, Enum):
    """
    Represents the contract type of options
    """

    CALL = "call"
    PUT = "put"


class ExerciseStyle(str, Enum):
    """
    Represents the exercise style of options
    """

    AMERICAN = "american"
    EUROPEAN = "european"


class ActivityCategory(str, Enum):
    """
    Represents the category of an Activity
    """

    TRADE_ACTIVITY = "trade_activity"
    NON_TRADE_ACTIVITY = "non_trade_activity"


class PositionIntent(str, Enum):
    """
    Represents what side this order was executed on.
    """

    BUY_TO_OPEN = "buy_to_open"
    BUY_TO_CLOSE = "buy_to_close"
    SELL_TO_OPEN = "sell_to_open"
    SELL_TO_CLOSE = "sell_to_close"
````

## File: alpaca/trading/models.py
````python
from alpaca.common.models import ModelWithID, ValidateBaseModel as BaseModel
from uuid import UUID
from datetime import datetime, date
from typing import Any, Optional, List, Union, Dict
from alpaca.trading.enums import (
    AssetClass,
    AssetStatus,
    AssetExchange,
    ContractType,
    DTBPCheck,
    ExerciseStyle,
    OrderStatus,
    OrderType,
    OrderClass,
    PDTCheck,
    PositionIntent,
    TimeInForce,
    OrderSide,
    PositionSide,
    AccountStatus,
    TradeActivityType,
    NonTradeActivityStatus,
    ActivityType,
    CorporateActionType,
    CorporateActionSubType,
    TradeConfirmationEmail,
    TradeEvent,
)
from pydantic import Field, model_validator


class Asset(ModelWithID):
    """
    Represents a security. Some Assets are not tradable with Alpaca. These Assets are
    marked with the flag `tradable=false`.

    For more info, visit https://alpaca.markets/docs/api-references/trading-api/assets/

    Attributes:
        id (UUID): Unique id of asset
        asset_class (AssetClass): The name of the asset class.
        exchange (AssetExchange): Which exchange this asset is available through.
        symbol (str): The symbol identifier of the asset.
        name (Optional[str]): The name of the asset.
        status (AssetStatus): The active status of the asset.
        tradable (bool): Whether the asset can be traded.
        marginable (bool): Whether the asset can be traded on margin.
        shortable (bool): Whether the asset can be shorted.
        easy_to_borrow (bool): When shorting, whether the asset is easy to borrow
        fractionable (bool): Whether fractional shares are available
        attributes (Optional[List[str]]): One of ptp_no_exception or ptp_with_exception. It will include unique characteristics of the asset here.
    """

    asset_class: AssetClass = Field(
        alias="class"
    )  # using a pydantic alias to allow parsing data with the `class` keyword field
    exchange: AssetExchange
    symbol: str
    name: Optional[str] = None
    status: AssetStatus
    tradable: bool
    marginable: bool
    shortable: bool
    easy_to_borrow: bool
    fractionable: bool
    min_order_size: Optional[float] = None
    min_trade_increment: Optional[float] = None
    price_increment: Optional[float] = None
    maintenance_margin_requirement: Optional[float] = None
    attributes: Optional[List[str]] = None


class USDPositionValues(BaseModel):
    """
    Represents an open long or short holding in an asset in USD.

    Attributes:
        avg_entry_price (str): The average entry price of the position.
        market_value (str): Total dollar amount of the position.
        cost_basis (str): Total cost basis in dollars.
        unrealized_pl (str): Unrealized profit/loss in dollars.
        unrealized_plpc (str): Unrealized profit/loss percent.
        unrealized_intraday_pl (str): Unrealized profit/loss in dollars for the day.
        unrealized_intraday_plpc (str): Unrealized profit/loss percent for the day.
        current_price (str): Current asset price per share.
        lastday_price (str): Last day‚Äôs asset price per share based on the closing value of the last trading day.
        change_today (str): Percent change from last day's price.

    """

    avg_entry_price: str
    market_value: str
    cost_basis: str
    unrealized_pl: str
    unrealized_plpc: str
    unrealized_intraday_pl: str
    unrealized_intraday_plpc: str
    current_price: str
    lastday_price: str
    change_today: str


class Position(BaseModel):
    """
    Represents an open long or short holding in an asset.

    Attributes:
        asset_id (UUID): ID of the asset.
        symbol (str): Symbol of the asset.
        exchange (AssetExchange): Exchange name of the asset.
        asset_class (AssetClass): Name of the asset's asset class.
        asset_marginable (Optional[bool]): Indicates if this asset is marginable.
        avg_entry_price (str): The average entry price of the position.
        qty (str): The number of shares of the position.
        side (PositionSide): "long" or "short" representing the side of the position.
        market_value (Optional[str]): Total dollar amount of the position.
        cost_basis (str): Total cost basis in dollars.
        unrealized_pl (Optional[str]): Unrealized profit/loss in dollars.
        unrealized_plpc (Optional[str]): Unrealized profit/loss percent.
        unrealized_intraday_pl (Optional[str]): Unrealized profit/loss in dollars for the day.
        unrealized_intraday_plpc (Optional[str]): Unrealized profit/loss percent for the day.
        current_price (Optional[str]): Current asset price per share.
        lastday_price (Optional[str]): Last day‚Äôs asset price per share based on the closing value of the last trading day.
        change_today (Optional[str]): Percent change from last day's price.
        swap_rate (Optional[str]): Swap rate is the exchange rate (without mark-up) used to convert the price into local currency or crypto asset.
        avg_entry_swap_rate (Optional[str]): The average exchange rate the price was converted into the local currency at.
        usd (USDPositionValues): Represents the position in USD values.
        qty_available (Optional[str]): Total number of shares available minus open orders.

    """

    asset_id: UUID
    symbol: str
    exchange: AssetExchange
    asset_class: AssetClass
    asset_marginable: Optional[bool] = None
    avg_entry_price: str
    qty: str
    side: PositionSide
    market_value: Optional[str] = None
    cost_basis: str
    unrealized_pl: Optional[str] = None
    unrealized_plpc: Optional[str] = None
    unrealized_intraday_pl: Optional[str] = None
    unrealized_intraday_plpc: Optional[str] = None
    current_price: Optional[str] = None
    lastday_price: Optional[str] = None
    change_today: Optional[str] = None
    swap_rate: Optional[str] = None
    avg_entry_swap_rate: Optional[str] = None
    usd: Optional[USDPositionValues] = None
    qty_available: Optional[str] = None


class AllAccountsPositions(BaseModel):
    """
    Represents the positions of every account as of last market close.

    Attributes:
        as_of (datetime): Timestamp for which the positions are returned.
        positions (Dict[str, List[Position]]): Positions held by an account, keyed by account_id.
    """

    as_of: datetime
    positions: Dict[str, List[Position]]


class Order(ModelWithID):
    """
    Represents a request for the sale or purchase of an asset.

    Attributes:
        id (UUID): order ID generated by Alpaca.
        client_order_id (str): Client unique order ID
        created_at (datetime): Timestamp when the order was created.
        updated_at (datetime): Timestamp when the order was last updated.
        submitted_at (datetime): Timestamp when the order was submitted.
        filled_at (Optional[datetime]): Timestamp when the order was filled.
        expired_at (Optional[datetime]): Timestamp when the order expired at.
        expires_at (Optional[datetime]): An auto cancel request will be triggered after this timestamp.
        canceled_at (Optional[datetime]): Timestamp when the order was canceled.
        failed_at (Optional[datetime]): Timestamp when the order failed at.
        replaced_at (Optional[datetime]): Timestamp when the order was replaced by a new order.
        replaced_by (Optional[UUID]): ID of order that replaces this order.
        replaces (Optional[UUID]): ID of order which this order replaces.
        asset_id (Optional[UUID]): ID of the asset. Omitted from top-level of response if the order is of mleg class.
        symbol (Optional[str]): Symbol of the asset. Omitted from top-level of response if the order is of mleg class.
        asset_class (Optional[AssetClass]): Asset class of the asset. Omitted from top-level of response if the order is of mleg class.
        notional (Optional[str]): Ordered notional amount. If entered, qty will be null. Can take up to 9 decimal
          points.
        qty (Optional[str]): Ordered quantity. If entered, notional will be null. Can take up to 9 decimal points.
        filled_qty (Optional[str]): Filled quantity.
        filled_avg_price (Optional[str]): Filled average price. Can be 0 until order is processed in case order is
          passed outside of market hours.
        order_class (OrderClass): Valid values: simple, bracket, oco or oto.
        order_type (Optional[OrderType]): Deprecated with just type field below. Omitted from legs of mleg orders.
        type (Optional[OrderType]): Valid values: market, limit, stop, stop_limit, trailing_stop. Omitted from legs of mleg orders.
        side (Optional[OrderSide]): Valid values: buy and sell. Omitted from top-level of response if the order is of mleg class.
        time_in_force (TimeInForce): Length of time the order is in force.
        limit_price (Optional[str]): Limit price of the order.
        stop_price (Optional[str]): Stop price of the order.
        status (OrderStatus): The status of the order.
        extended_hours (bool): If true, eligible for execution outside regular trading hours.
        legs (Optional[List[alpaca.trading.models.Order]]): When querying non-simple order_class orders in a nested style,
          an array of order entities associated with this order. Otherwise, null.
        trail_percent (Optional[str]): The percent value away from the high water mark for trailing stop orders.
        trail_price (Optional[str]): The dollar value away from the high water mark for trailing stop orders.
        hwm (Optional[str]): The highest (lowest) market price seen since the trailing stop order was submitted.
        position_intent  (Optional[PositionIntent]): Represents the desired position strategy.
        ratio_qty (Optional[str]): The proportional quantity of this leg in relation to the overall multi-leg order quantity.
    """

    client_order_id: str
    created_at: datetime
    updated_at: datetime
    submitted_at: datetime
    filled_at: Optional[datetime] = None
    expired_at: Optional[datetime] = None
    expires_at: Optional[datetime] = None
    canceled_at: Optional[datetime] = None
    failed_at: Optional[datetime] = None
    replaced_at: Optional[datetime] = None
    replaced_by: Optional[UUID] = None
    replaces: Optional[UUID] = None
    asset_id: Optional[UUID] = None
    symbol: Optional[str] = None
    asset_class: Optional[AssetClass] = None
    notional: Optional[str] = None
    qty: Optional[Union[str, float]] = None
    filled_qty: Optional[Union[str, float]] = None
    filled_avg_price: Optional[Union[str, float]] = None
    order_class: OrderClass
    order_type: Optional[OrderType] = None
    type: Optional[OrderType] = None
    side: Optional[OrderSide] = None
    time_in_force: TimeInForce
    limit_price: Optional[Union[str, float]] = None
    stop_price: Optional[Union[str, float]] = None
    status: OrderStatus
    extended_hours: bool
    legs: Optional[List["Order"]] = None
    trail_percent: Optional[str] = None
    trail_price: Optional[str] = None
    hwm: Optional[str] = None
    position_intent: Optional[PositionIntent] = None
    ratio_qty: Optional[Union[str, float]] = None

    def __init__(self, **data: Any) -> None:
        if "order_class" not in data or data["order_class"] == "":
            data["order_class"] = OrderClass.SIMPLE

        # mleg responses will give ''s that will need to be converted to None
        # to avoid validation errors from pydantic
        for k in [
            "asset_id",
            "symbol",
            "asset_class",
            "side",
            "position_intent",
            "type",
            "order_type",
        ]:
            if k in data and data[k] == "":
                data[k] = None

        super().__init__(**data)


class FailedClosePositionDetails(BaseModel):
    """API response for failed close position request.

    Attributes:
        available (float): The qty available.
        code (int): The status code.
        existing_qty (float): The total qty in account.
        held_for_orders (float): The qty locked up in existing orders.
        message (str): Message for failed request.
        symbol (str): The symbol for the request.
    """

    code: int
    message: str
    available: Optional[float] = None
    existing_qty: Optional[float] = None
    held_for_orders: Optional[float] = None
    symbol: Optional[str] = None


class ClosePositionResponse(BaseModel):
    """API response for a close position request.
    Attributes:
        order_id (Optional[UUID]): ID of order that was created to liquidate the position.
        status (Optional[int]): Status code corresponding to the request to liquidate the position.
        symbol (Optional[str]): The symbol of the position being closed.
        body (Optional[dict]): Information relating to the successful or unsuccessful closing of the position.
    """

    order_id: Optional[UUID] = None
    status: Optional[int] = None
    symbol: Optional[str] = None
    body: Union[FailedClosePositionDetails, Order]


class PortfolioHistory(BaseModel):
    """
    Contains information about the value of a portfolio over time.

    Attributes:
        timestamp (List[int]): Time of each data element, left-labeled (the beginning of time window).
        equity (List[float]): Equity value of the account in dollar amount as of the end of each time window.
        profit_loss (List[float]): Profit/loss in dollar from the base value.
        profit_loss_pct (List[Optional[float]]): Profit/loss in percentage from the base value.
        base_value (float): Basis in dollar of the profit loss calculation.
        timeframe (str): Time window size of each data element.
        cashflow (Dict[ActivityType, List[float]]): Cash flow amounts per activity type, if any.
    """

    timestamp: List[int]
    equity: List[float]
    profit_loss: List[float]
    profit_loss_pct: List[Optional[float]]
    base_value: float
    timeframe: str
    cashflow: Dict[ActivityType, List[float]] = {}


class Watchlist(ModelWithID):
    """
    A watchlist is an ordered list of assets. An account can have multiple watchlists.
    Learn more about watchlists in the documentation. https://alpaca.markets/docs/api-references/trading-api/watchlist/

    Attributes:
        account_id (UUID): The uuid identifying the account the watchlist belongs to
        id (UUID): The unique identifier for the watchlist
        name (str): An arbitrary string up to 64 characters identifying the watchlist
        created_at (datetime): When the watchlist was created
        updated_at (datetime): When the watchlist was last updated
        assets (Optional[List[Asset]]): The assets in the watchlist, not returned from all endpoints
    """

    account_id: UUID
    name: str
    created_at: datetime
    updated_at: datetime
    assets: Optional[List[Asset]] = None


class Clock(BaseModel):
    """
    The market clock for US equity markets. Timestamps are in eastern time.

    Attributes:
        timestamp (datetime): The current timestamp.
        is_open (bool): Whether the market is currently open.
        next_open (datetime): The timestamp when the market will next open.
        next_close (datetime): The timestamp when the market will next close.
    """

    timestamp: datetime
    is_open: bool
    next_open: datetime
    next_close: datetime


class Calendar(BaseModel):
    """
    The market calendar for equity markets. Describes the market open and close time on a given day.
    """

    date: date
    open: datetime
    close: datetime

    def __init__(self, **data: Any) -> None:
        """
            Converts open and close time strings from %H:%M to a datetime
        Args:
            **data: The raw calendar data from API
        """
        if "date" in data and "open" in data:
            start_datetime_str = data["date"] + " " + data["open"]
            data["open"] = datetime.strptime(start_datetime_str, "%Y-%m-%d %H:%M")

        if "date" in data and "close" in data:
            start_datetime_str = data["date"] + " " + data["close"]
            data["close"] = datetime.strptime(start_datetime_str, "%Y-%m-%d %H:%M")

        super().__init__(**data)


class BaseActivity(BaseModel):
    """
    Represents Base information for an event/activity for a specific Account.

    You most likely will want an instance of one of the child classes TradeActivity and NonTradeActivity

    Attributes:
        id (str): Unique ID of this Activity. Note that IDs for Activity instances are formatted like
          `20220203000000000::045b3b8d-c566-4bef-b741-2bf598dd6ae7` the first part before the `::` is a date string
          while the part after is a UUID
        account_id (UUID): id of the Account this activity relates too
        activity_type (ActivityType): What specific kind of Activity this was
    """

    id: str
    account_id: UUID
    activity_type: ActivityType

    def __init__(self, *args, **data):
        if "account_id" in data and type(data["account_id"]) == str:
            data["account_id"] = UUID(data["account_id"])

        super().__init__(*args, **data)


class NonTradeActivity(BaseActivity):
    """
    A NonTradeActivity represents an Activity that happened for an account that doesn't have to do with orders or trades.

    Attributes:
        date (date): The date on which the activity occurred or on which the transaction associated with the
          activity settled.
        net_amount (float): The net amount of money (positive or negative) associated with the activity.
        description (str): Extra description of the NTA if needed. Can be empty string ""
        status (NonTradeActivityStatus): Status of the activity. Not present for all activity types.
        symbol (Optional[str]): The symbol of the security involved with the activity. Not present for all activity
          types.
        qty (Optional[float]): For dividend activities, the number of shares that contributed to the payment. Not
          present for other activity types.
        price (Optional[float]) Not present for all activity types.
        per_share_amount (Optional[float]): For dividend activities, the average amount paid per share. Not present for
          other activity types.
    """

    date: date
    net_amount: float
    description: str
    status: Optional[NonTradeActivityStatus] = None
    symbol: Optional[str] = None
    qty: Optional[float] = None
    price: Optional[float] = None
    per_share_amount: Optional[float] = None


class TradeActivity(BaseActivity):
    """
    Represents information for TradeActivities. TradeActivities are Activities that pertain to trades that happened for
    an account. IE Fills or partial fills for orders.

    Attributes:
        transaction_time (datetime): The time and date of when this trade was processed
        type (TradeActivityType): What kind of trade this TradeActivity represents. See TradeActivityType for more
          details
        price (float): The per-share price that the trade was executed at.
        qty (float): The number of shares involved in the trade execution.
        side (OrderSide): What side the trade this TradeActivity represents was on. See OrderSide for more information
        symbol (str): The symbol of the asset that was traded
        leaves_qty (float): For partially filled orders, the quantity of shares that are left to be filled. Will be 0 if
          order was not a partially filled order
        order_id (UUID): The ID for the order filled
        cum_qty (float): The cumulative quantity of shares involved in the execution.
        order_status (OrderStatus): The status of the order that executed the trade. See OrderStatus for more details
    """

    transaction_time: datetime
    type: TradeActivityType
    price: float
    qty: float
    side: OrderSide
    symbol: str
    leaves_qty: float
    order_id: UUID
    cum_qty: float
    order_status: OrderStatus


class TradeAccount(ModelWithID):
    """
    Represents trading account information for an Account.

    Attributes:
        id (UUID): The account ID
        account_number (str): The account number
        status (AccountStatus): The current status of the account
        crypto_status (Optional[AccountStatus]): The status of the account in regards to trading crypto. Only present if
          crypto trading is enabled for your brokerage account.
        currency (Optional[str]): Currently will always be the value "USD".
        buying_power (Optional[str]): Current available cash buying power. If multiplier = 2 then
          buying_power = max(equity-initial_margin(0) * 2). If multiplier = 1 then buying_power = cash.
        regt_buying_power (Optional[str]): User‚Äôs buying power under Regulation T
          (excess equity - (equity - margin value) - * margin multiplier)
        daytrading_buying_power (Optional[str]): The buying power for day trades for the account
        non_marginable_buying_power (Optional[str]): The non marginable buying power for the account
        cash (Optional[str]): Cash balance in the account
        accrued_fees (Optional[str]): Fees accrued in this account
        pending_transfer_out (Optional[str]): Cash pending transfer out of this account
        pending_transfer_in (Optional[str]): Cash pending transfer into this account
        portfolio_value (str): Total value of cash + holding positions.
          (This field is deprecated. It is equivalent to the equity field.)
        pattern_day_trader (Optional[bool]): Whether the account is flagged as pattern day trader or not.
        trading_blocked (Optional[bool]): If true, the account is not allowed to place orders.
        transfers_blocked (Optional[bool]): If true, the account is not allowed to request money transfers.
        account_blocked (Optional[bool]): If true, the account activity by user is prohibited.
        created_at (Optional[datetime]): Timestamp this account was created at
        trade_suspended_by_user (Optional[bool]): If true, the account is not allowed to place orders.
        multiplier (Optional[str]): Multiplier value for this account.
        shorting_enabled (Optional[bool]): Flag to denote whether or not the account is permitted to short
        equity (Optional[str]): This value is cash + long_market_value + short_market_value. This value isn't calculated in the
          SDK it is computed on the server and we return the raw value here.
        last_equity (Optional[str]): Equity as of previous trading day at 16:00:00 ET
        long_market_value (Optional[str]): Real-time MtM value of all long positions held in the account
        short_market_value (Optional[str]): Real-time MtM value of all short positions held in the account
        initial_margin (Optional[str]): Reg T initial margin requirement
        maintenance_margin (Optional[str]): Maintenance margin requirement
        last_maintenance_margin (Optional[str]): Maintenance margin requirement on the previous trading day
        sma (Optional[str]): Value of Special Memorandum Account (will be used at a later date to provide additional buying_power)
        daytrade_count (Optional[int]): The current number of daytrades that have been made in the last 5 trading days
          (inclusive of today)
        options_buying_power (Optional[str]): Your buying power for options trading
        options_approved_level (Optional[int]): The options trading level that was approved for this account.
          0=disabled, 1=Covered Call/Cash-Secured Put, 2=Long Call/Put, 3=Spreads/Straddles.
        options_trading_level (Optional[int]): The effective options trading level of the account. This is the minimum between account options_approved_level and account configurations max_options_trading_level.
          0=disabled, 1=Covered Call/Cash-Secured Put, 2=Long, 3=Spreads/Straddles.
    """

    account_number: str
    status: AccountStatus
    crypto_status: Optional[AccountStatus] = None
    currency: Optional[str] = None
    buying_power: Optional[str] = None
    regt_buying_power: Optional[str] = None
    daytrading_buying_power: Optional[str] = None
    non_marginable_buying_power: Optional[str] = None
    cash: Optional[str] = None
    accrued_fees: Optional[str] = None
    pending_transfer_out: Optional[str] = None
    pending_transfer_in: Optional[str] = None
    portfolio_value: Optional[str] = None
    pattern_day_trader: Optional[bool] = None
    trading_blocked: Optional[bool] = None
    transfers_blocked: Optional[bool] = None
    account_blocked: Optional[bool] = None
    created_at: Optional[datetime] = None
    trade_suspended_by_user: Optional[bool] = None
    multiplier: Optional[str] = None
    shorting_enabled: Optional[bool] = None
    equity: Optional[str] = None
    last_equity: Optional[str] = None
    long_market_value: Optional[str] = None
    short_market_value: Optional[str] = None
    initial_margin: Optional[str] = None
    maintenance_margin: Optional[str] = None
    last_maintenance_margin: Optional[str] = None
    sma: Optional[str] = None
    daytrade_count: Optional[int] = None
    options_buying_power: Optional[str] = None
    options_approved_level: Optional[int] = None
    options_trading_level: Optional[int] = None


class AccountConfiguration(BaseModel):
    """
    Represents configuration options for a TradeAccount.

    Attributes:
        dtbp_check (DTBPCheck): Day Trade Buying Power Check. Controls Day Trading Margin Call (DTMC) checks.
        fractional_trading (bool): If true, account is able to participate in fractional trading
        max_margin_multiplier (str): A number between 1-4 that represents your max margin multiplier
        no_shorting (bool): If true then Account becomes long-only mode.
        pdt_check (PDTCheck): Controls Pattern Day Trader (PDT) checks.
        suspend_trade (bool): If true Account becomes unable to submit new orders
        trade_confirm_email (TradeConfirmationEmail): Controls whether Trade confirmation emails are sent.
        ptp_no_exception_entry (bool): If set to true then Alpaca will accept orders for PTP symbols with no exception. Default is false.
        max_options_trading_level (Optional[int]): The desired maximum options trading level. 0=disabled, 1=Covered Call/Cash-Secured Put, 2=Long Call/Put, 3=Spreads/Straddles.
    """

    dtbp_check: DTBPCheck
    fractional_trading: bool
    max_margin_multiplier: str
    no_shorting: bool
    pdt_check: PDTCheck
    suspend_trade: bool
    trade_confirm_email: TradeConfirmationEmail
    ptp_no_exception_entry: bool
    max_options_trading_level: Optional[int] = None


class CorporateActionAnnouncement(ModelWithID):
    """
    An announcement of a corporate action. Corporate actions are events like dividend payouts, mergers and stock splits.

    Attributes:
        id (UUID): The unique identifier for this single announcement.
        corporate_action_id (str): ID that remains consistent across all announcements for the same corporate action.
        ca_type (CorporateActionType): The type of corporate action that was announced.
        ca_sub_type (CorporateActionSubType): The specific subtype of corporate action that was announced.
        initiating_symbol (str): Symbol of the company initiating the announcement.
        initiating_original_cusip (str): CUSIP of the company initiating the announcement.
        target_symbol (Optional[str]): Symbol of the child company involved in the announcement.
        target_original_cusip (Optional[str]): CUSIP of the child company involved in the announcement.
        declaration_date (Optional[date]): Date the corporate action or subsequent terms update was announced.
        ex_date (Optional[date]): The first date that purchasing a security will not result in a corporate action entitlement.
        record_date (Optional[date]): The date an account must hold a settled position in the security in order to receive the
            corporate action entitlement.
        payable_date (Optional[date]): The date the announcement will take effect. On this date, account stock and cash
            balances are expected to be processed accordingly.
        cash (float): The amount of cash to be paid per share held by an account on the record date.
        old_rate (float): The denominator to determine any quantity change ratios in positions.
        new_rate (float): The numerator to determine any quantity change ratios in positions.
    """

    corporate_action_id: str
    ca_type: CorporateActionType
    ca_sub_type: CorporateActionSubType
    initiating_symbol: str
    initiating_original_cusip: str
    target_symbol: Optional[str] = None
    target_original_cusip: Optional[str] = None
    declaration_date: Optional[date] = None
    ex_date: Optional[date] = None
    record_date: Optional[date] = None
    payable_date: Optional[date] = None
    cash: float
    old_rate: float
    new_rate: float


class TradeUpdate(BaseModel):
    """
    Represents a trade update.

    ref. https://docs.alpaca.markets/docs/websocket-streaming#example
    """

    event: Union[TradeEvent, str]
    execution_id: Optional[UUID] = None
    order: Order
    timestamp: datetime
    position_qty: Optional[float] = None
    price: Optional[float] = None
    qty: Optional[float] = None


class OptionContract(BaseModel):
    """
    Represents an option contract.

    Attributes:
        id (str): The unique identifier of the option contract.
        symbol (str): The symbol representing the option contract.
        name (str): The name of the option contract.
        status (AssetStatus): The status of the option contract.
        tradable (bool): Indicates whether the option contract is tradable.
        expiration_date (date): The expiration date of the option contract.
        root_symbol (str): The root symbol of the option contract.
        underlying_symbol (str): The underlying symbol of the option contract.
        underlying_asset_id (UUID): The unique identifier of the underlying asset.
        type (ContractType): The type of the option contract.
        style (ExerciseStyle): The style of the option contract.
        strike_price (float): The strike price of the option contract.
        size (str): The size of the option contract. Usually contracts have size=100.
        open_interest (Optional[str]): The open interest of the option contract.
        open_interest_date (Optional[date]): The date of the open interest data.
        close_price (Optional[str]): The close price of the option contract.
        close_price_date (Optional[date]): The date of the close price data.
    """

    id: str
    symbol: str
    name: str
    status: AssetStatus
    tradable: bool
    expiration_date: date
    root_symbol: str
    underlying_symbol: str
    underlying_asset_id: UUID
    type: ContractType
    style: ExerciseStyle
    strike_price: float
    size: str
    open_interest: Optional[str] = None
    open_interest_date: Optional[date] = None
    close_price: Optional[str] = None
    close_price_date: Optional[date] = None


class OptionContractsResponse(BaseModel):
    """
    Represents a response from the option contracts endpoint.

    Attributes:
        option_contracts (Optional[List[OptionContract]]): The list of option contracts.
        next_page_token (Optional[str]): Pagination token for next page.
    """

    option_contracts: Optional[List[OptionContract]] = None
    next_page_token: Optional[str] = None
````

## File: alpaca/trading/requests.py
````python
from datetime import date, datetime, timedelta
from typing import Any, Dict, List, Optional, Union

import pandas as pd
from pydantic import model_validator

from alpaca.common.enums import Sort
from alpaca.common.models import ModelWithID
from alpaca.common.requests import NonEmptyRequest
from alpaca.trading.enums import (
    AssetClass,
    AssetExchange,
    AssetStatus,
    ContractType,
    CorporateActionDateType,
    CorporateActionType,
    ExerciseStyle,
    OrderClass,
    OrderSide,
    OrderType,
    PositionIntent,
    QueryOrderStatus,
    TimeInForce,
)


class ClosePositionRequest(NonEmptyRequest):
    """
    Attributes:
        qty (str): The number of shares to liquidate.
        percentage (str): The percentage of shares to liquidate.
    """

    qty: Optional[str] = None
    percentage: Optional[str] = None

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        qty = values.get("qty", None)
        percentage = values.get("percentage", None)
        if qty is None and percentage is None:
            raise ValueError(
                "qty or percentage must be given to the ClosePositionRequest, got None for both."
            )

        if qty is not None and percentage is not None:
            raise ValueError(
                "Only one of qty or percentage must be given to the ClosePositionRequest, got both."
            )

        return values


class GetPortfolioHistoryRequest(NonEmptyRequest):
    """
    Attributes:
        period (Optional[str]): The duration of the data in number + unit, such as 1D. unit can be D for day, W for
          week, M for month and A for year. Defaults to 1M.
        timeframe (Optional[str]): The resolution of time window. 1Min, 5Min, 15Min, 1H, or 1D. If omitted, 1Min for
          less than 7 days period, 15Min for less than 30 days, or otherwise 1D.
        intraday_reporting (Optional[str]): this specfies which timestamps to return data points
        start (Optional[datetime]): The timestamp the data is returned starting from in RFC3339 format (including timezone specification).
        pnl_reset (Optional[str]): efines how we are calculating the baseline values for Profit And Loss (pnl) for queries with timeframe less than 1D (intraday queries).
        end (Optional[datetime]): The timestamp the data is returned up to in RFC3339 format (including timezone specification).
        date_end (Optional[date]): The date the data is returned up to. Defaults to the current market date (rolls over
          at the market open if extended_hours is false, otherwise at 7am ET).
        extended_hours (Optional[bool]): If true, include extended hours in the result. This is effective only for
          timeframe less than 1D.
        cashflow_types (Optional[str]): The cashflow activities to include in the report
    """

    period: Optional[str] = None
    timeframe: Optional[str] = None
    intraday_reporting: Optional[str] = None
    start: Optional[datetime] = None
    pnl_reset: Optional[str] = None
    end: Optional[datetime] = None
    date_end: Optional[date] = None
    extended_hours: Optional[bool] = None
    cashflow_types: Optional[str] = None


class GetCalendarRequest(NonEmptyRequest):
    """
    Represents the optional filtering you can do when requesting a Calendar object
    """

    start: Optional[date] = None
    end: Optional[date] = None


class CreateWatchlistRequest(NonEmptyRequest):
    """
    Represents the fields you can specify when creating a Watchlist

    Attributes:
        name(str): Name of the Watchlist
        symbols(List[str]): Symbols of Assets to watch
    """

    name: str
    symbols: List[str]


class UpdateWatchlistRequest(NonEmptyRequest):
    """
    Represents the fields you can specify when updating a Watchlist

    Attributes:
        name(Optional[str]): Name of the Watchlist
        symbols(Optional[List[str]]): Symbols of Assets to watch
    """

    name: Optional[str] = None
    symbols: Optional[List[str]] = None

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        if ("name" not in values or values["name"] is None) and (
            "symbols" not in values or values["symbols"] is None
        ):
            raise ValueError("One of 'name' or 'symbols' must be defined")

        return values


class GetAssetsRequest(NonEmptyRequest):
    """
    When querying for available assets, this model provides the parameters that can be filtered by.

    Attributes:
        status (Optional[AssetStatus]): The active status of the asset.
        asset_class (Optional[AssetClass]): The type of asset (i.e. us_equity, crypto).
        exchange (Optional[AssetExchange]): The exchange the asset trades on.
        attributes (Optional[str]): Comma separated values to query for more than one attribute.
    """

    status: Optional[AssetStatus] = None
    asset_class: Optional[AssetClass] = None
    exchange: Optional[AssetExchange] = None
    attributes: Optional[str] = None


class TakeProfitRequest(NonEmptyRequest):
    """
    Used for providing take profit details for a bracket order.

    Attributes:
        limit_price (float): The execution price for exiting a profitable trade.
    """

    limit_price: float


class StopLossRequest(NonEmptyRequest):
    """
    Used for providing stop loss details for a bracket order.

    Attributes:
        stop_price (float): The price at which the stop loss is triggered.
        limit_price (Optional[float]): The execution price for exiting a losing trade. If not provided, the
            stop loss will execute as a market order.
    """

    stop_price: float
    limit_price: Optional[float] = None


class OptionLegRequest(NonEmptyRequest):
    """
    Used for providing details for a leg of a multi-leg order.

    Attributes:
        symbol (str): The symbol identifier for the asset being traded.
        ratio_qty (float): The proportional quantity of this leg in relation to the overall multi-leg order quantity.
        side (Optional[OrderSide]): Represents the side this order was on.
        position_intent (Optional[PositionIntent]): Represents the position strategy for this leg.
    """

    symbol: str
    ratio_qty: float
    side: Optional[OrderSide] = None
    position_intent: Optional[PositionIntent] = None

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        side = values.get("side", None)
        position_intent = values.get("position_intent", None)

        if side is None and position_intent is None:
            raise ValueError(
                "at least one of side or position_intent must be provided for OptionLegRequest"
            )

        return values


class GetOrdersRequest(NonEmptyRequest):
    """Contains data for submitting a request to retrieve orders.

    Attributes:
        status (Optional[QueryOrderStatus]): Order status to be queried. open, closed or all. Defaults to open. Not same as OrderStatus property of Order.
        limit (Optional[int]): The maximum number of orders in response. Defaults to 50 and max is 500.
        after (Optional[datetime]): The response will include only ones submitted after this timestamp.
        until (Optional[datetime]): The response will include only ones submitted until this timestamp.
        direction (Optional[Sort]): The chronological order of response based on the submission time. asc or desc. Defaults to desc.
        nested (Optional[bool]): If true, the result will roll up multi-leg orders under the legs field of primary order.
        side (Optional[OrderSide]): Filters down to orders that have a matching side field set.
        symbols (Optional[List[str]]): List of symbols to filter by.
    """

    status: Optional[QueryOrderStatus] = None
    limit: Optional[int] = None  # not pagination = None
    after: Optional[datetime] = None
    until: Optional[datetime] = None
    direction: Optional[Sort] = None
    nested: Optional[bool] = None
    side: Optional[OrderSide] = None
    symbols: Optional[List[str]] = None


class GetOrderByIdRequest(NonEmptyRequest):
    """Contains data for submitting a request to retrieve a single order by its order id.

    Attributes:
        nested (bool): If true, the result will roll up multi-leg orders under the legs field of primary order.
    """

    nested: bool


class ReplaceOrderRequest(NonEmptyRequest):
    """Contains data for submitting a request to replace an order.

    Attributes:
        qty (Optional[int]): Number of shares to trade
        time_in_force (Optional[TimeInForce]): The new expiration logic of the order.
        limit_price (Optional[float]): Required if type of order being replaced is limit or stop_limit
        stop_price (Optional[float]): Required if type of order being replaced is stop or stop_limit
        trail (Optional[float]): The new value of the trail_price or trail_percent value (works only for type=‚Äútrailing_stop‚Äù)
        client_order_id (Optional[str]): A unique identifier for the order.
    """

    qty: Optional[int] = None
    time_in_force: Optional[TimeInForce] = None
    limit_price: Optional[float] = None
    stop_price: Optional[float] = None
    trail: Optional[float] = None
    client_order_id: Optional[str] = None

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        qty = values.get("qty", None)
        limit_price = values.get("limit_price", None)
        stop_price = values.get("stop_price", None)
        trail = values.get("trail", None)

        if (qty is not None) and (qty <= 0):
            raise ValueError("qty must be greater than 0")
        if (limit_price is not None) and (limit_price <= 0):
            raise ValueError("limit_price must be greater than 0")
        if (stop_price is not None) and (stop_price <= 0):
            raise ValueError("stop_price must be greater than 0")
        if (trail is not None) and (trail <= 0):
            raise ValueError("trail must be greater than 0")

        return values


class CancelOrderResponse(ModelWithID):
    """
    Data returned after requesting to cancel an order. It contains the cancel status of an order.

    Attributes:
        id (UUID): The order id
        status (int): The HTTP status returned after attempting to cancel the order.
        body (Dict[str, Any]): an error description
    """

    status: int
    body: Optional[Dict[str, Any]] = None


class OrderRequest(NonEmptyRequest):
    """A base class for requests for creating an order. You probably shouldn't directly use
    this class when submitting an order. Instead, use one of the order type specific classes.

    Attributes:
        symbol (str): The symbol identifier for the asset being traded. Required for all order classes other than
            mleg.
        qty (Optional[float]): The number of shares to trade. Fractional qty for stocks only with market orders.
            Required for mleg order class.
        notional (Optional[float]): The base currency value of the shares to trade. For stocks, only works with MarketOrders.
            **Does not work with qty**.
        side (Optional[OrderSide]): Whether the order will buy or sell the asset. Either side or position_intent is required for all order classes other than mleg.
        type (OrderType): The execution logic type of the order (market, limit, etc).
        time_in_force (TimeInForce): The expiration logic of the order.
        extended_hours (Optional[float]): Whether the order can be executed during regular market hours.
        client_order_id (Optional[str]): A string to identify which client submitted the order.
        order_class (Optional[OrderClass]): The class of the order. Simple orders have no other legs.
        legs (Optional[List[OptionLegRequest]]): For multi-leg option orders, the legs of the order If specified (must contain at least 2 but no more than 4 legs for options).
            Otherwise, for equities, a list of individual orders.
        take_profit (Optional[TakeProfitRequest]): For orders with multiple legs, an order to exit a profitable trade.
        stop_loss (Optional[StopLossRequest]): For orders with multiple legs, an order to exit a losing trade.
        position_intent (Optional[PositionIntent]): An enum to indicate the desired position strategy: BTO, BTC, STO, STC.
    """

    symbol: Optional[str] = None
    qty: Optional[float] = None
    notional: Optional[float] = None
    side: Optional[OrderSide] = None
    type: OrderType
    time_in_force: TimeInForce
    order_class: Optional[OrderClass] = None
    extended_hours: Optional[bool] = None
    client_order_id: Optional[str] = None
    legs: Optional[List[OptionLegRequest]] = None
    take_profit: Optional[TakeProfitRequest] = None
    stop_loss: Optional[StopLossRequest] = None
    position_intent: Optional[PositionIntent] = None

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        qty_set = "qty" in values and values["qty"] is not None
        notional_set = "notional" in values and values["notional"] is not None

        if not qty_set and not notional_set:
            raise ValueError("At least one of qty or notional must be provided")
        elif qty_set and notional_set:
            raise ValueError("Both qty and notional can not be set.")

        # mleg-related checks
        if "order_class" in values and values["order_class"] == OrderClass.MLEG:
            if not qty_set:
                raise ValueError("qty is required for the mleg order class.")
            if "legs" not in values or values["legs"] is None:
                raise ValueError("legs is required for the mleg order class.")
            l_len = len(values["legs"])
            if l_len > 4:
                raise ValueError("At most 4 legs are allowed for the mleg order class.")
            if l_len < 2:
                raise ValueError(
                    "At least 2 legs are required for the mleg order class."
                )
            n_unique = len(set([l.symbol for l in values["legs"]]))
            if n_unique != l_len:
                raise ValueError("All legs must have unique symbols.")
        else:
            if "symbol" not in values or values["symbol"] is None:
                raise ValueError(
                    "symbol is required for all order classes other than mleg."
                )
            if "side" not in values or values["side"] is None:
                raise ValueError(
                    "side is required for all order classes other than mleg."
                )

        return values


class MarketOrderRequest(OrderRequest):
    """
    Used to submit a market order.

    Attributes:
        symbol (str): The symbol identifier for the asset being traded. Required for all order classes other than
            mleg.
        qty (Optional[float]): The number of shares to trade. Fractional qty for stocks only with market orders.
        notional (Optional[float]): The base currency value of the shares to trade. For stocks, only works with MarketOrders.
            **Does not work with qty**.
        side (OrderSide): Whether the order will buy or sell the asset. Required for all order classes other than mleg.
        type (OrderType): The execution logic type of the order (market, limit, etc).
        time_in_force (TimeInForce): The expiration logic of the order.
        extended_hours (Optional[float]): Whether the order can be executed during regular market hours.
        client_order_id (Optional[str]): A string to identify which client submitted the order.
        order_class (Optional[OrderClass]): The class of the order. Simple orders have no other legs.
        legs (Optional[List[OptionLegRequest]]): For multi-leg option orders, the legs of the order. At most 4 legs are allowed for options.
        take_profit (Optional[TakeProfitRequest]): For orders with multiple legs, an order to exit a profitable trade.
        stop_loss (Optional[StopLossRequest]): For orders with multiple legs, an order to exit a losing trade.
        position_intent (Optional[PositionIntent]): An enum to indicate the desired position strategy: BTO, BTC, STO, STC.
    """

    def __init__(self, **data: Any) -> None:
        data["type"] = OrderType.MARKET

        super().__init__(**data)


class StopOrderRequest(OrderRequest):
    """
    Used to submit a stop order.

    Attributes:
        symbol (str): The symbol identifier for the asset being traded
        qty (Optional[float]): The number of shares to trade. Fractional qty for stocks only with market orders.
        notional (Optional[float]): The base currency value of the shares to trade. For stocks, only works with MarketOrders.
            **Does not work with qty**.
        side (OrderSide): Whether the order will buy or sell the asset.
        type (OrderType): The execution logic type of the order (market, limit, etc).
        time_in_force (TimeInForce): The expiration logic of the order.
        extended_hours (Optional[float]): Whether the order can be executed during regular market hours.
        client_order_id (Optional[str]): A string to identify which client submitted the order.
        order_class (Optional[OrderClass]): The class of the order. Simple orders have no other legs.
        legs (Optional[List[OptionLegRequest]]): For multi-leg option orders, the legs of the order. At most 4 legs are allowed for options.
        take_profit (Optional[TakeProfitRequest]): For orders with multiple legs, an order to exit a profitable trade.
        stop_loss (Optional[StopLossRequest]): For orders with multiple legs, an order to exit a losing trade.
        stop_price (float): The price at which the stop order is converted to a market order or a stop limit
            order is converted to a limit order.
        position_intent (Optional[PositionIntent]): An enum to indicate the desired position strategy: BTO, BTC, STO, STC.
    """

    stop_price: float

    def __init__(self, **data: Any) -> None:
        data["type"] = OrderType.STOP

        super().__init__(**data)


class LimitOrderRequest(OrderRequest):
    """
    Used to submit a limit order.

    Attributes:
        symbol (str): The symbol identifier for the asset being traded
        qty (Optional[float]): The number of shares to trade. Fractional qty for stocks only with market orders.
        notional (Optional[float]): The base currency value of the shares to trade. For stocks, only works with MarketOrders.
            **Does not work with qty**.
        side (OrderSide): Whether the order will buy or sell the asset.
        type (OrderType): The execution logic type of the order (market, limit, etc).
        time_in_force (TimeInForce): The expiration logic of the order.
        extended_hours (Optional[float]): Whether the order can be executed during regular market hours.
        client_order_id (Optional[str]): A string to identify which client submitted the order.
        order_class (Optional[OrderClass]): The class of the order. Simple orders have no other legs.
        legs (Optional[List[OptionLegRequest]]): For multi-leg option orders, the legs of the order. At most 4 legs are allowed for options.
        take_profit (Optional[TakeProfitRequest]): For orders with multiple legs, an order to exit a profitable trade.
        stop_loss (Optional[StopLossRequest]): For orders with multiple legs, an order to exit a losing trade.
        limit_price (Optional[float]): The worst fill price for a limit or stop limit order. For the mleg order class, this
            is specified such that a positive value indicates a debit (representing a cost or payment to be made) while a
            negative value signifies a credit (reflecting an amount to be received).
        position_intent (Optional[PositionIntent]): An enum to indicate the desired position strategy: BTO, BTC, STO, STC.
    """

    limit_price: Optional[float] = None

    def __init__(self, **data: Any) -> None:
        data["type"] = OrderType.LIMIT

        super().__init__(**data)

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        # noinspection PyCallingNonCallable
        super().root_validator(values)
        if values.get("order_class", "") != OrderClass.OCO:
            limit_price = values.get("limit_price", None)
            if limit_price is None:
                raise ValueError("limit_price is required")
        return values


class StopLimitOrderRequest(OrderRequest):
    """
    Used to submit a stop limit order.

    Attributes:
        symbol (str): The symbol identifier for the asset being traded
        qty (Optional[float]): The number of shares to trade. Fractional qty for stocks only with market orders.
        notional (Optional[float]): The base currency value of the shares to trade. For stocks, only works with MarketOrders.
            **Does not work with qty**.
        side (OrderSide): Whether the order will buy or sell the asset.
        type (OrderType): The execution logic type of the order (market, limit, etc).
        time_in_force (TimeInForce): The expiration logic of the order.
        extended_hours (Optional[float]): Whether the order can be executed during regular market hours.
        client_order_id (Optional[str]): A string to identify which client submitted the order.
        order_class (Optional[OrderClass]): The class of the order. Simple orders have no other legs.
        legs (Optional[List[OptionLegRequest]]): For multi-leg option orders, the legs of the order. At most 4 legs are allowed for options.
        take_profit (Optional[TakeProfitRequest]): For orders with multiple legs, an order to exit a profitable trade.
        stop_loss (Optional[StopLossRequest]): For orders with multiple legs, an order to exit a losing trade.
        stop_price (float): The price at which the stop order is converted to a market order or a stop limit
            order is converted to a limit order.
        limit_price (float): The worst fill price for a limit or stop limit order. For the mleg order class, this
            is specified such that a positive value indicates a debit (representing a cost or payment to be made) while a
            negative value signifies a credit (reflecting an amount to be received).
        position_intent (Optional[PositionIntent]): An enum to indicate the desired position strategy: BTO, BTC, STO, STC.
    """

    stop_price: float
    limit_price: float

    def __init__(self, **data: Any) -> None:
        data["type"] = OrderType.STOP_LIMIT

        super().__init__(**data)


class TrailingStopOrderRequest(OrderRequest):
    """
    Used to submit a trailing stop order.

    Attributes:
        symbol (str): The symbol identifier for the asset being traded
        qty (Optional[float]): The number of shares to trade. Fractional qty for stocks only with market orders.
        notional (Optional[float]): The base currency value of the shares to trade. For stocks, only works with MarketOrders.
            **Does not work with qty**.
        side (OrderSide): Whether the order will buy or sell the asset.
        type (OrderType): The execution logic type of the order (market, limit, etc).
        time_in_force (TimeInForce): The expiration logic of the order.
        extended_hours (Optional[float]): Whether the order can be executed during regular market hours.
        client_order_id (Optional[str]): A string to identify which client submitted the order.
        order_class (Optional[OrderClass]): The class of the order. Simple orders have no other legs.
        legs (Optional[List[OptionLegRequest]]): For multi-leg option orders, the legs of the order. At most 4 legs are allowed for options.
        take_profit (Optional[TakeProfitRequest]): For orders with multiple legs, an order to exit a profitable trade.
        stop_loss (Optional[StopLossRequest]): For orders with multiple legs, an order to exit a losing trade.
        trail_price (Optional[float]): The absolute price difference by which the trailing stop will trail.
        trail_percent (Optional[float]): The percent price difference by which the trailing stop will trail.
        position_intent (Optional[PositionIntent]): An enum to indicate the desired position strategy: BTO, BTC, STO, STC.
    """

    trail_price: Optional[float] = None
    trail_percent: Optional[float] = None

    def __init__(self, **data: Any) -> None:
        data["type"] = OrderType.TRAILING_STOP

        super().__init__(**data)

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        # noinspection PyCallingNonCallable
        super().root_validator(values)
        trail_percent_set = (
            "trail_percent" in values and values["trail_percent"] is not None
        )
        trail_price_set = "trail_price" in values and values["trail_price"] is not None

        if not trail_percent_set and not trail_price_set:
            raise ValueError(
                "Either trail_percent or trail_price must be set for a trailing stop order."
            )
        elif trail_percent_set and trail_price_set:
            raise ValueError("Both trail_percent and trail_price cannot be set.")

        return values


class GetCorporateAnnouncementsRequest(NonEmptyRequest):
    """
    Contains parameters for querying corporate action data.
    Attributes:
        ca_types (List[CorporateActionType]): A list of corporate action types.
        since (date): The start (inclusive) of the date range when searching corporate action announcements.
            The date range is limited to 90 days.
        until (date): The end (inclusive) of the date range when searching corporate action announcements.
            The date range is limited to 90 days.
        symbol (Optional[str]): The symbol of the company initiating the announcement.
        cusip (Optional[str]): The CUSIP of the company initiating the announcement.
        date_type (Optional[CorporateActionDateType]): The date type for the announcement.
    """

    ca_types: List[CorporateActionType]
    since: date
    until: date
    symbol: Optional[str] = None
    cusip: Optional[str] = None
    date_type: Optional[CorporateActionDateType] = None

    @model_validator(mode="before")
    def root_validator(cls, values: dict) -> dict:
        since = pd.Timestamp(values.get("since")).date()
        until = pd.Timestamp(values.get("until")).date()

        if (
            since is not None
            and until is not None
            and (until - since) > timedelta(days=90)
        ):
            raise ValueError("The date range is limited to 90 days.")

        return values


class GetOptionContractsRequest(NonEmptyRequest):
    """
    Used to fetch option contracts for a given underlying symbol.

    Attributes:
        underlying_symbols (Optional[List[str]]): The underlying symbols for the option contracts to be returned. (e.g. ["AAPL", "SPY"])
        status (Optional[AssetStatus]): The status of the asset.
        expiration_date (Optional[Union[date, str]]): The expiration date of the option contract. (YYYY-MM-DD)
        expiration_date_gte (Optional[Union[date, str]]): The expiration date of the option contract greater than or equal to. (YYYY-MM-DD)
        expiration_date_lte (Optional[Union[date, str]]): The expiration date of the option contract less than or equal to. (YYYY-MM-DD)
        root_symbol (Optional[str]): The option root symbol.
        type (Optional[ContractType]): The option contract type.
        style (Optional[ExerciseStyle]): The option contract style.
        strike_price_gte (Optional[str]): The option contract strike price greater than or equal to.
        strike_price_lte (Optional[str]): The option contract strike price less than or equal to.
        limit (Optional[int]): The number of contracts to limit per page (default=100, max=10000).
        page_token (Optional[str]): Pagination token to continue from. The value to pass here is returned in specific
            requests when more data is available than the request limit allows.
    """

    underlying_symbols: Optional[List[str]] = None
    status: Optional[AssetStatus] = AssetStatus.ACTIVE
    expiration_date: Optional[Union[date, str]] = None
    expiration_date_gte: Optional[Union[date, str]] = None
    expiration_date_lte: Optional[Union[date, str]] = None
    root_symbol: Optional[str] = None
    type: Optional[ContractType] = None
    style: Optional[ExerciseStyle] = None
    strike_price_gte: Optional[str] = None
    strike_price_lte: Optional[str] = None

    limit: Optional[int] = None
    page_token: Optional[str] = None
````

## File: alpaca/trading/stream.py
````python
import asyncio
import json
import logging
import queue
from typing import Callable, Dict, Optional, Union

import websockets
from pydantic import BaseModel
from websockets.legacy import client as websockets_legacy

from alpaca.common import RawData
from alpaca.common.enums import BaseURL
from alpaca.trading import TradeUpdate

log = logging.getLogger(__name__)


class TradingStream:
    """
    This is a WebSocket client which allows you to streaming data from your trading account.

    Learn more here: https://alpaca.markets/docs/api-references/trading-api/streaming/

    If using paper keys, make sure to set ``paper`` to True when instantiating the client.
    """

    def __init__(
        self,
        api_key: str,
        secret_key: str,
        paper: bool = True,
        raw_data: bool = False,
        url_override: str = None,
        websocket_params: Optional[Dict] = None,
    ):
        self._api_key = api_key
        self._secret_key = secret_key
        self._trade_updates_handler = None
        self._endpoint = (
            url_override
            if url_override
            else BaseURL.TRADING_STREAM_PAPER if paper else BaseURL.TRADING_STREAM_LIVE
        )
        self._ws = None
        self._running = False
        self._loop = None
        self._raw_data = raw_data
        self._stop_stream_queue = queue.Queue()
        self._should_run = True
        self._websocket_params = {
            "ping_interval": 10,
            "ping_timeout": 180,
            "max_queue": 1024,
        }

        if websocket_params:
            self._websocket_params = websocket_params

    async def _connect(self):
        self._ws = await websockets_legacy.connect(
            self._endpoint, **self._websocket_params
        )

    async def _auth(self):
        await self._ws.send(
            json.dumps(
                {
                    "action": "authenticate",
                    "data": {
                        "key_id": self._api_key,
                        "secret_key": self._secret_key,
                    },
                }
            )
        )
        r = await self._ws.recv()
        msg = json.loads(r)
        if msg.get("data").get("status") != "authorized":
            raise ValueError("failed to authenticate")

    async def _dispatch(self, msg: Dict) -> None:
        """Distributes message from websocket connection to appropriate handler

        Args:
            msg (Dict): The message from the websocket connection
        """
        stream = msg.get("stream")
        if stream == "trade_updates":
            if self._trade_updates_handler:
                await self._trade_updates_handler(self._cast(msg))

    def _cast(self, msg: Dict) -> Union[BaseModel, RawData]:
        """Parses data from websocket message if raw_data is False, otherwise
        returns raw websocket message

        Args:
            msg (Dict): The message containing market data

        Returns:
            Union[BaseModel, RawData]: The raw or parsed live data
        """
        result = msg
        if not self._raw_data:
            result = TradeUpdate(**msg.get("data"))
        return result

    async def _subscribe_trade_updates(self) -> None:
        if self._trade_updates_handler:
            await self._ws.send(
                json.dumps({"action": "listen", "data": {"streams": ["trade_updates"]}})
            )

    def subscribe_trade_updates(self, handler: Callable):
        """
        Subscribes to trade updates for your trading account.

        Args:
            handler (Callable): The async handler that will receive trade update data.

        Returns:
            None
        """
        self._ensure_coroutine(handler)
        self._trade_updates_handler = handler
        if self._running:
            asyncio.run_coroutine_threadsafe(
                self._subscribe_trade_updates(), self._loop
            ).result()

    async def _start_ws(self):
        await self._connect()
        await self._auth()
        log.info(f"connected to: {self._endpoint}")
        await self._subscribe_trade_updates()

    async def _consume(self):
        while True:
            if not self._stop_stream_queue.empty():
                self._stop_stream_queue.get(timeout=1)
                await self.close()
                break
            else:
                try:
                    r = await asyncio.wait_for(self._ws.recv(), 5)
                    msg = json.loads(r)
                    await self._dispatch(msg)
                except asyncio.TimeoutError:
                    # ws.recv is hanging when no data is received. by using
                    # wait_for we break when no data is received, allowing us
                    # to break the loop when needed
                    pass

    async def _run_forever(self):
        self._loop = asyncio.get_running_loop()
        # do not start the websocket connection until we subscribe to something
        while not self._trade_updates_handler:
            if not self._stop_stream_queue.empty():
                self._stop_stream_queue.get(timeout=1)
                return
            await asyncio.sleep(0.1)
        log.info("started trading stream")
        self._should_run = True
        self._running = False
        while True:
            try:
                if not self._should_run:
                    log.info("Trading stream stopped")
                    return
                if not self._running:
                    log.info("starting trading websocket connection")
                    await self._start_ws()
                    self._running = True
                    await self._consume()
            except websockets.WebSocketException as wse:
                await self.close()
                self._running = False
                log.warning(
                    "trading stream websocket error, restarting "
                    + " connection: "
                    + str(wse)
                )
            except Exception as e:
                log.exception(
                    "error during websocket " "communication: {}".format(str(e))
                )
            finally:
                await asyncio.sleep(0.01)

    async def close(self) -> None:
        """Closes the websocket connection."""
        if self._ws:
            await self._ws.close()
            self._ws = None
            self._running = False

    async def stop_ws(self) -> None:
        """Signals websocket connection should close by adding a closing message to the stop_stream_queue"""
        self._should_run = False
        if self._stop_stream_queue.empty():
            self._stop_stream_queue.put_nowait({"should_stop": True})

    def stop(self) -> None:
        """Stops the websocket connection."""
        if self._loop.is_running():
            asyncio.run_coroutine_threadsafe(self.stop_ws(), self._loop).result()

    def run(self) -> None:
        """Starts up the websocket connection's event loop"""
        try:
            asyncio.run(self._run_forever())
        except KeyboardInterrupt:
            print("keyboard interrupt, bye")
            pass

    def _ensure_coroutine(self, handler: Callable) -> None:
        """Checks if a method is an asyncio coroutine method

        Args:
            handler (Callable): A method to be checked for coroutineness

        Raises:
            ValueError: Raised if the input method is not a coroutine
        """
        if not asyncio.iscoroutinefunction(handler):
            raise ValueError("handler must be a coroutine function")
````

## File: alpaca/__init__.py
````python
# placeholder for poetry-dynamic-versioning
__version__ = "0.0.0"
````

## File: tools/scripts/generate-docs.sh
````bash
#!/usr/bin/env bash

set -e

#make sure we're in the root of our repo
pushd "$(dirname "$0")"/../../docs >>/dev/null

set +e

#clean any local files to prevent cached errors
poetry run make clean

#run make html with a flag to make sphinx treat warnings as errors instead of generating incomplete docs
#we also run doctest to ensure any doctests are successful before generating html
poetry run make html doctest SPHINXOPTS="-W"
````

## File: .dockerignore
````
.dockerignore
Dockerfile
````

## File: .gitattributes
````
* text=auto
````

## File: .gitignore
````
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

#IDE configs
.idea
.vscode/

# Cloudflare stuff
Cloudflare_CA.pem
````

## File: .pre-commit-config.yaml
````yaml
# See https://pre-commit.com for more information
# See https://pre-commit.com/hooks.html for more hooks
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v3.2.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files
  - repo: local
    hooks:
      - id: black
        name: black
        language: system
        entry: "poetry run black --check alpaca/ tests/"
        pass_filenames: false
        always_run: true
      - id: pytest
        name: pytest
        language: system
        entry: "poetry run pytest"
        pass_filenames: false
        always_run: true
      - id: doc check
        name: sphinx doc check
        language: system
        entry: "./tools/scripts/generate-docs.sh"
        pass_filenames: false
        always_run: true
````

## File: cloudbuild.yaml
````yaml
steps:
- name: 'gcr.io/cloud-builders/docker'
  id: 'pull image cache'
  entrypoint: 'bash'
  args:
    - -c
    - |
      docker pull gcr.io/$PROJECT_ID/alpaca-py:deps || true

- name: 'gcr.io/cloud-builders/docker'
  id: 'deps build'
  args: [
    'build',
    '--target', 'deps',
    '-t', 'gcr.io/$PROJECT_ID/alpaca-py:deps',
    '--cache-from', 'gcr.io/$PROJECT_ID/alpaca-py:deps',
    '.'
  ]

- name: 'gcr.io/cloud-builders/docker'
  id: 'build image'
  args: [
    'build',
    '-t', 'gcr.io/$PROJECT_ID/alpaca-py:latest',
    '--cache-from', 'gcr.io/$PROJECT_ID/alpaca-py:deps',
    '.'
  ]

- name: 'gcr.io/cloud-builders/docker'
  id: 'push images'
  entrypoint: 'sh'
  args:
    - -c
    - |
      set -eu
      if [ "$TAG_NAME" = "" ] && [ "$BRANCH_NAME" = "master" ]; then
          docker tag gcr.io/$PROJECT_ID/alpaca-py:latest gcr.io/$PROJECT_ID/alpaca-py:${BRANCH_NAME}-latest
          docker push gcr.io/$PROJECT_ID/alpaca-py:${BRANCH_NAME}-latest
      fi

      if [ "$TAG_NAME" != "" ]; then
          docker tag gcr.io/$PROJECT_ID/alpaca-py:latest gcr.io/$PROJECT_ID/alpaca-py:$TAG_NAME
          docker push gcr.io/$PROJECT_ID/alpaca-py:$TAG_NAME
      else
          docker push gcr.io/$PROJECT_ID/alpaca-py:deps
          docker push gcr.io/$PROJECT_ID/alpaca-py:latest
      fi

- name: 'gcr.io/cloud-builders/kubectl'
  id: 'deploy to staging or master as appropriate'
  entrypoint: 'sh'
  secretEnv: ['SA_TOKEN_STAGING','SA_TOKEN_MASTER']
  args:
    - -c
    - |
      set -eu
      if [ "$TAG_NAME" = "" ] && [ "$BRANCH_NAME" = "master" ] ; then
        SA_TOKEN="$$SA_TOKEN_STAGING"
      elif [ "$TAG_NAME" != "" ]; then
        SA_TOKEN="$$SA_TOKEN_MASTER"
      fi
      if [ "$_KUBE_API_SERVER" != "" -a "$_KUBE_CA_CRT" != "" -a "$_KUBE_NAMESPACE" != "" -a "$_KUBE_DEPLOYMENT" != "" -a "$$SA_TOKEN" != "" ]; then
        echo "$_KUBE_CA_CRT" > /tmp/ca.crt
        if [ "$TAG_NAME" != "" ]; then
          kubectl --certificate-authority /tmp/ca.crt --server "$_KUBE_API_SERVER" --namespace "$_KUBE_NAMESPACE" --token "$$SA_TOKEN" set image deploy "$_KUBE_DEPLOYMENT" nginx=gcr.io/$PROJECT_ID/alpaca-py:$TAG_NAME
        fi
        kubectl --certificate-authority /tmp/ca.crt --server "$_KUBE_API_SERVER" --namespace "$_KUBE_NAMESPACE" --token "$$SA_TOKEN" rollout restart deploy "$_KUBE_DEPLOYMENT"
      fi


availableSecrets:
  secretManager:
    - versionName: projects/$PROJECT_ID/secrets/alpaca-py-staging-cloudbuild-kubernetes-sa-token/versions/latest
      env: 'SA_TOKEN_STAGING'
    - versionName: projects/$PROJECT_ID/secrets/alpaca-py-prod-cloudbuild-kubernetes-sa-token/versions/latest
      env: 'SA_TOKEN_MASTER'

timeout: 1200s
````

## File: CODEOWNERS
````
#
* @hiohiohio
````

## File: CONTRIBUTING.md
````markdown
Contributing to Alpaca-Py
=========================


Thank you for taking the time to contribute!
Alpaca-Py is currently in an early alpha phase, but we are very open to taking contributions!

## How do I file a bug/Ask a question/Request a feature?

We track these here on Github via our [issues](https://github.com/alpacahq/alpaca-py/issues/new/choose), with a template
for each of these cases that will ask you to fill out some information to better help us solve your issue.
(Note that not filling out the template or skipping questions is likely to just delay us being able to solve your issue
and will result in us having to ask you to fill out the missing information or close out your issue for being invalid.)

> **NOTE** that we can only solve issues with the SDK, if you are trying to report an issue with the API itself, then
> please open an issue over [here](https://github.com/alpacahq/Alpaca-API) instead.

## How to I contribute code?

1. Please fork this repo and create a branch for your changes
2. Please read the README steps on setting up the dev environment so that things like git pre-commit hooks are run on
   your code. This is to help prevent your PR getting rejected by the lint CI actions when you open your PR.
3. Code away
4. Open a PR with your changes!

That's the high level flow of it. Note that this repo uses merge commits so don't feel the need to squash your commits
before your pr.

### Dev setup

This project is managed via poetry so setup should be just running `poetry install`.

This repo is using [`pre-commit`](https://pre-commit.com/) to setup some checks to happen at commit time to keep the
repo clean. To set these up after you've run `poetry install` just run `poetry run pre-commit install` to have
pre-commit setup these hooks

## Coding Guidelines

### Formatting

This repo is using [Black](https://github.com/psf/black) as our formatter and style enforcer, if you're unsure if your
code will fit our style guide simply run

`poetry run black .`

from the root of the repo and Black will take care of formatting your code correctly for you.

### Conventions

We only have a few conventions we follow.

[//]: # (In the future put commit conventions here if we ever embrace them, ie conventional commits)

#### Models

We use [Pydantic](https://pydantic-docs.helpmanual.io/) for our models and for representing request objects. This lets
us add both type and custom validations to the models. If your PR needs to add a new model for some reason please make
sure it extends the `alpaca.common.models.ValidateBaseModel` class and implements a pydantic validator if needed to
ensure that models are always in a consistent state.

If what you're adding is a model for a request, IE `GetNewThingRequest` then please make sure it instead extends the
`alpaca.common.models.NonEmptyRequest` class. This class is a helper that extends the ValidateBaseModel to also add a
method called `to_request_fields` that eases the conversion of fields to safe HTTP request values.

#### Request Methods

Our request methods try to stick to a simple formula.

For example, lets take the Trading api method `remove_symbol_from_watchlist_by_id` and reverse engineer the naming here.
The url for this request is `DELETE /v2/watchlists/{watchlist_id}/{symbol}`

1. All url parameters shall be full parameters in the resulting method. So for our example we'll have a `watchlist_id`
   and `symbol` parameters.

2. Any GET/POST/PATCH/PUT parameters that a request can take should be turned into a new class that extends
   `alpaca.common.models.NonEmptyRequest`. Doing so will not only make the request method easier to write but also
   ensures that we have validation for the user almost for free from Pydantic. This also helps ensure that the addition
   of new fields here wont result in a breaking change.

   Our example doesn't have any DELETE parameters but if it did take any we would have a final parameter of a new type
   named `RemoveSymbolFromWatchlistRequest`.

3. Naming of the request method should be pretty obvious in most cases (`create_order`, `get_clock`, etc). But in
   certain cases, especially in the Broker module or when a request has multiple url parameters we try to follow a
   naming convention like the following:
   `{verb}_{noun}_by_{value}` or `{verb}_{noun1}_(for, from, to, etc)_{noun2}`or `{verb}_{noun1}_for_{noun2}_by_{value}`

   - step 1: is to get the verb we need. In this case its DELETE but for a more semantic name we'll use remove
   - step 2: what are the nouns we're working on, in this case its Watchlists and Symbols
   - step 3: The main noun in this case is Watchlist, and we specify which Watchlist we wish to update via its id, so we
     will add on a `by_id` to the end.

   and thus we end up with `remove_symbol_from_watchlist_by_id`.

> **NOTE**: Currently during the alpha phase of alpaca-py we haven't been strict on the above naming scheme. However,
> this **_will_** change in the future before we hit 1.0.0

And so the final method looks like:

```python
def remove_symbol_from_watchlist_by_id(self, watchlist_id: UUID, symbol: str) -> Watchlist:
```
````

## File: Dockerfile
````dockerfile
# Install dependencies only when needed
FROM python:3.11 AS deps

ARG POETRY_VERSION=1.6.1
ENV POETRY_VERSION ${POETRY_VERSION}

RUN pip install --no-cache-dir poetry==${POETRY_VERSION}

# Build the docs
FROM deps AS builder

WORKDIR /app

COPY . .

# for the config line below, see https://github.com/python-poetry/poetry/issues/7611#issuecomment-1747836233 (can be dropped with poetry >= 1.7.0)
RUN poetry config installer.max-workers 1
RUN poetry install

WORKDIR /app/docs

RUN poetry run make html

# Serve static files
FROM nginx:alpine

# COPY ./nginx.conf /etc/nginx/nginx.conf

COPY --from=builder /app/docs/_build/html /usr/share/nginx/html

ENTRYPOINT ["nginx", "-g", "daemon off;"]
````

## File: LICENSE
````
Apache License
                        Version 2.0, January 2004
                     http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

   "License" shall mean the terms and conditions for use, reproduction,
   and distribution as defined by Sections 1 through 9 of this document.

   "Licensor" shall mean the copyright owner or entity authorized by
   the copyright owner that is granting the License.

   "Legal Entity" shall mean the union of the acting entity and all
   other entities that control, are controlled by, or are under common
   control with that entity. For the purposes of this definition,
   "control" means (i) the power, direct or indirect, to cause the
   direction or management of such entity, whether by contract or
   otherwise, or (ii) ownership of fifty percent (50%) or more of the
   outstanding shares, or (iii) beneficial ownership of such entity.

   "You" (or "Your") shall mean an individual or Legal Entity
   exercising permissions granted by this License.

   "Source" form shall mean the preferred form for making modifications,
   including but not limited to software source code, documentation
   source, and configuration files.

   "Object" form shall mean any form resulting from mechanical
   transformation or translation of a Source form, including but
   not limited to compiled object code, generated documentation,
   and conversions to other media types.

   "Work" shall mean the work of authorship, whether in Source or
   Object form, made available under the License, as indicated by a
   copyright notice that is included in or attached to the work
   (an example is provided in the Appendix below).

   "Derivative Works" shall mean any work, whether in Source or Object
   form, that is based on (or derived from) the Work and for which the
   editorial revisions, annotations, elaborations, or other modifications
   represent, as a whole, an original work of authorship. For the purposes
   of this License, Derivative Works shall not include works that remain
   separable from, or merely link (or bind by name) to the interfaces of,
   the Work and Derivative Works thereof.

   "Contribution" shall mean any work of authorship, including
   the original version of the Work and any modifications or additions
   to that Work or Derivative Works thereof, that is intentionally
   submitted to Licensor for inclusion in the Work by the copyright owner
   or by an individual or Legal Entity authorized to submit on behalf of
   the copyright owner. For the purposes of this definition, "submitted"
   means any form of electronic, verbal, or written communication sent
   to the Licensor or its representatives, including but not limited to
   communication on electronic mailing lists, source code control systems,
   and issue tracking systems that are managed by, or on behalf of, the
   Licensor for the purpose of discussing and improving the Work, but
   excluding communication that is conspicuously marked or otherwise
   designated in writing by the copyright owner as "Not a Contribution."

   "Contributor" shall mean Licensor and any individual or Legal Entity
   on behalf of whom a Contribution has been received by Licensor and
   subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   copyright license to reproduce, prepare Derivative Works of,
   publicly display, publicly perform, sublicense, and distribute the
   Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   (except as stated in this section) patent license to make, have made,
   use, offer to sell, sell, import, and otherwise transfer the Work,
   where such license applies only to those patent claims licensable
   by such Contributor that are necessarily infringed by their
   Contribution(s) alone or by combination of their Contribution(s)
   with the Work to which such Contribution(s) was submitted. If You
   institute patent litigation against any entity (including a
   cross-claim or counterclaim in a lawsuit) alleging that the Work
   or a Contribution incorporated within the Work constitutes direct
   or contributory patent infringement, then any patent licenses
   granted to You under this License for that Work shall terminate
   as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the
   Work or Derivative Works thereof in any medium, with or without
   modifications, and in Source or Object form, provided that You
   meet the following conditions:

   (a) You must give any other recipients of the Work or
         Derivative Works a copy of this License; and

   (b) You must cause any modified files to carry prominent notices
         stating that You changed the files; and

   (c) You must retain, in the Source form of any Derivative Works
         that You distribute, all copyright, patent, trademark, and
         attribution notices from the Source form of the Work,
         excluding those notices that do not pertain to any part of
         the Derivative Works; and

   (d) If the Work includes a "NOTICE" text file as part of its
         distribution, then any Derivative Works that You distribute must
         include a readable copy of the attribution notices contained
         within such NOTICE file, excluding those notices that do not
         pertain to any part of the Derivative Works, in at least one
         of the following places: within a NOTICE text file distributed
         as part of the Derivative Works; within the Source form or
         documentation, if provided along with the Derivative Works; or,
         within a display generated by the Derivative Works, if and
         wherever such third-party notices normally appear. The contents
         of the NOTICE file are for informational purposes only and
         do not modify the License. You may add Your own attribution
         notices within Derivative Works that You distribute, alongside
         or as an addendum to the NOTICE text from the Work, provided
         that such additional attribution notices cannot be construed
         as modifying the License.

   You may add Your own copyright statement to Your modifications and
   may provide additional or different license terms and conditions
   for use, reproduction, or distribution of Your modifications, or
   for any such Derivative Works as a whole, provided Your use,
   reproduction, and distribution of the Work otherwise complies with
   the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise,
   any Contribution intentionally submitted for inclusion in the Work
   by You to the Licensor shall be under the terms and conditions of
   this License, without any additional terms or conditions.
   Notwithstanding the above, nothing herein shall supersede or modify
   the terms of any separate license agreement you may have executed
   with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade
   names, trademarks, service marks, or product names of the Licensor,
   except as required for reasonable and customary use in describing the
   origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or
   agreed to in writing, Licensor provides the Work (and each
   Contributor provides its Contributions) on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied, including, without limitation, any warranties or conditions
   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
   PARTICULAR PURPOSE. You are solely responsible for determining the
   appropriateness of using or redistributing the Work and assume any
   risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory,
   whether in tort (including negligence), contract, or otherwise,
   unless required by applicable law (such as deliberate and grossly
   negligent acts) or agreed to in writing, shall any Contributor be
   liable to You for damages, including any direct, indirect, special,
   incidental, or consequential damages of any character arising as a
   result of this License or out of the use or inability to use the
   Work (including but not limited to damages for loss of goodwill,
   work stoppage, computer failure or malfunction, or any and all
   other commercial damages or losses), even if such Contributor
   has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing
   the Work or Derivative Works thereof, You may choose to offer,
   and charge a fee for, acceptance of support, warranty, indemnity,
   or other liability obligations and/or rights consistent with this
   License. However, in accepting such obligations, You may act only
   on Your own behalf and on Your sole responsibility, not on behalf
   of any other Contributor, and only if You agree to indemnify,
   defend, and hold each Contributor harmless for any liability
   incurred by, or claims asserted against, such Contributor by reason
   of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS

APPENDIX: How to apply the Apache License to your work.

   To apply the Apache License to your work, attach the following
   boilerplate notice, with the fields enclosed by brackets "[]"
   replaced with your own identifying information. (Don't include
   the brackets!)  The text should be enclosed in the appropriate
   comment syntax for the file format. We also recommend that a
   file or class name and description of purpose be included on the
   same "printed page" as the copyright notice for easier
   identification within third-party archives.

Copyright 2022 Alpaca

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
````

## File: Makefile
````
# The default "help" goal nicely prints all the available goals based on the funny looking ## comments.
# Source: https://marmelab.com/blog/2016/02/29/auto-documented-makefile.html
.DEFAULT_GOAL := help
.PHONY: help
help:  ## Display this help
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'

.PHONY: install
install: ## Install the SDK and its dependencies using poetry
	poetry install

.PHONY: lint
lint: ## Run the linters
	poetry run black --check alpaca/ tests/

.PHONY: generate
generate: ## Generate the documentation
	./tools/scripts/generate-docs.sh

.PHONY: test
test: ## Run the unit tests
	poetry run pytest
````

## File: pyproject.toml
````toml
[tool.poetry]
name = "alpaca-py"
# placeholder for poetry-dynamic-versioning
version = "0.0.0"
description = "The Official Python SDK for Alpaca APIs"
authors = [
    "Rahul Chowdhury <rahul.chowdhury@alpaca.markets>",
]
readme = "README.md"
license = "Apache-2.0"
repository = "https://github.com/alpacahq/alpaca-py"
documentation = "https://alpaca.markets/docs/python-sdk/"
packages = [
    { include = "alpaca" }
]
include = [ "alpaca/py.typed" ]

[tool.poetry.dependencies]
python = "^3.8.0"
requests = "^2.30.0"
pydantic = "^2.0.3"
pandas = ">=1.5.3"
msgpack = "^1.0.3"
websockets = ">=10.4"
sseclient-py = "^1.7.2"


[tool.poetry.dev-dependencies]
pytest = "^7.1"
pytest-asyncio = "^0.23.7"
requests-mock = "^1.9.3"
black = "^24.3.0"
isort = "^5.10.1"
pre-commit = "^2.17.0"
furo = "^2022.2.14"
Sphinx = "^5.0.1"
sphinx-copybutton = "^0.5.0"
enum-tools = "^0.9.0"
sphinx-toolbox = "^3.1.2"

[build-system]
requires = ["poetry-core>=1.4.2", "poetry-dynamic-versioning>=1.0.0,<2.0.0"]
build-backend = "poetry_dynamic_versioning.backend"

[tool.poetry-dynamic-versioning]
enable=true

[tool.poetry-dynamic-versioning.substitution]
folders = [
  { path = "alpaca" }
]
````

## File: README.md
````markdown
[![Alpaca-py](https://github.com/alpacahq/alpaca-py/blob/master/docs/images/alpaca-py-banner.png?raw=true)](https://alpaca.markets/docs/python-sdk)

[![Downloads](https://pepy.tech/badge/alpaca-py/month)](https://pepy.tech/project/alpaca-py)
[![Python Versions](https://img.shields.io/pypi/pyversions/alpaca-py.svg?logo=python&logoColor=white)](https://pypi.org/project/alpaca-py)
[![GitHub](https://img.shields.io/github/license/alpacahq/alpaca-py?color=blue)](https://github.com/alpacahq/alpaca-py/blob/master/LICENSE.md)
[![PyPI](https://img.shields.io/pypi/v/alpaca-py?color=blue)](https://pypi.org/project/alpaca-py/)

## Table of Contents

- [About](#about)
- [Documentation](#documentation)
- [Installation](#installation)
- [Update](#update)
- [What's New?](#whats-new)
  1.  [Broker API](#broker-api-new)
  2.  [OOP Design](#oop-design)
  3.  [Data Validation](#data-validation)
  4.  [Many Clients](#many-clients)
- [API Keys](#api-keys)
  1.  [Trading and Market Data API Keys](#trading-api-keys)
  2.  [Broker API Keys](#trading-api-keys)
- [Usage](#usage)
  1.  [Broker API Example](#broker-api-example)
  2.  [Trading API Example](#trading-api-example)
  3.  [Market Data API Example](#data-api-example)
- [Contributing](https://github.com/alpacahq/alpaca-py/blob/master/CONTRIBUTING.md)
- [License](https://github.com/alpacahq/alpaca-py/blob/master/LICENSE)

## About <a name="about"></a>

Alpaca-py provides an interface for interacting with the API products Alpaca offers. These API products are provided as various REST, WebSocket and SSE endpoints that allow you to do everything from streaming market data to creating your own investment apps.

Learn more about the API products Alpaca offers at https://alpaca.markets.

## Documentation <a name="documentation"></a>

Alpaca-py has a supplementary documentation site which contains references for all clients, methods and models found in this codebase. The documentation
also contains examples to get started with alpaca-py.

You can find the documentation site here: https://alpaca.markets/sdks/python/getting_started.html

You can also find the API Reference of Alpaca APIs: https://docs.alpaca.markets/reference

## Installation <a name="installation"></a>

Alpaca-py is supported on Python 3.8+.  You can install Alpaca-py using pip.

Run the following command in your terminal.

```shell
  pip install alpaca-py
```

## Update <a name="update"></a>

If you already have Alpaca-py installed, and would like to use the latest version available...

Run the following command in your terminal:

```shell
  pip install alpaca-py --upgrade
```

## What‚Äôs New? <a name="whats-new"></a>

If you‚Äôve used the previous python SDK alpaca-trade-api, there are a few key differences to be aware of.

### Broker API <a name="broker-api-new"></a>

Alpaca-py lets you use Broker API to start building your investment apps! Learn more at the [Broker](https://docs.alpaca.markets/docs/about-broker-api) page.

### OOP Design <a name="oop-design"></a>

Alpaca-py uses a more OOP approach to submitting requests compared to the previous SDK. To submit a request, you will most likely need to create a request object containing the desired request data. Generally, there is a unique request model for each method.

Some examples of request models corresponding to methods:

- `GetOrdersRequest` for `TradingClient.get_orders()`
- `CryptoLatestOrderbookRequest` for `CryptoHistoricalDataClient.get_crypto_latest_orderbook()`

**Request Models Usage Example**

To get historical bar data for crypto, you will need to provide a `CryptoBarsRequest` object.

```python
from alpaca.data.historical import CryptoHistoricalDataClient
from alpaca.data.requests import CryptoBarsRequest
from alpaca.data.timeframe import TimeFrame
from datetime import datetime

# no keys required for crypto data
client = CryptoHistoricalDataClient()

request_params = CryptoBarsRequest(
                        symbol_or_symbols=["BTC/USD", "ETH/USD"],
                        timeframe=TimeFrame.Day,
                        start=datetime(2022, 7, 1)
                 )

bars = client.get_crypto_bars(request_params)
```

### Data Validation <a name="data-validation"></a>

Alpaca-py uses _pydantic_ to validate data models at run-time. This means if you are receiving request data via JSON from a client. You can handle parsing and validation through Alpaca‚Äôs request models. All request models can be instantiated by passing in data in dictionary format.

Here is a rough example of what is possible.

```python

 @app.route('/post_json', methods=['POST'])
 def do_trade():
     # ...

     order_data_json = request.get_json()

     # validate data
     MarketOrderRequest(**order_data_json)

     # ...
```

### Many Clients <a name="many-clients"></a>

Alpaca-py has a lot of client classes. There is a client for each API and even asset class specific clients (`StockHistoricalDataClient`, `CryptoDataStream`, `OptionHistoricalDataClient`). This requires you to pick and choose clients based on your needs.

**Broker API:** `BrokerClient`

**Trading API:** `TradingClient`

**Market Data API:** `StockHistoricalDataClient`, `CryptoHistoricalDataClient`, `NewsClient`, `OptionHistoricalDataClient`, `CryptoDataStream`, `StockDataStream`, `NewsDataStream`, `OptionDataStream`

## API Keys <a name="api-keys"></a>

### Trading and Market Data API <a name="trading-api-keys"></a>

In order to use Alpaca‚Äôs services you‚Äôll need to sign up for an Alpaca account and retrieve your API keys. Signing up is completely free and takes only a few minutes. Sandbox environments are available to test out the API. To use the sandbox environment, you will need to provide sandbox/paper keys. API keys are passed into Alpaca-py through either `TradingClient`, `StockHistoricalDataClient`, `CryptoHistoricalDataClient`, `NewsClient`, `OptionHistoricalDataClient`, `StockDataStream`, `CryptoDataStream`,`NewsDataStream`, or `OptionDataStream`.

### Broker API <a name="broker-api-keys"></a>

To use the Broker API, you will need to sign up for a broker account and retrieve your Broker API keys. The API keys can be found on the dashboard once you‚Äôve logged in. Alpaca also provides a sandbox environment to test out Broker API. To use the sandbox mode, provide your sandbox keys. Once you have your keys, you can pass them into `BrokerClient` to get started.

## Usage <a name="usage"></a>

Alpaca‚Äôs APIs allow you to do everything from building algorithmic trading strategies to building a full brokerage experience for your own end users. Here are some things you can do with Alpaca-py.

To view full descriptions and examples view the [documentation page](https://alpaca.markets/sdks/python/).

**Market Data API**: Access live and historical market data for 5000+ stocks, 20+ crypto, and options.

**Trading API**: Trade stock and crypto with lightning fast execution speeds.

**Broker API & Connect**: Build investment apps - from robo-advisors to brokerages.

### Broker API Example <a name="broker-api-example"></a>

**Listing All Accounts**

The `BrokerClient.list_accounts` method allows you to list all the brokerage accounts under your management. The method takes an optional parameter `search_parameters` which requires a `ListAccountsRequest` object. This parameter allows you to filter the list of accounts returned.

```python
from alpaca.broker.client import BrokerClient
from alpaca.broker.requests import ListAccountsRequest
from alpaca.broker.enums import AccountEntities

broker_client = BrokerClient('api-key', 'secret-key')

# search for accounts created after January 30th 2022.
# Response should contain Contact and Identity fields for each account.
filter = ListAccountsRequest(
                    created_after=datetime.datetime.strptime("2022-01-30", "%Y-%m-%d"),
                    entities=[AccountEntities.CONTACT, AccountEntities.IDENTITY]
                    )

accounts = broker_client.list_accounts(search_parameters=filter)
```

### Trading API Example <a name="trading-api-example"></a>

**Submitting an Order**

To create an order on Alpaca-py you must use an `OrderRequest` object. There are different `OrderRequest` objects based on the type of order you want to make. For market orders, there is `MarketOrderRequest`, limit orders have `LimitOrderRequest`, stop orders `StopOrderRequest`, and trailing stop orders have `TrailingStopOrderRequest`. Each order type have their own required parameters for a successful order.

```python
from alpaca.trading.client import TradingClient
from alpaca.trading.requests import MarketOrderRequest
from alpaca.trading.enums import OrderSide, TimeInForce

trading_client = TradingClient('api-key', 'secret-key')


# preparing order data
market_order_data = MarketOrderRequest(
                      symbol="BTC/USD",
                      qty=0.0001,
                      side=OrderSide.BUY,
                      time_in_force=TimeInForce.DAY
                  )

# Market order
market_order = trading_client.submit_order(
                order_data=market_order_data
                )
```

### Market Data API Example <a name="data-api-example"></a>

**Querying Historical Bar Data**

You can request bar data via the HistoricalDataClients. In this example, we query daily bar data for ‚ÄúBTC/USD‚Äù and ‚ÄúETH/USD‚Äù since July 1st 2022. You can convert the response to a multi-index pandas dataframe using the `.df` property. There are `StockHistoricalDataClient` and `OptionHistoricalDataClient` that you also could use to fetch equity/options historical data.

```python
from alpaca.data.historical import CryptoHistoricalDataClient
from alpaca.data.requests import CryptoBarsRequest
from alpaca.data.timeframe import TimeFrame
from datetime import datetime

# no keys required for crypto data
client = CryptoHistoricalDataClient()

request_params = CryptoBarsRequest(
                        symbol_or_symbols=["BTC/USD", "ETH/USD"],
                        timeframe=TimeFrame.Day,
                        start=datetime.strptime("2022-07-01", '%Y-%m-%d')
                        )

bars = client.get_crypto_bars(request_params)

# convert to dataframe
bars.df

```

**Querying News Data** <a name="news-client-example"></a>

You can query news data via the NewsClient. In this example, we query news data for ‚ÄúTSLA‚Äù since July 1st 2022. You can convert the response to a pandas dataframe using the `.df` property.

```python
from alpaca.data.historical.news import NewsClient
from alpaca.data.requests import NewsRequest
from datetime import datetime

# no keys required for news data
client = NewsClient()

request_params = NewsRequest(
                        symbols="TSLA",
                        start=datetime.strptime("2022-07-01", '%Y-%m-%d')
                        )

news = client.get_news(request_params)

# convert to dataframe
news.df

```

### Options Trading <a name="options-trading"></a>

We're excited to support options trading! Use this section to read up on Alpaca's options trading capabilities.
For more details, please refer to [our documentation page for options trading](https://docs.alpaca.markets/docs/options-trading)

There is an example jupyter notebook to explain methods of alpaca-py for options trading.

* [jupyter notebook: options trading basic example with alpaca-py](https://github.com/alpacahq/alpaca-py/blob/master/examples/options-trading-basic.ipynb)

### Jupyter Notebook Library <a name="colab-library"></a>

We have put together some examples in jupyter notebooks so that you can start developing today with alpaca-py right away!

* [Stocks](https://github.com/alpacahq/alpaca-py/blob/master/examples/stocks-trading-basic.ipynb)
* [Options](https://github.com/alpacahq/alpaca-py/blob/master/examples/options-trading-basic.ipynb)
* [Crypto](https://github.com/alpacahq/alpaca-py/blob/master/examples/crypto-trading-basic.ipynb)
* [Multi-Leg Options](https://github.com/alpacahq/alpaca-py/blob/master/examples/options-trading-mleg.ipynb)
````
